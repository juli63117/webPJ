{"ast":null,"code":"\"use strict\";\n\nconst moment = require(\"moment\");\nconst momentTz = require(\"moment-timezone\");\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-D424D23B-0933-425F-BC69-9C0E6724693C\");\n  BaseTypes.DATE.types.oracle = [\"TIMESTAMP\", \"TIMESTAMP WITH LOCAL TIME ZONE\"];\n  BaseTypes.STRING.types.oracle = [\"VARCHAR2\", \"NVARCHAR2\"];\n  BaseTypes.CHAR.types.oracle = [\"CHAR\", \"RAW\"];\n  BaseTypes.TEXT.types.oracle = [\"CLOB\"];\n  BaseTypes.TINYINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.SMALLINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.MEDIUMINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.INTEGER.types.oracle = [\"INTEGER\"];\n  BaseTypes.BIGINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.FLOAT.types.oracle = [\"BINARY_FLOAT\"];\n  BaseTypes.DATEONLY.types.oracle = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.oracle = [\"CHAR(1)\"];\n  BaseTypes.BLOB.types.oracle = [\"BLOB\"];\n  BaseTypes.DECIMAL.types.oracle = [\"NUMBER\"];\n  BaseTypes.UUID.types.oracle = [\"VARCHAR2\"];\n  BaseTypes.ENUM.types.oracle = [\"VARCHAR2\"];\n  BaseTypes.REAL.types.oracle = [\"BINARY_DOUBLE\"];\n  BaseTypes.DOUBLE.types.oracle = [\"BINARY_DOUBLE\"];\n  BaseTypes.JSON.types.oracle = [\"BLOB\"];\n  BaseTypes.GEOMETRY.types.oracle = false;\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this.length > 4e3 || this._binary && this._length > 2e3) {\n        warn(\"Oracle supports length up to 32764 bytes or characters; Be sure that your administrator has extended the MAX_STRING_SIZE parameter. Check https://docs.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-7B72E154-677A-4342-A1EA-C74C1EA928E6\");\n      }\n      if (!this._binary) {\n        return `NVARCHAR2(${this._length})`;\n      }\n      return `RAW(${this._length})`;\n    }\n    _stringify(value, options) {\n      if (this._binary) {\n        return options.escape(value.toString(\"hex\"));\n      }\n      return options.escape(value);\n    }\n    _getBindDef(oracledb) {\n      if (this._binary) {\n        return {\n          type: oracledb.DB_TYPE_RAW,\n          maxSize: this._length\n        };\n      }\n      return {\n        type: oracledb.DB_TYPE_VARCHAR,\n        maxSize: this._length\n      };\n    }\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n  STRING.prototype.escape = false;\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"CHAR(1)\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_CHAR,\n        maxSize: 1\n      };\n    }\n    _stringify(value) {\n      return value === true ? \"1\" : value === false ? \"0\" : value;\n    }\n    _sanitize(value) {\n      if (typeof value === \"string\") {\n        return value === \"1\" || value === \"true\" ? true : value === \"0\" || value === \"false\" ? false : value;\n      }\n      return super._sanitize(value);\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"VARCHAR2(36)\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_VARCHAR,\n        maxSize: 36\n      };\n    }\n  }\n  class NOW extends BaseTypes.NOW {\n    toSql() {\n      return \"SYSDATE\";\n    }\n    _stringify() {\n      return \"SYSDATE\";\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return \"VARCHAR2(512)\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_VARCHAR,\n        maxSize: 512\n      };\n    }\n  }\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      return \"CLOB\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_CLOB\n      };\n    }\n  }\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        warn(\"Oracle CHAR.BINARY datatype is not of Fixed Length.\");\n        return `RAW(${this._length})`;\n      }\n      return super.toSql();\n    }\n    _getBindDef(oracledb) {\n      if (this._binary) {\n        return {\n          type: oracledb.DB_TYPE_RAW,\n          maxSize: this._length\n        };\n      }\n      return {\n        type: oracledb.DB_TYPE_CHAR,\n        maxSize: this._length\n      };\n    }\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return \"TIMESTAMP WITH LOCAL TIME ZONE\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_TIMESTAMP_LTZ\n      };\n    }\n    _stringify(date, options) {\n      const format = \"YYYY-MM-DD HH24:MI:SS.FFTZH:TZM\";\n      date = this._applyTimezone(date, options);\n      const formatedDate = date.format(\"YYYY-MM-DD HH:mm:ss.SSS Z\");\n      return `TO_TIMESTAMP_TZ('${formatedDate}','${format}')`;\n    }\n    _applyTimezone(date, options) {\n      if (options.timezone) {\n        if (momentTz.tz.zone(options.timezone)) {\n          date = momentTz(date).tz(options.timezone);\n        } else {\n          date = moment(date).utcOffset(options.timezone);\n        }\n      } else {\n        date = momentTz(date);\n      }\n      return date;\n    }\n    static parse(value, options) {\n      if (value === null) {\n        return value;\n      }\n      if (options && moment.tz.zone(options.timezone)) {\n        value = moment.tz(value.toString(), options.timezone).toDate();\n      }\n      return value;\n    }\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n  DATE.prototype.escape = false;\n  class DECIMAL extends BaseTypes.DECIMAL {\n    toSql() {\n      let result = \"\";\n      if (this._length) {\n        result += `(${this._length}`;\n        if (typeof this._decimals === \"number\") {\n          result += `,${this._decimals}`;\n        }\n        result += \")\";\n      }\n      if (!this._length && this._precision) {\n        result += `(${this._precision}`;\n        if (typeof this._scale === \"number\") {\n          result += `,${this._scale}`;\n        }\n        result += \")\";\n      }\n      return `NUMBER${result}`;\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n  }\n  class TINYINT extends BaseTypes.TINYINT {\n    toSql() {\n      return \"NUMBER(3)\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n  }\n  class SMALLINT extends BaseTypes.SMALLINT {\n    toSql() {\n      if (this._length) {\n        return `NUMBER(${this._length},0)`;\n      }\n      return \"SMALLINT\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n  }\n  class MEDIUMINT extends BaseTypes.MEDIUMINT {\n    toSql() {\n      return \"NUMBER(8)\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n  }\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      if (!(this instanceof BIGINT)) return new BIGINT(length);\n      BaseTypes.BIGINT.apply(this, arguments);\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn(\"Oracle does not support BIGINT with options\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n    }\n    toSql() {\n      return \"NUMBER(19)\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n    _sanitize(value) {\n      if (typeof value === \"bigint\" || typeof value === \"number\") {\n        return value.toString();\n      }\n      return value;\n    }\n  }\n  class NUMBER extends BaseTypes.NUMBER {\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n  }\n  class INTEGER extends BaseTypes.INTEGER {\n    toSql() {\n      if (this._length) {\n        return `NUMBER(${this._length},0)`;\n      }\n      return \"INTEGER\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n  }\n  class FLOAT extends BaseTypes.FLOAT {\n    toSql() {\n      return \"BINARY_FLOAT\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_BINARY_FLOAT\n      };\n    }\n  }\n  class REAL extends BaseTypes.REAL {\n    toSql() {\n      return \"BINARY_DOUBLE\";\n    }\n    _stringify(value) {\n      if (value === Number.POSITIVE_INFINITY) {\n        return \"inf\";\n      }\n      if (value === Number.NEGATIVE_INFINITY) {\n        return \"-inf\";\n      }\n      return value;\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_BINARY_DOUBLE\n      };\n    }\n  }\n  class BLOB extends BaseTypes.BLOB {\n    _hexify(hex) {\n      return `'${hex}'`;\n    }\n    toSql() {\n      return \"BLOB\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_BLOB\n      };\n    }\n  }\n  class JSONTYPE extends BaseTypes.JSON {\n    toSql() {\n      return \"BLOB\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_BLOB\n      };\n    }\n    _stringify(value, options) {\n      return options.operation === \"where\" && typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n    _bindParam(value, options) {\n      return options.bindParam(Buffer.from(JSON.stringify(value)));\n    }\n  }\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (!(this instanceof DOUBLE)) return new BaseTypes.DOUBLE(length, decimals);\n      BaseTypes.DOUBLE.apply(this, arguments);\n      if (this._length || this._unsigned || this._zerofill) {\n        warn(\"Oracle does not support DOUBLE with options.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n      this.key = \"DOUBLE PRECISION\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_BINARY_DOUBLE\n      };\n    }\n    toSql() {\n      return \"BINARY_DOUBLE\";\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    parse(value) {\n      return moment(value).format(\"YYYY-MM-DD\");\n    }\n    _sanitize(value) {\n      if (value) {\n        return moment(value).format(\"YYYY-MM-DD\");\n      }\n      return value;\n    }\n    _stringify(date, options) {\n      if (date) {\n        const format = \"YYYY/MM/DD\";\n        return options.escape(`TO_DATE('${date}','${format}')`);\n      }\n      return options.escape(date);\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_DATE\n      };\n    }\n    _bindParam(value, options) {\n      if (typeof value === \"string\") {\n        return options.bindParam(new Date(value));\n      }\n      return options.bindParam(value);\n    }\n  }\n  DATEONLY.prototype.escape = false;\n  return {\n    BOOLEAN,\n    \"DOUBLE PRECISION\": DOUBLE,\n    DOUBLE,\n    STRING,\n    TINYINT,\n    SMALLINT,\n    MEDIUMINT,\n    BIGINT,\n    NUMBER,\n    INTEGER,\n    FLOAT,\n    UUID,\n    DATEONLY,\n    DATE,\n    NOW,\n    BLOB,\n    ENUM,\n    TEXT,\n    CHAR,\n    JSON: JSONTYPE,\n    REAL,\n    DECIMAL\n  };\n};","map":{"version":3,"names":["moment","require","momentTz","module","exports","BaseTypes","warn","ABSTRACT","bind","DATE","types","oracle","STRING","CHAR","TEXT","TINYINT","SMALLINT","MEDIUMINT","INTEGER","BIGINT","FLOAT","DATEONLY","BOOLEAN","BLOB","DECIMAL","UUID","ENUM","REAL","DOUBLE","JSON","GEOMETRY","toSql","length","_binary","_length","_stringify","value","options","escape","toString","_getBindDef","oracledb","type","DB_TYPE_RAW","maxSize","DB_TYPE_VARCHAR","_bindParam","bindParam","prototype","DB_TYPE_CHAR","_sanitize","NOW","DB_TYPE_CLOB","DB_TYPE_TIMESTAMP_LTZ","date","format","_applyTimezone","formatedDate","timezone","tz","zone","utcOffset","parse","toDate","result","_decimals","_precision","_scale","DB_TYPE_NUMBER","constructor","apply","arguments","_unsigned","_zerofill","NUMBER","DB_TYPE_BINARY_FLOAT","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","DB_TYPE_BINARY_DOUBLE","_hexify","hex","DB_TYPE_BLOB","JSONTYPE","operation","stringify","Buffer","from","decimals","key","DB_TYPE_DATE","Date"],"sources":["C:\\Users\\teply\\OneDrive\\Рабочий стол\\web_project\\client\\node_modules\\sequelize\\src\\dialects\\oracle\\data-types.js"],"sourcesContent":["// Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved\n\n'use strict';\n\nconst moment = require('moment');\nconst momentTz = require('moment-timezone');\n\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(\n    undefined,\n    'https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-D424D23B-0933-425F-BC69-9C0E6724693C'\n  );\n\n  BaseTypes.DATE.types.oracle = ['TIMESTAMP', 'TIMESTAMP WITH LOCAL TIME ZONE'];\n  BaseTypes.STRING.types.oracle = ['VARCHAR2', 'NVARCHAR2'];\n  BaseTypes.CHAR.types.oracle = ['CHAR', 'RAW'];\n  BaseTypes.TEXT.types.oracle = ['CLOB'];\n  BaseTypes.TINYINT.types.oracle = ['NUMBER'];\n  BaseTypes.SMALLINT.types.oracle = ['NUMBER'];\n  BaseTypes.MEDIUMINT.types.oracle = ['NUMBER'];\n  BaseTypes.INTEGER.types.oracle = ['INTEGER'];\n  BaseTypes.BIGINT.types.oracle = ['NUMBER'];\n  BaseTypes.FLOAT.types.oracle = ['BINARY_FLOAT'];\n  BaseTypes.DATEONLY.types.oracle = ['DATE'];\n  BaseTypes.BOOLEAN.types.oracle = ['CHAR(1)'];\n  BaseTypes.BLOB.types.oracle = ['BLOB'];\n  BaseTypes.DECIMAL.types.oracle = ['NUMBER'];\n  BaseTypes.UUID.types.oracle = ['VARCHAR2'];\n  BaseTypes.ENUM.types.oracle = ['VARCHAR2'];\n  BaseTypes.REAL.types.oracle = ['BINARY_DOUBLE'];\n  BaseTypes.DOUBLE.types.oracle = ['BINARY_DOUBLE'];\n  BaseTypes.JSON.types.oracle = ['BLOB'];\n  BaseTypes.GEOMETRY.types.oracle = false;\n\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this.length > 4000 || this._binary && this._length > 2000) {\n        warn(\n          'Oracle supports length up to 32764 bytes or characters; Be sure that your administrator has extended the MAX_STRING_SIZE parameter. Check https://docs.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-7B72E154-677A-4342-A1EA-C74C1EA928E6'\n        );\n      }\n      if (!this._binary) {\n        return `NVARCHAR2(${this._length})`;\n      }\n      return `RAW(${this._length})`;\n    }\n\n    _stringify(value, options) {\n      if (this._binary) {\n        // For Binary numbers we're converting a buffer to hex then\n        // sending it over the wire as a string,\n        // We pass it through escape function to remove un-necessary quotes\n        // this.format in insert/bulkinsert query calls stringify hence we need to convert binary buffer\n        // to hex string. Since this block is used by both bind (insert/bulkinsert) and\n        // non-bind (select query where clause) hence we need to\n        // have an operation that supports both\n        return options.escape(value.toString('hex'));\n      }\n      return options.escape(value);\n    }\n\n    _getBindDef(oracledb) {\n      if (this._binary) {\n        return { type: oracledb.DB_TYPE_RAW, maxSize: this._length };\n      }\n      return { type: oracledb.DB_TYPE_VARCHAR, maxSize: this._length };\n    }\n\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n\n  STRING.prototype.escape = false;\n\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return 'CHAR(1)';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_CHAR, maxSize: 1 };\n    }\n\n    _stringify(value) {\n      // If value is true we return '1'\n      // If value is false we return '0'\n      // Else we return it as is\n      // Converting number to char since in bindDef\n      // the type would be oracledb.DB_TYPE_CHAR\n      return value === true ? '1' : value === false ? '0' : value;\n    }\n\n    _sanitize(value) {\n      if (typeof value === 'string') {\n        // If value is a string we return true if among '1' and 'true'\n        // We return false if among '0' and 'false'\n        // Else return the value as is and let the DB raise error for invalid values\n        return value === '1' || value === 'true' ? true : value === '0' || value === 'false' ? false : value;\n      }\n      return super._sanitize(value);\n    }\n  }\n\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return 'VARCHAR2(36)';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_VARCHAR, maxSize: 36 };\n    }\n  }\n\n  class NOW extends BaseTypes.NOW {\n    toSql() {\n      return 'SYSDATE';\n    }\n\n    _stringify() {\n      return 'SYSDATE';\n    }\n  }\n\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return 'VARCHAR2(512)';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_VARCHAR, maxSize: 512 };\n    }\n  }\n\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      return 'CLOB';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_CLOB };\n    }\n  }\n\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        warn('Oracle CHAR.BINARY datatype is not of Fixed Length.');\n        return `RAW(${this._length})`;\n      }\n      return super.toSql();\n    }\n\n    _getBindDef(oracledb) {\n      if (this._binary) {\n        return { type: oracledb.DB_TYPE_RAW, maxSize: this._length };\n      }\n      return { type: oracledb.DB_TYPE_CHAR, maxSize: this._length };\n    }\n\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return 'TIMESTAMP WITH LOCAL TIME ZONE';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_TIMESTAMP_LTZ };\n    }\n\n    _stringify(date, options) {\n      const format = 'YYYY-MM-DD HH24:MI:SS.FFTZH:TZM';\n\n      date = this._applyTimezone(date, options);\n\n      const formatedDate = date.format('YYYY-MM-DD HH:mm:ss.SSS Z');\n\n      return `TO_TIMESTAMP_TZ('${formatedDate}','${format}')`;\n    }\n\n    _applyTimezone(date, options) {\n      if (options.timezone) {\n        if (momentTz.tz.zone(options.timezone)) {\n          date = momentTz(date).tz(options.timezone);\n        } else {\n          date = moment(date).utcOffset(options.timezone);\n        }\n      } else {\n        date = momentTz(date);\n      }\n      return date;\n    }\n\n    static parse(value, options) {\n      if (value === null) {\n        return value;\n      }\n      if (options && moment.tz.zone(options.timezone)) {\n        value = moment.tz(value.toString(), options.timezone).toDate();\n      }\n      return value;\n    }\n\n    /**\n     * avoids appending TO_TIMESTAMP_TZ in _stringify\n     *\n     * @override\n     */\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n\n  DATE.prototype.escape = false;\n\n  class DECIMAL extends BaseTypes.DECIMAL {\n    toSql() {\n      let result = '';\n      if (this._length) {\n        result += `(${this._length}`;\n        if (typeof this._decimals === 'number') {\n          result += `,${this._decimals}`;\n        }\n        result += ')';\n      }\n\n      if (!this._length && this._precision) {\n        result += `(${this._precision}`;\n        if (typeof this._scale === 'number') {\n          result += `,${this._scale}`;\n        }\n        result += ')';\n      }\n\n      return `NUMBER${result}`;\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n\n  class TINYINT extends BaseTypes.TINYINT {\n    toSql() {\n      return 'NUMBER(3)';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n\n  class SMALLINT extends BaseTypes.SMALLINT {\n    toSql() {\n      if (this._length) {\n        return `NUMBER(${this._length},0)`;\n      }\n      return 'SMALLINT';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n\n  class MEDIUMINT extends BaseTypes.MEDIUMINT {\n    toSql() {\n      return 'NUMBER(8)';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      if (!(this instanceof BIGINT)) return new BIGINT(length);\n      BaseTypes.BIGINT.apply(this, arguments);\n\n      // ORACLE does not support any options for bigint\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn('Oracle does not support BIGINT with options');\n        this._length = undefined;\n        this.options.length = undefined;\n        this._unsigned = undefined;\n        this._zerofill = undefined;\n      }\n    }\n\n    toSql() {\n      return 'NUMBER(19)';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n\n    _sanitize(value) {\n      if (typeof value === 'bigint' || typeof value === 'number') {\n        return value.toString();\n      }\n      return value;\n    }\n\n  }\n\n  class NUMBER extends BaseTypes.NUMBER {\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n\n  class INTEGER extends BaseTypes.INTEGER {\n    toSql() {\n      if (this._length) {\n        return `NUMBER(${this._length},0)`;\n      }\n      return 'INTEGER';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n\n  class FLOAT extends BaseTypes.FLOAT {\n    toSql() {\n      return 'BINARY_FLOAT';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BINARY_FLOAT };\n    }\n  }\n\n  class REAL extends BaseTypes.REAL {\n    toSql() {\n      return 'BINARY_DOUBLE';\n    }\n\n    // https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-0BA2E065-8006-426C-A3CB-1F6B0C8F283C\n    _stringify(value) {\n      if (value === Number.POSITIVE_INFINITY) {\n        return 'inf';\n      }\n      if (value === Number.NEGATIVE_INFINITY) {\n        return '-inf';\n      }\n      return value;\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BINARY_DOUBLE };\n    }\n  }\n\n  class BLOB extends BaseTypes.BLOB {\n    // Generic hexify returns X'${hex}' but Oracle expects '${hex}' for BLOB datatype\n    _hexify(hex) {\n      return `'${hex}'`;\n    }\n\n    toSql() {\n      return 'BLOB';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BLOB };\n    }\n  }\n\n  class JSONTYPE extends BaseTypes.JSON {\n    toSql() {\n      return 'BLOB';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BLOB };\n    }\n\n    _stringify(value, options) {\n      return options.operation === 'where' && typeof value === 'string' ? value : JSON.stringify(value);\n    }\n\n    _bindParam(value, options) {\n      return options.bindParam(Buffer.from(JSON.stringify(value)));\n    }\n  }\n\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (!(this instanceof DOUBLE)) return new BaseTypes.DOUBLE(length, decimals);\n      BaseTypes.DOUBLE.apply(this, arguments);\n\n      if (this._length || this._unsigned || this._zerofill) {\n        warn('Oracle does not support DOUBLE with options.');\n        this._length = undefined;\n        this.options.length = undefined;\n        this._unsigned = undefined;\n        this._zerofill = undefined;\n      }\n\n      this.key = 'DOUBLE PRECISION';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BINARY_DOUBLE };\n    }\n\n    toSql() {\n      return 'BINARY_DOUBLE';\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    parse(value) {\n      return moment(value).format('YYYY-MM-DD');\n    }\n\n    _sanitize(value) {\n      if (value) {\n        return moment(value).format('YYYY-MM-DD');\n      }\n      return value;\n    }\n\n    _stringify(date, options) {\n      // If date is not null only then we format the date\n      if (date) {\n        const format = 'YYYY/MM/DD';\n        return options.escape(`TO_DATE('${date}','${format}')`);\n      }\n      return options.escape(date);\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_DATE };\n    }\n\n    /**\n     * avoids appending TO_DATE in _stringify\n     *\n     * @override\n     */\n    _bindParam(value, options) {\n      if (typeof value === 'string') {\n        return options.bindParam(new Date(value));\n      }\n      return options.bindParam(value);\n\n    }\n  }\n\n  DATEONLY.prototype.escape = false;\n\n  return {\n    BOOLEAN,\n    'DOUBLE PRECISION': DOUBLE,\n    DOUBLE,\n    STRING,\n    TINYINT,\n    SMALLINT,\n    MEDIUMINT,\n    BIGINT,\n    NUMBER,\n    INTEGER,\n    FLOAT,\n    UUID,\n    DATEONLY,\n    DATE,\n    NOW,\n    BLOB,\n    ENUM,\n    TEXT,\n    CHAR,\n    JSON: JSONTYPE,\n    REAL,\n    DECIMAL\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}