{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\nconst AbstractConnectionManager = require(\"../abstract/connection-manager\");\nconst {\n  logger\n} = require(\"../../utils/logger\");\nconst debug = logger.debugContext(\"connection:pg\");\nconst sequelizeErrors = require(\"../../errors\");\nconst semver = require(\"semver\");\nconst dataTypes = require(\"../../data-types\");\nconst momentTz = require(\"moment-timezone\");\nconst {\n  promisify\n} = require(\"util\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 5432;\n    super(dialect, sequelize);\n    const pgLib = this._loadDialectModule(\"pg\");\n    this.lib = this.sequelize.config.native ? pgLib.native : pgLib;\n    this._clearDynamicOIDs();\n    this._clearTypeParser();\n    this.refreshTypeParser(dataTypes.postgres);\n  }\n  _refreshTypeParser(dataType) {\n    const arrayParserBuilder = parser2 => {\n      return value => this.lib.types.arrayParser.create(value, parser2).parse();\n    };\n    const rangeParserBuilder = parser2 => {\n      return value => dataType.parse(value, {\n        parser: parser2\n      });\n    };\n    if (dataType.key.toLowerCase() === \"range\") {\n      for (const name in this.nameOidMap) {\n        const entry = this.nameOidMap[name];\n        if (!entry.rangeOid) continue;\n        const rangeParser = rangeParserBuilder(this.getTypeParser(entry.oid));\n        const arrayRangeParser = arrayParserBuilder(rangeParser);\n        this.oidParserMap.set(entry.rangeOid, rangeParser);\n        if (!entry.arrayRangeOid) continue;\n        this.oidParserMap.set(entry.arrayRangeOid, arrayRangeParser);\n      }\n      return;\n    }\n    const parser = value => dataType.parse(value);\n    const arrayParser = arrayParserBuilder(parser);\n    if (dataType.key.toLowerCase() === \"enum\") {\n      this.enumOids.oids.forEach(oid => {\n        this.oidParserMap.set(oid, parser);\n      });\n      this.enumOids.arrayOids.forEach(arrayOid => {\n        this.oidParserMap.set(arrayOid, arrayParser);\n      });\n      return;\n    }\n    dataType.types.postgres.forEach(name => {\n      if (!this.nameOidMap[name]) return;\n      this.oidParserMap.set(this.nameOidMap[name].oid, parser);\n      if (!this.nameOidMap[name].arrayOid) return;\n      this.oidParserMap.set(this.nameOidMap[name].arrayOid, arrayParser);\n    });\n  }\n  _clearTypeParser() {\n    this.oidParserMap = /* @__PURE__ */new Map();\n  }\n  getTypeParser(oid, ...args) {\n    if (this.oidParserMap.get(oid)) return this.oidParserMap.get(oid);\n    return this.lib.types.getTypeParser(oid, ...args);\n  }\n  async connect(config) {\n    config.user = config.username;\n    const connectionConfig = _.pick(config, [\"user\", \"password\", \"host\", \"database\", \"port\"]);\n    connectionConfig.types = {\n      getTypeParser: ConnectionManager.prototype.getTypeParser.bind(this)\n    };\n    if (config.dialectOptions) {\n      _.merge(connectionConfig, _.pick(config.dialectOptions, [\"application_name\", \"ssl\", \"client_encoding\", \"binary\", \"keepAlive\", \"statement_timeout\", \"query_timeout\", \"connectionTimeoutMillis\", \"idle_in_transaction_session_timeout\", \"lock_timeout\", \"options\", \"stream\"]));\n    }\n    const connection = await new Promise((resolve, reject) => {\n      let responded = false;\n      const connection2 = new this.lib.Client(connectionConfig);\n      const parameterHandler = message => {\n        switch (message.parameterName) {\n          case \"server_version\":\n            if (this.sequelize.options.databaseVersion === 0) {\n              const version = semver.coerce(message.parameterValue).version;\n              this.sequelize.options.databaseVersion = semver.valid(version) ? version : this.dialect.defaultVersion;\n            }\n            break;\n          case \"standard_conforming_strings\":\n            connection2[\"standard_conforming_strings\"] = message.parameterValue;\n            break;\n        }\n      };\n      const endHandler = () => {\n        debug(\"connection timeout\");\n        if (!responded) {\n          reject(new sequelizeErrors.ConnectionTimedOutError(new Error(\"Connection timed out\")));\n        }\n      };\n      connection2.once(\"end\", endHandler);\n      if (!this.sequelize.config.native) {\n        connection2.connection.on(\"parameterStatus\", parameterHandler);\n      }\n      connection2.connect(err => {\n        responded = true;\n        if (!this.sequelize.config.native) {\n          connection2.connection.removeListener(\"parameterStatus\", parameterHandler);\n        }\n        if (err) {\n          if (err.code) {\n            switch (err.code) {\n              case \"ECONNREFUSED\":\n                reject(new sequelizeErrors.ConnectionRefusedError(err));\n                break;\n              case \"ENOTFOUND\":\n                reject(new sequelizeErrors.HostNotFoundError(err));\n                break;\n              case \"EHOSTUNREACH\":\n                reject(new sequelizeErrors.HostNotReachableError(err));\n                break;\n              case \"EINVAL\":\n                reject(new sequelizeErrors.InvalidConnectionError(err));\n                break;\n              default:\n                reject(new sequelizeErrors.ConnectionError(err));\n                break;\n            }\n          } else {\n            reject(new sequelizeErrors.ConnectionError(err));\n          }\n        } else {\n          debug(\"connection acquired\");\n          connection2.removeListener(\"end\", endHandler);\n          resolve(connection2);\n        }\n      });\n    });\n    connection.on(\"error\", error => {\n      connection._invalid = true;\n      debug(`connection error ${error.code || error.message}`);\n      this.pool.destroy(connection);\n    });\n    let query = \"\";\n    if (this.sequelize.options.standardConformingStrings !== false && connection[\"standard_conforming_strings\"] !== \"on\") {\n      query += \"SET standard_conforming_strings=on;\";\n    }\n    if (this.sequelize.options.clientMinMessages !== void 0) {\n      console.warn('Usage of \"options.clientMinMessages\" is deprecated and will be removed in v7.');\n      console.warn('Please use the sequelize option \"dialectOptions.clientMinMessages\" instead.');\n    }\n    if (!(config.dialectOptions && config.dialectOptions.clientMinMessages && config.dialectOptions.clientMinMessages.toLowerCase() === \"ignore\" || this.sequelize.options.clientMinMessages === false)) {\n      const clientMinMessages = config.dialectOptions && config.dialectOptions.clientMinMessages || this.sequelize.options.clientMinMessages || \"warning\";\n      query += `SET client_min_messages TO ${clientMinMessages};`;\n    }\n    if (!this.sequelize.config.keepDefaultTimezone) {\n      const isZone = !!momentTz.tz.zone(this.sequelize.options.timezone);\n      if (isZone) {\n        query += `SET TIME ZONE '${this.sequelize.options.timezone}';`;\n      } else {\n        query += `SET TIME ZONE INTERVAL '${this.sequelize.options.timezone}' HOUR TO MINUTE;`;\n      }\n    }\n    if (query) {\n      await connection.query(query);\n    }\n    if (Object.keys(this.nameOidMap).length === 0 && this.enumOids.oids.length === 0 && this.enumOids.arrayOids.length === 0) {\n      await this._refreshDynamicOIDs(connection);\n    }\n    return connection;\n  }\n  async disconnect(connection) {\n    if (connection._ending) {\n      debug(\"connection tried to disconnect but was already at ENDING state\");\n      return;\n    }\n    return await promisify(callback => connection.end(callback))();\n  }\n  validate(connection) {\n    return !connection._invalid && !connection._ending;\n  }\n  async _refreshDynamicOIDs(connection) {\n    const databaseVersion = this.sequelize.options.databaseVersion;\n    const supportedVersion = \"8.3.0\";\n    if ((databaseVersion && semver.gte(databaseVersion, supportedVersion)) === false) {\n      return;\n    }\n    const results = await (connection || this.sequelize).query(\"WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));\");\n    let result = Array.isArray(results) ? results.pop() : results;\n    if (Array.isArray(result)) {\n      if (result[0].command === \"SET\") {\n        result = result.pop();\n      }\n    }\n    const newNameOidMap = {};\n    const newEnumOids = {\n      oids: [],\n      arrayOids: []\n    };\n    for (const row of result.rows) {\n      if (row.typtype === \"e\") {\n        newEnumOids.oids.push(row.oid);\n        if (row.typarray) newEnumOids.arrayOids.push(row.typarray);\n        continue;\n      }\n      newNameOidMap[row.typname] = {\n        oid: row.oid\n      };\n      if (row.typarray) newNameOidMap[row.typname].arrayOid = row.typarray;\n      if (row.rngtypid) {\n        newNameOidMap[row.typname].rangeOid = row.rngtypid;\n        if (row.rngtyparray) newNameOidMap[row.typname].arrayRangeOid = row.rngtyparray;\n      }\n    }\n    this.nameOidMap = newNameOidMap;\n    this.enumOids = newEnumOids;\n    this.refreshTypeParser(dataTypes.postgres);\n  }\n  _clearDynamicOIDs() {\n    this.nameOidMap = {};\n    this.enumOids = {\n      oids: [],\n      arrayOids: []\n    };\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"names":["_","require","AbstractConnectionManager","logger","debug","debugContext","sequelizeErrors","semver","dataTypes","momentTz","promisify","ConnectionManager","constructor","dialect","sequelize","config","port","pgLib","_loadDialectModule","lib","native","_clearDynamicOIDs","_clearTypeParser","refreshTypeParser","postgres","_refreshTypeParser","dataType","arrayParserBuilder","parser2","value","types","arrayParser","create","parse","rangeParserBuilder","parser","key","toLowerCase","name","nameOidMap","entry","rangeOid","rangeParser","getTypeParser","oid","arrayRangeParser","oidParserMap","set","arrayRangeOid","enumOids","oids","forEach","arrayOids","arrayOid","Map","args","get","connect","user","username","connectionConfig","pick","prototype","bind","dialectOptions","merge","connection","Promise","resolve","reject","responded","connection2","Client","parameterHandler","message","parameterName","options","databaseVersion","version","coerce","parameterValue","valid","defaultVersion","endHandler","ConnectionTimedOutError","Error","once","on","err","removeListener","code","ConnectionRefusedError","HostNotFoundError","HostNotReachableError","InvalidConnectionError","ConnectionError","error","_invalid","pool","destroy","query","standardConformingStrings","clientMinMessages","console","warn","keepDefaultTimezone","isZone","tz","zone","timezone","Object","keys","length","_refreshDynamicOIDs","disconnect","_ending","callback","end","validate","supportedVersion","gte","results","result","Array","isArray","pop","command","newNameOidMap","newEnumOids","row","rows","typtype","push","typarray","typname","rngtypid","rngtyparray","module","exports","default"],"sources":["C:\\Users\\teply\\OneDrive\\Рабочий стол\\web_project\\client\\node_modules\\sequelize\\src\\dialects\\postgres\\connection-manager.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst { logger } = require('../../utils/logger');\nconst debug = logger.debugContext('connection:pg');\nconst sequelizeErrors = require('../../errors');\nconst semver = require('semver');\nconst dataTypes = require('../../data-types');\nconst momentTz = require('moment-timezone');\nconst { promisify } = require('util');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 5432;\n    super(dialect, sequelize);\n\n    const pgLib = this._loadDialectModule('pg');\n    this.lib = this.sequelize.config.native ? pgLib.native : pgLib;\n\n    this._clearDynamicOIDs();\n    this._clearTypeParser();\n    this.refreshTypeParser(dataTypes.postgres);\n  }\n\n  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n  _refreshTypeParser(dataType) {\n    const arrayParserBuilder = parser => {\n      return value => this.lib.types.arrayParser.create(value, parser).parse();\n    };\n    const rangeParserBuilder = parser => {\n      return value => dataType.parse(value, { parser });\n    };\n\n    // Set range parsers\n    if (dataType.key.toLowerCase() === 'range') {\n      for (const name in this.nameOidMap) {\n        const entry = this.nameOidMap[name];\n        if (! entry.rangeOid) continue;\n\n        const rangeParser = rangeParserBuilder(this.getTypeParser(entry.oid));\n        const arrayRangeParser = arrayParserBuilder(rangeParser);\n\n        this.oidParserMap.set(entry.rangeOid, rangeParser);\n        if (! entry.arrayRangeOid) continue;\n        this.oidParserMap.set(entry.arrayRangeOid, arrayRangeParser);\n      }\n      return;\n    }\n\n    // Create parsers for normal or enum data types\n    const parser = value => dataType.parse(value);\n    const arrayParser = arrayParserBuilder(parser);\n\n    // Set enum parsers\n    if (dataType.key.toLowerCase() === 'enum') {\n      this.enumOids.oids.forEach(oid => {\n        this.oidParserMap.set(oid, parser);\n      });\n      this.enumOids.arrayOids.forEach(arrayOid => {\n        this.oidParserMap.set(arrayOid, arrayParser);\n      });\n      return;\n    }\n\n    // Set parsers for normal data types\n    dataType.types.postgres.forEach(name => {\n      if (! this.nameOidMap[name]) return;\n      this.oidParserMap.set(this.nameOidMap[name].oid, parser);\n\n      if (! this.nameOidMap[name].arrayOid) return;\n      this.oidParserMap.set(this.nameOidMap[name].arrayOid, arrayParser);\n    });\n  }\n\n  _clearTypeParser() {\n    this.oidParserMap = new Map();\n  }\n\n  getTypeParser(oid, ...args) {\n    if (this.oidParserMap.get(oid)) return this.oidParserMap.get(oid);\n\n    return this.lib.types.getTypeParser(oid, ...args);\n  }\n\n  async connect(config) {\n    config.user = config.username;\n    const connectionConfig = _.pick(config, [\n      'user', 'password', 'host', 'database', 'port'\n    ]);\n\n    connectionConfig.types = {\n      getTypeParser: ConnectionManager.prototype.getTypeParser.bind(this)\n    };\n\n    if (config.dialectOptions) {\n      _.merge(connectionConfig,\n        _.pick(config.dialectOptions, [\n        // see [http://www.postgresql.org/docs/9.3/static/runtime-config-logging.html#GUC-APPLICATION-NAME]\n          'application_name',\n          // choose the SSL mode with the PGSSLMODE environment variable\n          // object format: [https://github.com/brianc/node-postgres/blob/ee19e74ffa6309c9c5e8e01746261a8f651661f8/lib/connection.js#L79]\n          // see also [http://www.postgresql.org/docs/9.3/static/libpq-ssl.html]\n          'ssl',\n          // In addition to the values accepted by the corresponding server,\n          // you can use \"auto\" to determine the right encoding from the\n          // current locale in the client (LC_CTYPE environment variable on Unix systems)\n          'client_encoding',\n          // !! DO NOT SET THIS TO TRUE !!\n          // (unless you know what you're doing)\n          // see [http://www.postgresql.org/message-id/flat/bc9549a50706040852u27633f41ib1e6b09f8339d845@mail.gmail.com#bc9549a50706040852u27633f41ib1e6b09f8339d845@mail.gmail.com]\n          'binary',\n          // This should help with backends incorrectly considering idle clients to be dead and prematurely disconnecting them.\n          // this feature has been added in pg module v6.0.0, check pg/CHANGELOG.md\n          'keepAlive',\n          // Times out queries after a set time in milliseconds in the database end. Added in pg v7.3\n          'statement_timeout',\n          // Times out queries after a set time in milliseconds in client end, query would be still running in database end.\n          'query_timeout',\n          // Number of milliseconds to wait for connection, default is no timeout.\n          'connectionTimeoutMillis',\n          // Terminate any session with an open transaction that has been idle for longer than the specified duration in milliseconds. Added in pg v7.17.0 only supported in postgres >= 10\n          'idle_in_transaction_session_timeout',\n          // Maximum wait time for lock requests in milliseconds. Added in pg v8.8.0.\n          'lock_timeout',\n          // Postgres allows additional session variables to be configured in the connection string in the `options` param.\n          // see [https://www.postgresql.org/docs/14/libpq-connect.html#LIBPQ-CONNECT-OPTIONS]\n          'options',\n          // The stream acts as a user-defined socket factory for postgres. In particular, it enables IAM autentication\n          // with Google Cloud SQL. see: https://github.com/sequelize/sequelize/issues/16001#issuecomment-1561136388\n          'stream',\n        ]));\n    }\n\n    const connection = await new Promise((resolve, reject) => {\n      let responded = false;\n\n      const connection = new this.lib.Client(connectionConfig);\n\n      const parameterHandler = message => {\n        switch (message.parameterName) {\n          case 'server_version':\n            if (this.sequelize.options.databaseVersion === 0) {\n              const version = semver.coerce(message.parameterValue).version;\n              this.sequelize.options.databaseVersion = semver.valid(version)\n                ? version\n                : this.dialect.defaultVersion;\n            }\n            break;\n          case 'standard_conforming_strings':\n            connection['standard_conforming_strings'] = message.parameterValue;\n            break;\n        }\n      };\n\n      const endHandler = () => {\n        debug('connection timeout');\n        if (!responded) {\n          reject(new sequelizeErrors.ConnectionTimedOutError(new Error('Connection timed out')));\n        }\n      };\n\n      // If we didn't ever hear from the client.connect() callback the connection timeout\n      // node-postgres does not treat this as an error since no active query was ever emitted\n      connection.once('end', endHandler);\n\n      if (!this.sequelize.config.native) {\n        // Receive various server parameters for further configuration\n        connection.connection.on('parameterStatus', parameterHandler);\n      }\n\n      connection.connect(err => {\n        responded = true;\n\n        if (!this.sequelize.config.native) {\n          // remove parameter handler\n          connection.connection.removeListener('parameterStatus', parameterHandler);\n        }\n\n        if (err) {\n          if (err.code) {\n            switch (err.code) {\n              case 'ECONNREFUSED':\n                reject(new sequelizeErrors.ConnectionRefusedError(err));\n                break;\n              case 'ENOTFOUND':\n                reject(new sequelizeErrors.HostNotFoundError(err));\n                break;\n              case 'EHOSTUNREACH':\n                reject(new sequelizeErrors.HostNotReachableError(err));\n                break;\n              case 'EINVAL':\n                reject(new sequelizeErrors.InvalidConnectionError(err));\n                break;\n              default:\n                reject(new sequelizeErrors.ConnectionError(err));\n                break;\n            }\n          } else {\n            reject(new sequelizeErrors.ConnectionError(err));\n          }\n        } else {\n          debug('connection acquired');\n          connection.removeListener('end', endHandler);\n          resolve(connection);\n        }\n      });\n    });\n\n    // Don't let a Postgres restart (or error) to take down the whole app\n    connection.on('error', error => {\n      connection._invalid = true;\n      debug(`connection error ${error.code || error.message}`);\n      this.pool.destroy(connection);\n    });\n\n    let query = '';\n\n    if (this.sequelize.options.standardConformingStrings !== false && connection['standard_conforming_strings'] !== 'on') {\n      // Disable escape characters in strings\n      // see https://github.com/sequelize/sequelize/issues/3545 (security issue)\n      // see https://www.postgresql.org/docs/current/static/runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS\n      query += 'SET standard_conforming_strings=on;';\n    }\n\n    if (this.sequelize.options.clientMinMessages !== undefined) {\n      console.warn('Usage of \"options.clientMinMessages\" is deprecated and will be removed in v7.');\n      console.warn('Please use the sequelize option \"dialectOptions.clientMinMessages\" instead.');\n    }\n\n    // Redshift dosen't support client_min_messages, use 'ignore' to skip this settings.\n    // If no option, the default value in sequelize is 'warning'\n    if ( !( config.dialectOptions && config.dialectOptions.clientMinMessages && config.dialectOptions.clientMinMessages.toLowerCase() === 'ignore' ||\n            this.sequelize.options.clientMinMessages === false ) ) {\n      const clientMinMessages = config.dialectOptions && config.dialectOptions.clientMinMessages || this.sequelize.options.clientMinMessages || 'warning';\n      query += `SET client_min_messages TO ${clientMinMessages};`;\n\n    }\n\n    if (!this.sequelize.config.keepDefaultTimezone) {\n      const isZone = !!momentTz.tz.zone(this.sequelize.options.timezone);\n      if (isZone) {\n        query += `SET TIME ZONE '${this.sequelize.options.timezone}';`;\n      } else {\n        query += `SET TIME ZONE INTERVAL '${this.sequelize.options.timezone}' HOUR TO MINUTE;`;\n      }\n    }\n\n    if (query) {\n      await connection.query(query);\n    }\n    if (Object.keys(this.nameOidMap).length === 0 &&\n      this.enumOids.oids.length === 0 &&\n      this.enumOids.arrayOids.length === 0) {\n      await this._refreshDynamicOIDs(connection);\n    }\n\n    return connection;\n  }\n\n  async disconnect(connection) {\n    if (connection._ending) {\n      debug('connection tried to disconnect but was already at ENDING state');\n      return;\n    }\n\n    return await promisify(callback => connection.end(callback))();\n  }\n\n  validate(connection) {\n    return !connection._invalid && !connection._ending;\n  }\n\n  async _refreshDynamicOIDs(connection) {\n    const databaseVersion = this.sequelize.options.databaseVersion;\n    const supportedVersion = '8.3.0';\n\n    // Check for supported version\n    if ( (databaseVersion && semver.gte(databaseVersion, supportedVersion)) === false) {\n      return;\n    }\n\n    const results = await (connection || this.sequelize).query(\n      'WITH ranges AS (' +\n      '  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,' +\n      '         pg_type.typarray AS rngtyparray, pg_range.rngsubtype' +\n      '    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid' +\n      ')' +\n      'SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,' +\n      '       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray' +\n      '  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype' +\n      ' WHERE (pg_type.typtype IN(\\'b\\', \\'e\\'));'\n    );\n\n    let result = Array.isArray(results) ? results.pop() : results;\n\n    // When searchPath is prepended then two statements are executed and the result is\n    // an array of those two statements. First one is the SET search_path and second is\n    // the SELECT query result.\n    if (Array.isArray(result)) {\n      if (result[0].command === 'SET') {\n        result = result.pop();\n      }\n    }\n\n    const newNameOidMap = {};\n    const newEnumOids = { oids: [], arrayOids: [] };\n\n    for (const row of result.rows) {\n      // Mapping enums, handled separatedly\n      if (row.typtype === 'e') {\n        newEnumOids.oids.push(row.oid);\n        if (row.typarray) newEnumOids.arrayOids.push(row.typarray);\n        continue;\n      }\n\n      // Mapping base types and their arrays\n      newNameOidMap[row.typname] = { oid: row.oid };\n      if (row.typarray) newNameOidMap[row.typname].arrayOid = row.typarray;\n\n      // Mapping ranges(of base types) and their arrays\n      if (row.rngtypid) {\n        newNameOidMap[row.typname].rangeOid = row.rngtypid;\n        if (row.rngtyparray) newNameOidMap[row.typname].arrayRangeOid = row.rngtyparray;\n      }\n    }\n\n    // Replace all OID mappings. Avoids temporary empty OID mappings.\n    this.nameOidMap = newNameOidMap;\n    this.enumOids = newEnumOids;\n\n    this.refreshTypeParser(dataTypes.postgres);\n  }\n\n  _clearDynamicOIDs() {\n    this.nameOidMap = {};\n    this.enumOids = { oids: [], arrayOids: [] };\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}