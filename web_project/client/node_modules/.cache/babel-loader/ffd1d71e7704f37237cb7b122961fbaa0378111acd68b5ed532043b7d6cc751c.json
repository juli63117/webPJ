{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst sequelizeErrors = require(\"../../errors\");\nconst QueryTypes = require(\"../../query-types\");\nconst {\n  QueryInterface\n} = require(\"../abstract/query-interface\");\nconst {\n  cloneDeep\n} = require(\"../../utils\");\nconst _ = require(\"lodash\");\nclass SQLiteQueryInterface extends QueryInterface {\n  async removeColumn(tableName, attributeName, options) {\n    options = options || {};\n    const fields = await this.describeTable(tableName, options);\n    delete fields[attributeName];\n    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(\";\").filter(q => q !== \"\");\n    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, __spreadValues({\n      raw: true\n    }, options));\n  }\n  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    options = options || {};\n    const fields = await this.describeTable(tableName, options);\n    Object.assign(fields[attributeName], this.normalizeAttribute(dataTypeOrOptions));\n    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(\";\").filter(q => q !== \"\");\n    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, __spreadValues({\n      raw: true\n    }, options));\n  }\n  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    const fields = await this.assertTableHasColumn(tableName, attrNameBefore, options);\n    fields[attrNameAfter] = __spreadValues({}, fields[attrNameBefore]);\n    delete fields[attrNameBefore];\n    const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, attrNameAfter, fields);\n    const subQueries = sql.split(\";\").filter(q => q !== \"\");\n    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, __spreadValues({\n      raw: true\n    }, options));\n  }\n  async removeConstraint(tableName, constraintName, options) {\n    let createTableSql;\n    const constraints = await this.showConstraint(tableName, constraintName);\n    const constraint = constraints.find(constaint => constaint.constraintName === constraintName);\n    if (!constraint) {\n      throw new sequelizeErrors.UnknownConstraintError({\n        message: `Constraint ${constraintName} on table ${tableName} does not exist`,\n        constraint: constraintName,\n        table: tableName\n      });\n    }\n    createTableSql = constraint.sql;\n    constraint.constraintName = this.queryGenerator.quoteIdentifier(constraint.constraintName);\n    let constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType} ${constraint.constraintCondition}`;\n    if (constraint.constraintType === \"FOREIGN KEY\") {\n      const referenceTableName = this.queryGenerator.quoteTable(constraint.referenceTableName);\n      constraint.referenceTableKeys = constraint.referenceTableKeys.map(columnName => this.queryGenerator.quoteIdentifier(columnName));\n      const referenceTableKeys = constraint.referenceTableKeys.join(\", \");\n      constraintSnippet += ` REFERENCES ${referenceTableName} (${referenceTableKeys})`;\n      constraintSnippet += ` ON UPDATE ${constraint.updateAction}`;\n      constraintSnippet += ` ON DELETE ${constraint.deleteAction}`;\n    }\n    createTableSql = createTableSql.replace(constraintSnippet, \"\");\n    createTableSql += \";\";\n    const fields = await this.describeTable(tableName, options);\n    const sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n    const subQueries = sql.split(\";\").filter(q => q !== \"\");\n    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, __spreadValues({\n      raw: true\n    }, options));\n  }\n  async addConstraint(tableName, options) {\n    if (!options.fields) {\n      throw new Error(\"Fields must be specified through options.fields\");\n    }\n    if (!options.type) {\n      throw new Error(\"Constraint type must be specified through options.type\");\n    }\n    options = cloneDeep(options);\n    const constraintSnippet = this.queryGenerator.getConstraintSnippet(tableName, options);\n    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);\n    const constraints = await this.sequelize.query(describeCreateTableSql, __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.SELECT,\n      raw: true\n    }));\n    let sql = constraints[0].sql;\n    const index = sql.length - 1;\n    const createTableSql = `${sql.substr(0, index)}, ${constraintSnippet})${sql.substr(index + 1)};`;\n    const fields = await this.describeTable(tableName, options);\n    sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n    const subQueries = sql.split(\";\").filter(q => q !== \"\");\n    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, __spreadValues({\n      raw: true\n    }, options));\n  }\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const database = this.sequelize.config.database;\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, database);\n    const result = await this.sequelize.query(query, options);\n    return result.map(row => ({\n      tableName,\n      columnName: row.from,\n      referencedTableName: row.table,\n      referencedColumnName: row.to,\n      tableCatalog: database,\n      referencedTableCatalog: database\n    }));\n  }\n  async dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n    const tableNames = await this.showAllTables(options);\n    await this.sequelize.query(\"PRAGMA foreign_keys = OFF\", options);\n    await this._dropAllTables(tableNames, skip, options);\n    await this.sequelize.query(\"PRAGMA foreign_keys = ON\", options);\n  }\n  async describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n    if (typeof options === \"string\") {\n      schema = options;\n    } else if (typeof options === \"object\" && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n    if (typeof tableName === \"object\" && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.DESCRIBE\n    });\n    const sqlIndexes = this.queryGenerator.showIndexesQuery(tableName);\n    try {\n      const data = await this.sequelize.query(sql, options);\n      if (_.isEmpty(data)) {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n      const indexes = await this.sequelize.query(sqlIndexes, options);\n      for (const prop in data) {\n        data[prop].unique = false;\n      }\n      for (const index of indexes) {\n        for (const field of index.fields) {\n          if (index.unique !== void 0) {\n            data[field.attribute].unique = index.unique;\n          }\n        }\n      }\n      const foreignKeys = await this.getForeignKeyReferencesForTable(tableName, options);\n      for (const foreignKey of foreignKeys) {\n        data[foreignKey.columnName].references = {\n          model: foreignKey.referencedTableName,\n          key: foreignKey.referencedColumnName\n        };\n      }\n      return data;\n    } catch (e) {\n      if (e.original && e.original.code === \"ER_NO_SUCH_TABLE\") {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n      throw e;\n    }\n  }\n}\nexports.SQLiteQueryInterface = SQLiteQueryInterface;","map":{"version":3,"names":["sequelizeErrors","require","QueryTypes","QueryInterface","cloneDeep","_","SQLiteQueryInterface","removeColumn","tableName","attributeName","options","fields","describeTable","sql","queryGenerator","removeColumnQuery","subQueries","split","filter","q","subQuery","sequelize","query","__spreadValues","raw","changeColumn","dataTypeOrOptions","Object","assign","normalizeAttribute","renameColumn","attrNameBefore","attrNameAfter","assertTableHasColumn","renameColumnQuery","removeConstraint","constraintName","createTableSql","constraints","showConstraint","constraint","find","constaint","UnknownConstraintError","message","table","quoteIdentifier","constraintSnippet","constraintType","constraintCondition","referenceTableName","quoteTable","referenceTableKeys","map","columnName","join","updateAction","deleteAction","replace","_alterConstraintQuery","addConstraint","Error","type","getConstraintSnippet","describeCreateTableSql","describeCreateTableQuery","__spreadProps","SELECT","index","length","substr","getForeignKeyReferencesForTable","database","config","getForeignKeysQuery","result","row","from","referencedTableName","referencedColumnName","to","tableCatalog","referencedTableCatalog","dropAllTables","skip","tableNames","showAllTables","_dropAllTables","schema","schemaDelimiter","describeTableQuery","DESCRIBE","sqlIndexes","showIndexesQuery","data","isEmpty","indexes","prop","unique","field","attribute","foreignKeys","foreignKey","references","model","key","e","original","code","exports"],"sources":["C:\\Users\\teply\\OneDrive\\Рабочий стол\\web_project\\client\\node_modules\\sequelize\\src\\dialects\\sqlite\\query-interface.js"],"sourcesContent":["'use strict';\n\nconst sequelizeErrors = require('../../errors');\nconst QueryTypes = require('../../query-types');\nconst { QueryInterface } = require('../abstract/query-interface');\nconst { cloneDeep } = require('../../utils');\nconst _ = require('lodash');\n\n/**\n * The interface that Sequelize uses to talk with SQLite database\n */\nclass SQLiteQueryInterface extends QueryInterface {\n  /**\n   * A wrapper that fixes SQLite's inability to remove columns from existing tables.\n   * It will create a backup of the table, drop the table afterwards and create a\n   * new table with the same name but without the obsolete column.\n   *\n   * @override\n   */\n  async removeColumn(tableName, attributeName, options) {\n    options = options || {};\n\n    const fields = await this.describeTable(tableName, options);\n    delete fields[attributeName];\n\n    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });\n  }\n\n  /**\n   * A wrapper that fixes SQLite's inability to change columns from existing tables.\n   * It will create a backup of the table, drop the table afterwards and create a\n   * new table with the same name but with a modified version of the respective column.\n   *\n   * @override\n   */\n  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    options = options || {};\n\n    const fields = await this.describeTable(tableName, options);\n    Object.assign(fields[attributeName], this.normalizeAttribute(dataTypeOrOptions));\n\n    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });\n  }\n\n  /**\n   * A wrapper that fixes SQLite's inability to rename columns from existing tables.\n   * It will create a backup of the table, drop the table afterwards and create a\n   * new table with the same name but with a renamed version of the respective column.\n   *\n   * @override\n   */\n  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    const fields = await this.assertTableHasColumn(tableName, attrNameBefore, options);\n\n    fields[attrNameAfter] = { ...fields[attrNameBefore] };\n    delete fields[attrNameBefore];\n\n    const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, attrNameAfter, fields);\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });\n  }\n\n  /**\n   * @override\n   */\n  async removeConstraint(tableName, constraintName, options) {\n    let createTableSql;\n\n    const constraints = await this.showConstraint(tableName, constraintName);\n    // sqlite can't show only one constraint, so we find here the one to remove\n    const constraint = constraints.find(constaint => constaint.constraintName === constraintName);\n\n    if (!constraint) {\n      throw new sequelizeErrors.UnknownConstraintError({\n        message: `Constraint ${constraintName} on table ${tableName} does not exist`,\n        constraint: constraintName,\n        table: tableName\n      });\n    }\n    createTableSql = constraint.sql;\n    constraint.constraintName = this.queryGenerator.quoteIdentifier(constraint.constraintName);\n    let constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType} ${constraint.constraintCondition}`;\n\n    if (constraint.constraintType === 'FOREIGN KEY') {\n      const referenceTableName = this.queryGenerator.quoteTable(constraint.referenceTableName);\n      constraint.referenceTableKeys = constraint.referenceTableKeys.map(columnName => this.queryGenerator.quoteIdentifier(columnName));\n      const referenceTableKeys = constraint.referenceTableKeys.join(', ');\n      constraintSnippet += ` REFERENCES ${referenceTableName} (${referenceTableKeys})`;\n      constraintSnippet += ` ON UPDATE ${constraint.updateAction}`;\n      constraintSnippet += ` ON DELETE ${constraint.deleteAction}`;\n    }\n\n    createTableSql = createTableSql.replace(constraintSnippet, '');\n    createTableSql += ';';\n\n    const fields = await this.describeTable(tableName, options);\n\n    const sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });\n  }\n\n  /**\n   * @override\n   */\n  async addConstraint(tableName, options) {\n    if (!options.fields) {\n      throw new Error('Fields must be specified through options.fields');\n    }\n\n    if (!options.type) {\n      throw new Error('Constraint type must be specified through options.type');\n    }\n\n    options = cloneDeep(options);\n\n    const constraintSnippet = this.queryGenerator.getConstraintSnippet(tableName, options);\n    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);\n\n    const constraints = await this.sequelize.query(describeCreateTableSql, { ...options, type: QueryTypes.SELECT, raw: true });\n    let sql = constraints[0].sql;\n    const index = sql.length - 1;\n    //Replace ending ')' with constraint snippet - Simulates String.replaceAt\n    //http://stackoverflow.com/questions/1431094\n    const createTableSql = `${sql.substr(0, index)}, ${constraintSnippet})${sql.substr(index + 1)};`;\n\n    const fields = await this.describeTable(tableName, options);\n    sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n    const subQueries = sql.split(';').filter(q => q !== '');\n\n    for (const subQuery of subQueries) await this.sequelize.query(`${subQuery};`, { raw: true, ...options });\n  }\n\n  /**\n   * @override\n   */\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const database = this.sequelize.config.database;\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, database);\n    const result = await this.sequelize.query(query, options);\n    return result.map(row => ({\n      tableName,\n      columnName: row.from,\n      referencedTableName: row.table,\n      referencedColumnName: row.to,\n      tableCatalog: database,\n      referencedTableCatalog: database\n    }));\n  }\n\n  /**\n   * @override\n   */\n  async dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n\n    const tableNames = await this.showAllTables(options);\n    await this.sequelize.query('PRAGMA foreign_keys = OFF', options);\n    await this._dropAllTables(tableNames, skip, options);\n    await this.sequelize.query('PRAGMA foreign_keys = ON', options);\n  }\n\n  /**\n   * @override\n   */\n  async describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n\n    if (typeof options === 'string') {\n      schema = options;\n    } else if (typeof options === 'object' && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n\n    if (typeof tableName === 'object' && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n\n    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = { ...options, type: QueryTypes.DESCRIBE };\n    const sqlIndexes = this.queryGenerator.showIndexesQuery(tableName);\n\n    try {\n      const data = await this.sequelize.query(sql, options);\n      /*\n       * If no data is returned from the query, then the table name may be wrong.\n       * Query generators that use information_schema for retrieving table info will just return an empty result set,\n       * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).\n       */\n      if (_.isEmpty(data)) {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n\n      const indexes = await this.sequelize.query(sqlIndexes, options);\n      for (const prop in data) {\n        data[prop].unique = false;\n      }\n      for (const index of indexes) {\n        for (const field of index.fields) {\n          if (index.unique !== undefined) {\n            data[field.attribute].unique = index.unique;\n          }\n        }\n      }\n\n      const foreignKeys = await this.getForeignKeyReferencesForTable(tableName, options);\n      for (const foreignKey of foreignKeys) {\n        data[foreignKey.columnName].references = {\n          model: foreignKey.referencedTableName,\n          key: foreignKey.referencedColumnName\n        };\n      }\n\n      return data;\n    } catch (e) {\n      if (e.original && e.original.code === 'ER_NO_SUCH_TABLE') {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n\n      throw e;\n    }\n  }\n}\n\nexports.SQLiteQueryInterface = SQLiteQueryInterface;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAEA,MAAMA,eAAA,GAAkBC,OAAA,CAAQ;AAChC,MAAMC,UAAA,GAAaD,OAAA,CAAQ;AAC3B,MAAM;EAAEE;AAAA,IAAmBF,OAAA,CAAQ;AACnC,MAAM;EAAEG;AAAA,IAAcH,OAAA,CAAQ;AAC9B,MAAMI,CAAA,GAAIJ,OAAA,CAAQ;AAKlB,MAAAK,oBAAA,SAAmCH,cAAA,CAAe;EAAA,MAQ1CI,aAAaC,SAAA,EAAWC,aAAA,EAAeC,OAAA,EAAS;IACpDA,OAAA,GAAUA,OAAA,IAAW;IAErB,MAAMC,MAAA,GAAS,MAAM,KAAKC,aAAA,CAAcJ,SAAA,EAAWE,OAAA;IACnD,OAAOC,MAAA,CAAOF,aAAA;IAEd,MAAMI,GAAA,GAAM,KAAKC,cAAA,CAAeC,iBAAA,CAAkBP,SAAA,EAAWG,MAAA;IAC7D,MAAMK,UAAA,GAAaH,GAAA,CAAII,KAAA,CAAM,KAAKC,MAAA,CAAOC,CAAA,IAAKA,CAAA,KAAM;IAEpD,WAAWC,QAAA,IAAYJ,UAAA,EAAY,MAAM,KAAKK,SAAA,CAAUC,KAAA,CAAM,GAAGF,QAAA,KAAaG,cAAA;MAAEC,GAAA,EAAK;IAAA,GAASd,OAAA;EAAA;EAAA,MAU1Fe,aAAajB,SAAA,EAAWC,aAAA,EAAeiB,iBAAA,EAAmBhB,OAAA,EAAS;IACvEA,OAAA,GAAUA,OAAA,IAAW;IAErB,MAAMC,MAAA,GAAS,MAAM,KAAKC,aAAA,CAAcJ,SAAA,EAAWE,OAAA;IACnDiB,MAAA,CAAOC,MAAA,CAAOjB,MAAA,CAAOF,aAAA,GAAgB,KAAKoB,kBAAA,CAAmBH,iBAAA;IAE7D,MAAMb,GAAA,GAAM,KAAKC,cAAA,CAAeC,iBAAA,CAAkBP,SAAA,EAAWG,MAAA;IAC7D,MAAMK,UAAA,GAAaH,GAAA,CAAII,KAAA,CAAM,KAAKC,MAAA,CAAOC,CAAA,IAAKA,CAAA,KAAM;IAEpD,WAAWC,QAAA,IAAYJ,UAAA,EAAY,MAAM,KAAKK,SAAA,CAAUC,KAAA,CAAM,GAAGF,QAAA,KAAaG,cAAA;MAAEC,GAAA,EAAK;IAAA,GAASd,OAAA;EAAA;EAAA,MAU1FoB,aAAatB,SAAA,EAAWuB,cAAA,EAAgBC,aAAA,EAAetB,OAAA,EAAS;IACpEA,OAAA,GAAUA,OAAA,IAAW;IACrB,MAAMC,MAAA,GAAS,MAAM,KAAKsB,oBAAA,CAAqBzB,SAAA,EAAWuB,cAAA,EAAgBrB,OAAA;IAE1EC,MAAA,CAAOqB,aAAA,IAAiBT,cAAA,KAAKZ,MAAA,CAAOoB,cAAA;IACpC,OAAOpB,MAAA,CAAOoB,cAAA;IAEd,MAAMlB,GAAA,GAAM,KAAKC,cAAA,CAAeoB,iBAAA,CAAkB1B,SAAA,EAAWuB,cAAA,EAAgBC,aAAA,EAAerB,MAAA;IAC5F,MAAMK,UAAA,GAAaH,GAAA,CAAII,KAAA,CAAM,KAAKC,MAAA,CAAOC,CAAA,IAAKA,CAAA,KAAM;IAEpD,WAAWC,QAAA,IAAYJ,UAAA,EAAY,MAAM,KAAKK,SAAA,CAAUC,KAAA,CAAM,GAAGF,QAAA,KAAaG,cAAA;MAAEC,GAAA,EAAK;IAAA,GAASd,OAAA;EAAA;EAAA,MAM1FyB,iBAAiB3B,SAAA,EAAW4B,cAAA,EAAgB1B,OAAA,EAAS;IACzD,IAAI2B,cAAA;IAEJ,MAAMC,WAAA,GAAc,MAAM,KAAKC,cAAA,CAAe/B,SAAA,EAAW4B,cAAA;IAEzD,MAAMI,UAAA,GAAaF,WAAA,CAAYG,IAAA,CAAKC,SAAA,IAAaA,SAAA,CAAUN,cAAA,KAAmBA,cAAA;IAE9E,IAAI,CAACI,UAAA,EAAY;MACf,MAAM,IAAIxC,eAAA,CAAgB2C,sBAAA,CAAuB;QAC/CC,OAAA,EAAS,cAAcR,cAAA,aAA2B5B,SAAA;QAClDgC,UAAA,EAAYJ,cAAA;QACZS,KAAA,EAAOrC;MAAA;IAAA;IAGX6B,cAAA,GAAiBG,UAAA,CAAW3B,GAAA;IAC5B2B,UAAA,CAAWJ,cAAA,GAAiB,KAAKtB,cAAA,CAAegC,eAAA,CAAgBN,UAAA,CAAWJ,cAAA;IAC3E,IAAIW,iBAAA,GAAoB,gBAAgBP,UAAA,CAAWJ,cAAA,IAAkBI,UAAA,CAAWQ,cAAA,IAAkBR,UAAA,CAAWS,mBAAA;IAE7G,IAAIT,UAAA,CAAWQ,cAAA,KAAmB,eAAe;MAC/C,MAAME,kBAAA,GAAqB,KAAKpC,cAAA,CAAeqC,UAAA,CAAWX,UAAA,CAAWU,kBAAA;MACrEV,UAAA,CAAWY,kBAAA,GAAqBZ,UAAA,CAAWY,kBAAA,CAAmBC,GAAA,CAAIC,UAAA,IAAc,KAAKxC,cAAA,CAAegC,eAAA,CAAgBQ,UAAA;MACpH,MAAMF,kBAAA,GAAqBZ,UAAA,CAAWY,kBAAA,CAAmBG,IAAA,CAAK;MAC9DR,iBAAA,IAAqB,eAAeG,kBAAA,KAAuBE,kBAAA;MAC3DL,iBAAA,IAAqB,cAAcP,UAAA,CAAWgB,YAAA;MAC9CT,iBAAA,IAAqB,cAAcP,UAAA,CAAWiB,YAAA;IAAA;IAGhDpB,cAAA,GAAiBA,cAAA,CAAeqB,OAAA,CAAQX,iBAAA,EAAmB;IAC3DV,cAAA,IAAkB;IAElB,MAAM1B,MAAA,GAAS,MAAM,KAAKC,aAAA,CAAcJ,SAAA,EAAWE,OAAA;IAEnD,MAAMG,GAAA,GAAM,KAAKC,cAAA,CAAe6C,qBAAA,CAAsBnD,SAAA,EAAWG,MAAA,EAAQ0B,cAAA;IACzE,MAAMrB,UAAA,GAAaH,GAAA,CAAII,KAAA,CAAM,KAAKC,MAAA,CAAOC,CAAA,IAAKA,CAAA,KAAM;IAEpD,WAAWC,QAAA,IAAYJ,UAAA,EAAY,MAAM,KAAKK,SAAA,CAAUC,KAAA,CAAM,GAAGF,QAAA,KAAaG,cAAA;MAAEC,GAAA,EAAK;IAAA,GAASd,OAAA;EAAA;EAAA,MAM1FkD,cAAcpD,SAAA,EAAWE,OAAA,EAAS;IACtC,IAAI,CAACA,OAAA,CAAQC,MAAA,EAAQ;MACnB,MAAM,IAAIkD,KAAA,CAAM;IAAA;IAGlB,IAAI,CAACnD,OAAA,CAAQoD,IAAA,EAAM;MACjB,MAAM,IAAID,KAAA,CAAM;IAAA;IAGlBnD,OAAA,GAAUN,SAAA,CAAUM,OAAA;IAEpB,MAAMqC,iBAAA,GAAoB,KAAKjC,cAAA,CAAeiD,oBAAA,CAAqBvD,SAAA,EAAWE,OAAA;IAC9E,MAAMsD,sBAAA,GAAyB,KAAKlD,cAAA,CAAemD,wBAAA,CAAyBzD,SAAA;IAE5E,MAAM8B,WAAA,GAAc,MAAM,KAAKjB,SAAA,CAAUC,KAAA,CAAM0C,sBAAA,EAAwBE,aAAA,CAAA3C,cAAA,KAAKb,OAAA,GAAL;MAAcoD,IAAA,EAAM5D,UAAA,CAAWiE,MAAA;MAAQ3C,GAAA,EAAK;IAAA;IACnH,IAAIX,GAAA,GAAMyB,WAAA,CAAY,GAAGzB,GAAA;IACzB,MAAMuD,KAAA,GAAQvD,GAAA,CAAIwD,MAAA,GAAS;IAG3B,MAAMhC,cAAA,GAAiB,GAAGxB,GAAA,CAAIyD,MAAA,CAAO,GAAGF,KAAA,MAAWrB,iBAAA,IAAqBlC,GAAA,CAAIyD,MAAA,CAAOF,KAAA,GAAQ;IAE3F,MAAMzD,MAAA,GAAS,MAAM,KAAKC,aAAA,CAAcJ,SAAA,EAAWE,OAAA;IACnDG,GAAA,GAAM,KAAKC,cAAA,CAAe6C,qBAAA,CAAsBnD,SAAA,EAAWG,MAAA,EAAQ0B,cAAA;IACnE,MAAMrB,UAAA,GAAaH,GAAA,CAAII,KAAA,CAAM,KAAKC,MAAA,CAAOC,CAAA,IAAKA,CAAA,KAAM;IAEpD,WAAWC,QAAA,IAAYJ,UAAA,EAAY,MAAM,KAAKK,SAAA,CAAUC,KAAA,CAAM,GAAGF,QAAA,KAAaG,cAAA;MAAEC,GAAA,EAAK;IAAA,GAASd,OAAA;EAAA;EAAA,MAM1F6D,gCAAgC/D,SAAA,EAAWE,OAAA,EAAS;IACxD,MAAM8D,QAAA,GAAW,KAAKnD,SAAA,CAAUoD,MAAA,CAAOD,QAAA;IACvC,MAAMlD,KAAA,GAAQ,KAAKR,cAAA,CAAe4D,mBAAA,CAAoBlE,SAAA,EAAWgE,QAAA;IACjE,MAAMG,MAAA,GAAS,MAAM,KAAKtD,SAAA,CAAUC,KAAA,CAAMA,KAAA,EAAOZ,OAAA;IACjD,OAAOiE,MAAA,CAAOtB,GAAA,CAAIuB,GAAA,KAAQ;MACxBpE,SAAA;MACA8C,UAAA,EAAYsB,GAAA,CAAIC,IAAA;MAChBC,mBAAA,EAAqBF,GAAA,CAAI/B,KAAA;MACzBkC,oBAAA,EAAsBH,GAAA,CAAII,EAAA;MAC1BC,YAAA,EAAcT,QAAA;MACdU,sBAAA,EAAwBV;IAAA;EAAA;EAAA,MAOtBW,cAAczE,OAAA,EAAS;IAC3BA,OAAA,GAAUA,OAAA,IAAW;IACrB,MAAM0E,IAAA,GAAO1E,OAAA,CAAQ0E,IAAA,IAAQ;IAE7B,MAAMC,UAAA,GAAa,MAAM,KAAKC,aAAA,CAAc5E,OAAA;IAC5C,MAAM,KAAKW,SAAA,CAAUC,KAAA,CAAM,6BAA6BZ,OAAA;IACxD,MAAM,KAAK6E,cAAA,CAAeF,UAAA,EAAYD,IAAA,EAAM1E,OAAA;IAC5C,MAAM,KAAKW,SAAA,CAAUC,KAAA,CAAM,4BAA4BZ,OAAA;EAAA;EAAA,MAMnDE,cAAcJ,SAAA,EAAWE,OAAA,EAAS;IACtC,IAAI8E,MAAA,GAAS;IACb,IAAIC,eAAA,GAAkB;IAEtB,IAAI,OAAO/E,OAAA,KAAY,UAAU;MAC/B8E,MAAA,GAAS9E,OAAA;IAAA,WACA,OAAOA,OAAA,KAAY,YAAYA,OAAA,KAAY,MAAM;MAC1D8E,MAAA,GAAS9E,OAAA,CAAQ8E,MAAA,IAAU;MAC3BC,eAAA,GAAkB/E,OAAA,CAAQ+E,eAAA,IAAmB;IAAA;IAG/C,IAAI,OAAOjF,SAAA,KAAc,YAAYA,SAAA,KAAc,MAAM;MACvDgF,MAAA,GAAShF,SAAA,CAAUgF,MAAA;MACnBhF,SAAA,GAAYA,SAAA,CAAUA,SAAA;IAAA;IAGxB,MAAMK,GAAA,GAAM,KAAKC,cAAA,CAAe4E,kBAAA,CAAmBlF,SAAA,EAAWgF,MAAA,EAAQC,eAAA;IACtE/E,OAAA,GAAUwD,aAAA,CAAA3C,cAAA,KAAKb,OAAA,GAAL;MAAcoD,IAAA,EAAM5D,UAAA,CAAWyF;IAAA;IACzC,MAAMC,UAAA,GAAa,KAAK9E,cAAA,CAAe+E,gBAAA,CAAiBrF,SAAA;IAExD,IAAI;MACF,MAAMsF,IAAA,GAAO,MAAM,KAAKzE,SAAA,CAAUC,KAAA,CAAMT,GAAA,EAAKH,OAAA;MAM7C,IAAIL,CAAA,CAAE0F,OAAA,CAAQD,IAAA,GAAO;QACnB,MAAM,IAAIjC,KAAA,CAAM,6BAA6BrD,SAAA;MAAA;MAG/C,MAAMwF,OAAA,GAAU,MAAM,KAAK3E,SAAA,CAAUC,KAAA,CAAMsE,UAAA,EAAYlF,OAAA;MACvD,WAAWuF,IAAA,IAAQH,IAAA,EAAM;QACvBA,IAAA,CAAKG,IAAA,EAAMC,MAAA,GAAS;MAAA;MAEtB,WAAW9B,KAAA,IAAS4B,OAAA,EAAS;QAC3B,WAAWG,KAAA,IAAS/B,KAAA,CAAMzD,MAAA,EAAQ;UAChC,IAAIyD,KAAA,CAAM8B,MAAA,KAAW,QAAW;YAC9BJ,IAAA,CAAKK,KAAA,CAAMC,SAAA,EAAWF,MAAA,GAAS9B,KAAA,CAAM8B,MAAA;UAAA;QAAA;MAAA;MAK3C,MAAMG,WAAA,GAAc,MAAM,KAAK9B,+BAAA,CAAgC/D,SAAA,EAAWE,OAAA;MAC1E,WAAW4F,UAAA,IAAcD,WAAA,EAAa;QACpCP,IAAA,CAAKQ,UAAA,CAAWhD,UAAA,EAAYiD,UAAA,GAAa;UACvCC,KAAA,EAAOF,UAAA,CAAWxB,mBAAA;UAClB2B,GAAA,EAAKH,UAAA,CAAWvB;QAAA;MAAA;MAIpB,OAAOe,IAAA;IAAA,SACAY,CAAA,EAAP;MACA,IAAIA,CAAA,CAAEC,QAAA,IAAYD,CAAA,CAAEC,QAAA,CAASC,IAAA,KAAS,oBAAoB;QACxD,MAAM,IAAI/C,KAAA,CAAM,6BAA6BrD,SAAA;MAAA;MAG/C,MAAMkG,CAAA;IAAA;EAAA;AAAA;AAKZG,OAAA,CAAQvG,oBAAA,GAAuBA,oBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}