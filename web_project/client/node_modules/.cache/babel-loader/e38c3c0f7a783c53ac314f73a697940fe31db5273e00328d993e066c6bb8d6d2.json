{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nconst AbstractConnectionManager = require(\"../abstract/connection-manager\");\nconst SequelizeErrors = require(\"../../errors\");\nconst {\n  logger\n} = require(\"../../utils/logger\");\nconst DataTypes = require(\"../../data-types\").mysql;\nconst momentTz = require(\"moment-timezone\");\nconst debug = logger.debugContext(\"connection:mysql\");\nconst parserStore = require(\"../parserStore\")(\"mysql\");\nconst {\n  promisify\n} = require(\"util\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"mysql2\");\n    this.refreshTypeParser(DataTypes);\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n  async connect(config) {\n    const connectionConfig = __spreadValues({\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      flags: \"-FOUND_ROWS\",\n      password: config.password,\n      database: config.database,\n      timezone: this.sequelize.options.timezone,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true\n    }, config.dialectOptions);\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        const connection2 = this.lib.createConnection(connectionConfig);\n        const errorHandler = e => {\n          connection2.removeListener(\"connect\", connectHandler);\n          connection2.removeListener(\"error\", connectHandler);\n          reject(e);\n        };\n        const connectHandler = () => {\n          connection2.removeListener(\"error\", errorHandler);\n          resolve(connection2);\n        };\n        connection2.on(\"error\", errorHandler);\n        connection2.once(\"connect\", connectHandler);\n      });\n      debug(\"connection acquired\");\n      connection.on(\"error\", error => {\n        switch (error.code) {\n          case \"ESOCKET\":\n          case \"ECONNRESET\":\n          case \"EPIPE\":\n          case \"PROTOCOL_CONNECTION_LOST\":\n            this.pool.destroy(connection);\n        }\n      });\n      if (!this.sequelize.config.keepDefaultTimezone) {\n        let tzOffset = this.sequelize.options.timezone;\n        tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format(\"Z\") : tzOffset;\n        await promisify(cb => connection.query(`SET time_zone = '${tzOffset}'`, cb))();\n      }\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case \"ECONNREFUSED\":\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case \"ER_ACCESS_DENIED_ERROR\":\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case \"ENOTFOUND\":\n          throw new SequelizeErrors.HostNotFoundError(err);\n        case \"EHOSTUNREACH\":\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case \"EINVAL\":\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n  async disconnect(connection) {\n    if (connection._closing) {\n      debug(\"connection tried to disconnect but was already at CLOSED state\");\n      return;\n    }\n    return await promisify(callback => connection.end(callback))();\n  }\n  validate(connection) {\n    return connection && !connection._fatalError && !connection._protocolError && !connection._closing && !connection.stream.destroyed;\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"names":["AbstractConnectionManager","require","SequelizeErrors","logger","DataTypes","mysql","momentTz","debug","debugContext","parserStore","promisify","ConnectionManager","constructor","dialect","sequelize","config","port","lib","_loadDialectModule","refreshTypeParser","_refreshTypeParser","dataType","refresh","_clearTypeParser","clear","_typecast","field","next","get","type","options","connect","connectionConfig","__spreadValues","host","user","username","flags","password","database","timezone","typeCast","bind","bigNumberStrings","supportBigNumbers","dialectOptions","connection","Promise","resolve","reject","connection2","createConnection","errorHandler","e","removeListener","connectHandler","on","once","error","code","pool","destroy","keepDefaultTimezone","tzOffset","test","tz","format","cb","query","err","ConnectionRefusedError","AccessDeniedError","HostNotFoundError","HostNotReachableError","InvalidConnectionError","ConnectionError","disconnect","_closing","callback","end","validate","_fatalError","_protocolError","stream","destroyed","module","exports","default"],"sources":["C:\\Users\\teply\\OneDrive\\Рабочий стол\\web_project\\client\\node_modules\\sequelize\\src\\dialects\\mysql\\connection-manager.js"],"sourcesContent":["'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst SequelizeErrors = require('../../errors');\nconst { logger } = require('../../utils/logger');\nconst DataTypes = require('../../data-types').mysql;\nconst momentTz = require('moment-timezone');\nconst debug = logger.debugContext('connection:mysql');\nconst parserStore = require('../parserStore')('mysql');\nconst { promisify } = require('util');\n\n/**\n * MySQL Connection Manager\n *\n * Get connections, validate and disconnect them.\n * AbstractConnectionManager pooling use it to handle MySQL specific connections\n * Use https://github.com/sidorares/node-mysql2 to connect with MySQL server\n *\n * @private\n */\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('mysql2');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n\n  /**\n   * Connect with MySQL database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once connection is connected.\n   *\n   * @param {object} config\n   * @returns {Promise<Connection>}\n   * @private\n   */\n  async connect(config) {\n    const connectionConfig = {\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      flags: '-FOUND_ROWS',\n      password: config.password,\n      database: config.database,\n      timezone: this.sequelize.options.timezone,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true,\n      ...config.dialectOptions\n    };\n\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        const connection = this.lib.createConnection(connectionConfig);\n\n        const errorHandler = e => {\n          // clean up connect & error event if there is error\n          connection.removeListener('connect', connectHandler);\n          connection.removeListener('error', connectHandler);\n          reject(e);\n        };\n\n        const connectHandler = () => {\n          // clean up error event if connected\n          connection.removeListener('error', errorHandler);\n          resolve(connection);\n        };\n\n        // don't use connection.once for error event handling here\n        // mysql2 emit error two times in case handshake was failed\n        // first error is protocol_lost and second is timeout\n        // if we will use `once.error` node process will crash on 2nd error emit\n        connection.on('error', errorHandler);\n        connection.once('connect', connectHandler);\n      });\n\n      debug('connection acquired');\n      connection.on('error', error => {\n        switch (error.code) {\n          case 'ESOCKET':\n          case 'ECONNRESET':\n          case 'EPIPE':\n          case 'PROTOCOL_CONNECTION_LOST':\n            this.pool.destroy(connection);\n        }\n      });\n\n      if (!this.sequelize.config.keepDefaultTimezone) {\n        // set timezone for this connection\n        // but named timezone are not directly supported in mysql, so get its offset first\n        let tzOffset = this.sequelize.options.timezone;\n        tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z') : tzOffset;\n        await promisify(cb => connection.query(`SET time_zone = '${tzOffset}'`, cb))();\n      }\n\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case 'ECONNREFUSED':\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case 'ER_ACCESS_DENIED_ERROR':\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case 'ENOTFOUND':\n          throw new SequelizeErrors.HostNotFoundError(err);\n        case 'EHOSTUNREACH':\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case 'EINVAL':\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    // Don't disconnect connections with CLOSED state\n    if (connection._closing) {\n      debug('connection tried to disconnect but was already at CLOSED state');\n      return;\n    }\n\n    return await promisify(callback => connection.end(callback))();\n  }\n\n  validate(connection) {\n    return connection\n      && !connection._fatalError\n      && !connection._protocolError\n      && !connection._closing\n      && !connection.stream.destroyed;\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}