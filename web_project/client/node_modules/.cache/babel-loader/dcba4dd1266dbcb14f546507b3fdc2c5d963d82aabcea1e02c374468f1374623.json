{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nconst _ = require(\"lodash\");\nconst Utils = require(\"../../utils\");\nconst DataTypes = require(\"../../data-types\");\nconst TableHints = require(\"../../table-hints\");\nconst AbstractQueryGenerator = require(\"../abstract/query-generator\");\nconst randomBytes = require(\"crypto\").randomBytes;\nconst semver = require(\"semver\");\nconst Op = require(\"../../operators\");\nconst throwMethodUndefined = function (methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n};\nclass MSSQLQueryGenerator extends AbstractQueryGenerator {\n  createDatabaseQuery(databaseName, options) {\n    options = __spreadValues({\n      collate: null\n    }, options);\n    const collation = options.collate ? `COLLATE ${this.escape(options.collate)}` : \"\";\n    return [\"IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =\", wrapSingleQuote(databaseName), \")\", \"BEGIN\", \"CREATE DATABASE\", this.quoteIdentifier(databaseName), `${collation};`, \"END;\"].join(\" \");\n  }\n  dropDatabaseQuery(databaseName) {\n    return [\"IF EXISTS (SELECT * FROM sys.databases WHERE name =\", wrapSingleQuote(databaseName), \")\", \"BEGIN\", \"DROP DATABASE\", this.quoteIdentifier(databaseName), \";\", \"END;\"].join(\" \");\n  }\n  createSchema(schema) {\n    return [\"IF NOT EXISTS (SELECT schema_name\", \"FROM information_schema.schemata\", \"WHERE schema_name =\", wrapSingleQuote(schema), \")\", \"BEGIN\", \"EXEC sp_executesql N'CREATE SCHEMA\", this.quoteIdentifier(schema), \";'\", \"END;\"].join(\" \");\n  }\n  dropSchema(schema) {\n    const quotedSchema = wrapSingleQuote(schema);\n    return [\"IF EXISTS (SELECT schema_name\", \"FROM information_schema.schemata\", \"WHERE schema_name =\", quotedSchema, \")\", \"BEGIN\", \"DECLARE @id INT, @ms_sql NVARCHAR(2000);\", \"DECLARE @cascade TABLE (\", \"id INT NOT NULL IDENTITY PRIMARY KEY,\", \"ms_sql NVARCHAR(2000) NOT NULL );\", \"INSERT INTO @cascade ( ms_sql )\", \"SELECT CASE WHEN o.type IN ('F','PK')\", \"THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'\", \"ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END\", \"FROM sys.objects o\", \"JOIN sys.schemas s on o.schema_id = s.schema_id\", \"LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id\", \"WHERE o.type IN ('F', 'PK', 'U') AND s.name = \", quotedSchema, \"ORDER BY o.type ASC;\", \"SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;\", \"WHILE @id IS NOT NULL\", \"BEGIN\", \"BEGIN TRY EXEC sp_executesql @ms_sql; END TRY\", \"BEGIN CATCH BREAK; THROW; END CATCH;\", \"DELETE FROM @cascade WHERE id = @id;\", \"SELECT @id = NULL, @ms_sql = NULL;\", \"SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;\", \"END\", \"EXEC sp_executesql N'DROP SCHEMA\", this.quoteIdentifier(schema), \";'\", \"END;\"].join(\" \");\n  }\n  showSchemasQuery() {\n    return ['SELECT \"name\" as \"schema_name\" FROM sys.schemas as s', 'WHERE \"s\".\"name\" NOT IN (', \"'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'\", \")\", \"AND\", '\"s\".\"name\" NOT LIKE', \"'db_%'\"].join(\" \");\n  }\n  versionQuery() {\n    return [\"DECLARE @ms_ver NVARCHAR(20);\", \"SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));\", \"SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'\"].join(\" \");\n  }\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [],\n      foreignKeys = {},\n      attributesClauseParts = [];\n    let commentStr = \"\";\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n        if (dataType.includes(\"COMMENT \")) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          const commentText = commentMatch[2].replace(\"COMMENT\", \"\").trim();\n          commentStr += this.commentTemplate(commentText, tableName, attr);\n          dataType = commentMatch[1];\n        }\n        if (dataType.includes(\"PRIMARY KEY\")) {\n          primaryKeys.push(attr);\n          if (dataType.includes(\"REFERENCES\")) {\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1].replace(\"PRIMARY KEY\", \"\")}`);\n            foreignKeys[attr] = match[2];\n          } else {\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType.replace(\"PRIMARY KEY\", \"\")}`);\n          }\n        } else if (dataType.includes(\"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n        }\n      }\n    }\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(\", \");\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== \"string\") {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n          attributesClauseParts.push(`CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(\", \")})`);\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      attributesClauseParts.push(`PRIMARY KEY (${pkString})`);\n    }\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClauseParts.push(`FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`);\n      }\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([`IF OBJECT_ID('${quotedTableName}', 'U') IS NULL`, `CREATE TABLE ${quotedTableName} (${attributesClauseParts.join(\", \")})`, \";\", commentStr]);\n  }\n  describeTableQuery(tableName, schema) {\n    let sql = [\"SELECT\", \"c.COLUMN_NAME AS 'Name',\", \"c.DATA_TYPE AS 'Type',\", \"c.CHARACTER_MAXIMUM_LENGTH AS 'Length',\", \"c.IS_NULLABLE as 'IsNull',\", \"COLUMN_DEFAULT AS 'Default',\", \"pk.CONSTRAINT_TYPE AS 'Constraint',\", \"COLUMNPROPERTY(OBJECT_ID('[' + c.TABLE_SCHEMA + '].[' + c.TABLE_NAME + ']'), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',\", \"CAST(prop.value AS NVARCHAR) AS 'Comment'\", \"FROM\", \"INFORMATION_SCHEMA.TABLES t\", \"INNER JOIN\", \"INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA\", \"LEFT JOIN (SELECT tc.table_schema, tc.table_name, \", \"cu.column_name, tc.CONSTRAINT_TYPE \", \"FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc \", \"JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu \", \"ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name \", \"and tc.constraint_name=cu.constraint_name \", \"and tc.CONSTRAINT_TYPE='PRIMARY KEY') pk \", \"ON pk.table_schema=c.table_schema \", \"AND pk.table_name=c.table_name \", \"AND pk.column_name=c.column_name \", \"INNER JOIN sys.columns AS sc\", \"ON sc.object_id = OBJECT_ID('[' + t.TABLE_SCHEMA + '].[' + t.TABLE_NAME + ']') AND sc.name = c.column_name\", \"LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id\", \"AND prop.minor_id = sc.column_id\", \"AND prop.name = 'MS_Description'\", \"WHERE t.TABLE_NAME =\", wrapSingleQuote(tableName)].join(\" \");\n    if (schema) {\n      sql += `AND t.TABLE_SCHEMA =${wrapSingleQuote(schema)}`;\n    }\n    return sql;\n  }\n  renameTableQuery(before, after) {\n    return `EXEC sp_rename ${this.quoteTable(before)}, ${this.quoteTable(after)};`;\n  }\n  showTablesQuery() {\n    return \"SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';\";\n  }\n  tableExistsQuery(table) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema || \"dbo\";\n    return `SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = ${this.escape(tableName)} AND TABLE_SCHEMA = ${this.escape(schemaName)}`;\n  }\n  dropTableQuery(tableName) {\n    const quoteTbl = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([`IF OBJECT_ID('${quoteTbl}', 'U') IS NOT NULL`, \"DROP TABLE\", quoteTbl, \";\"]);\n  }\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n    let commentStr = \"\";\n    if (dataType.comment && _.isString(dataType.comment)) {\n      commentStr = this.commentTemplate(dataType.comment, table, key);\n      delete dataType[\"comment\"];\n    }\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(table), \"ADD\", this.quoteIdentifier(key), this.attributeToSQL(dataType, {\n      context: \"addColumn\"\n    }), \";\", commentStr]);\n  }\n  commentTemplate(comment, table, column) {\n    return ` EXEC sp_addextendedproperty @name = N'MS_Description', @value = ${this.escape(comment)}, @level0type = N'Schema', @level0name = 'dbo', @level1type = N'Table', @level1name = ${this.quoteIdentifier(table)}, @level2type = N'Column', @level2name = ${this.quoteIdentifier(column)};`;\n  }\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP COLUMN\", this.quoteIdentifier(attributeName), \";\"]);\n  }\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [],\n      constraintString = [];\n    let commentString = \"\";\n    for (const attributeName in attributes) {\n      const quotedAttrName = this.quoteIdentifier(attributeName);\n      let definition = attributes[attributeName];\n      if (definition.includes(\"COMMENT \")) {\n        const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);\n        const commentText = commentMatch[2].replace(\"COMMENT\", \"\").trim();\n        commentString += this.commentTemplate(commentText, tableName, attributeName);\n        definition = commentMatch[1];\n      }\n      if (definition.includes(\"REFERENCES\")) {\n        constraintString.push(`FOREIGN KEY (${quotedAttrName}) ${definition.replace(/.+?(?=REFERENCES)/, \"\")}`);\n      } else {\n        attrString.push(`${quotedAttrName} ${definition}`);\n      }\n    }\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), attrString.length && `ALTER COLUMN ${attrString.join(\", \")}`, constraintString.length && `ADD ${constraintString.join(\", \")}`, \";\", commentString]);\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return Utils.joinSQLFragments([\"EXEC sp_rename\", `'${this.quoteTable(tableName)}.${attrBefore}',`, `'${newName}',`, \"'COLUMN'\", \";\"]);\n  }\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    const quotedTable = this.quoteTable(tableName);\n    options = options || {};\n    attributes = attributes || {};\n    const tuples = [];\n    const allAttributes = [];\n    const allQueries = [];\n    let needIdentityInsertWrapper = false,\n      outputFragment = \"\";\n    if (options.returning) {\n      const returnValues = this.generateReturnValues(attributes, options);\n      outputFragment = returnValues.outputFragment;\n    }\n    const emptyQuery = `INSERT INTO ${quotedTable}${outputFragment} DEFAULT VALUES`;\n    attrValueHashes.forEach(attrValueHash => {\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        allQueries.push(emptyQuery);\n        return;\n      }\n      _.forOwn(attrValueHash, (value, key) => {\n        if (value !== null && attributes[key] && attributes[key].autoIncrement) {\n          needIdentityInsertWrapper = true;\n        }\n        if (!allAttributes.includes(key)) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement) return;\n          allAttributes.push(key);\n        }\n      });\n    });\n    if (allAttributes.length > 0) {\n      attrValueHashes.forEach(attrValueHash => {\n        tuples.push(`(${allAttributes.map(key => this.escape(attrValueHash[key])).join(\",\")})`);\n      });\n      const quotedAttributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(\",\");\n      allQueries.push(tupleStr => `INSERT INTO ${quotedTable} (${quotedAttributes})${outputFragment} VALUES ${tupleStr};`);\n    }\n    const commands = [];\n    let offset = 0;\n    const batch = Math.floor(250 / (allAttributes.length + 1)) + 1;\n    while (offset < Math.max(tuples.length, 1)) {\n      const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));\n      let generatedQuery = allQueries.map(v => typeof v === \"string\" ? v : v(tupleStr)).join(\";\");\n      if (needIdentityInsertWrapper) {\n        generatedQuery = `SET IDENTITY_INSERT ${quotedTable} ON; ${generatedQuery}; SET IDENTITY_INSERT ${quotedTable} OFF;`;\n      }\n      commands.push(generatedQuery);\n      offset += batch;\n    }\n    return commands.join(\";\");\n  }\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n    if (options.limit) {\n      const updateArgs = `UPDATE TOP(${this.escape(options.limit)})`;\n      sql.query = sql.query.replace(\"UPDATE\", updateArgs);\n    }\n    return sql;\n  }\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    let needIdentityInsertWrapper = false;\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    }\n    for (const index of model._indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === \"string\" ? field : field.name || field.attribute;\n          if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map(key => this.quoteIdentifier(key)).join(\", \");\n    const insertValuesEscaped = insertKeys.map(key => this.escape(insertValues[key])).join(\", \");\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`;\n    let joinCondition;\n    identityAttrs.forEach(key => {\n      if (insertValues[key] && insertValues[key] !== null) {\n        needIdentityInsertWrapper = true;\n      }\n    });\n    const clauses = where[Op.or].filter(clause => {\n      let valid = true;\n      for (const key in clause) {\n        if (typeof clause[key] === \"undefined\" || clause[key] == null) {\n          valid = false;\n          break;\n        }\n      }\n      return valid;\n    });\n    const getJoinSnippet = array => {\n      return array.map(key => {\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n    if (clauses.length === 0) {\n      throw new Error(\"Primary Key or Unique key should be passed to upsert query\");\n    } else {\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n        if (primaryKeysAttrs.includes(keys[0])) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(\" AND \");\n          break;\n        }\n      }\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(\" AND \");\n      }\n    }\n    const filteredUpdateClauses = updateKeys.filter(key => !identityAttrs.includes(key)).map(key => {\n      const value = this.escape(updateValues[key]);\n      key = this.quoteIdentifier(key);\n      return `${targetTableAlias}.${key} = ${value}`;\n    });\n    const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses.join(\", \")}` : \"\";\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;\n    if (needIdentityInsertWrapper) {\n      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;\n    }\n    return query;\n  }\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    const whereClause = this.getWhereConditions(where, null, model, options);\n    return Utils.joinSQLFragments([\"DELETE\", options.limit && `TOP(${this.escape(options.limit)})`, \"FROM\", table, whereClause && `WHERE ${whereClause}`, \";\", \"SELECT @@ROWCOUNT AS AFFECTEDROWS\", \";\"]);\n  }\n  showIndexesQuery(tableName) {\n    return `EXEC sys.sp_helpindex @objname = N'${this.quoteTable(tableName)}';`;\n  }\n  showConstraintsQuery(tableName) {\n    return `EXEC sp_helpconstraint @objname = ${this.escape(this.quoteTable(tableName))};`;\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return `DROP INDEX ${this.quoteIdentifiers(indexName)} ON ${this.quoteIdentifiers(tableName)}`;\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    if (attribute.references) {\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log(\"MSSQL does not support self referencial constraints, we will remove it but we recommend restructuring your query\");\n        attribute.onDelete = \"\";\n        attribute.onUpdate = \"\";\n      }\n    }\n    let template;\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map(value => {\n        return this.escape(value);\n      }).join(\", \")}))`;\n      return template;\n    }\n    template = attribute.type.toString();\n    if (attribute.allowNull === false) {\n      template += \" NOT NULL\";\n    } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += \" NULL\";\n    }\n    if (attribute.autoIncrement) {\n      template += \" IDENTITY(1,1)\";\n    }\n    if (attribute.type !== \"TEXT\" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n    if (attribute.comment && typeof attribute.comment === \"string\") {\n      template += ` COMMENT ${attribute.comment}`;\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {},\n      existingConstraints = [];\n    let key, attribute;\n    for (key in attributes) {\n      attribute = attributes[key];\n      if (attribute.references) {\n        if (existingConstraints.includes(attribute.references.model.toString())) {\n          attribute.onDelete = \"\";\n          attribute.onUpdate = \"\";\n        } else {\n          existingConstraints.push(attribute.references.model.toString());\n          attribute.onUpdate = \"\";\n        }\n      }\n      if (key && !attribute.field) attribute.field = key;\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n    return result;\n  }\n  createTrigger() {\n    throwMethodUndefined(\"createTrigger\");\n  }\n  dropTrigger() {\n    throwMethodUndefined(\"dropTrigger\");\n  }\n  renameTrigger() {\n    throwMethodUndefined(\"renameTrigger\");\n  }\n  createFunction() {\n    throwMethodUndefined(\"createFunction\");\n  }\n  dropFunction() {\n    throwMethodUndefined(\"dropFunction\");\n  }\n  renameFunction() {\n    throwMethodUndefined(\"renameFunction\");\n  }\n  _getForeignKeysQueryPrefix(catalogName) {\n    return `${\"SELECT constraint_name = OBJ.NAME, constraintName = OBJ.NAME, \"}${catalogName ? `constraintCatalog = '${catalogName}', ` : \"\"}constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), tableName = TB.NAME, tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), ${catalogName ? `tableCatalog = '${catalogName}', ` : \"\"}columnName = COL.NAME, referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), ${catalogName ? `referencedCatalog = '${catalogName}', ` : \"\"}referencedTableName = RTB.NAME, referencedColumnName = RCOL.NAME FROM sys.foreign_key_columns FKC INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID`;\n  }\n  getForeignKeysQuery(table, catalogName) {\n    const tableName = table.tableName || table;\n    let sql = `${this._getForeignKeysQueryPrefix(catalogName)} WHERE TB.NAME =${wrapSingleQuote(tableName)}`;\n    if (table.schema) {\n      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;\n    }\n    return sql;\n  }\n  getForeignKeyQuery(table, attributeName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([this._getForeignKeysQueryPrefix(), \"WHERE\", `TB.NAME =${wrapSingleQuote(tableName)}`, \"AND\", `COL.NAME =${wrapSingleQuote(attributeName)}`, table.schema && `AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`]);\n  }\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n    return Utils.joinSQLFragments([\"SELECT K.TABLE_NAME AS tableName,\", \"K.COLUMN_NAME AS columnName,\", \"K.CONSTRAINT_NAME AS constraintName\", \"FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C\", \"JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K\", \"ON C.TABLE_NAME = K.TABLE_NAME\", \"AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG\", \"AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA\", \"AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME\", \"WHERE C.CONSTRAINT_TYPE = 'PRIMARY KEY'\", `AND K.COLUMN_NAME = ${wrapSingleQuote(attributeName)}`, `AND K.TABLE_NAME = ${tableName}`, \";\"]);\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP\", this.quoteIdentifier(foreignKey)]);\n  }\n  getDefaultConstraintQuery(tableName, attributeName) {\n    const quotedTable = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\"SELECT name FROM sys.default_constraints\", `WHERE PARENT_OBJECT_ID = OBJECT_ID('${quotedTable}', 'U')`, `AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('${attributeName}')`, `AND object_id = OBJECT_ID('${quotedTable}', 'U'))`, \";\"]);\n  }\n  dropConstraintQuery(tableName, constraintName) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP CONSTRAINT\", this.quoteIdentifier(constraintName), \";\"]);\n  }\n  setIsolationLevelQuery() {}\n  generateTransactionId() {\n    return randomBytes(10).toString(\"hex\");\n  }\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return \"BEGIN TRANSACTION;\";\n  }\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n    return \"COMMIT TRANSACTION;\";\n  }\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return \"ROLLBACK TRANSACTION;\";\n  }\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {\n    this._throwOnEmptyAttributes(attributes, {\n      modelName: model && model.name,\n      as: mainTableAs\n    });\n    const dbVersion = this.sequelize.options.databaseVersion;\n    const isSQLServer2008 = semver.valid(dbVersion) && semver.lt(dbVersion, \"11.0.0\");\n    if (isSQLServer2008 && options.offset) {\n      const offset = options.offset || 0;\n      const isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n      let orders = {\n        mainQueryOrder: []\n      };\n      if (options.order) {\n        orders = this.getQueryOrders(options, model, isSubQuery);\n      }\n      if (orders.mainQueryOrder.length === 0) {\n        orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));\n      }\n      const tmpTable = mainTableAs || \"OffsetTable\";\n      if (options.include) {\n        const subQuery = options.subQuery === void 0 ? options.limit && options.hasMultiAssociation : options.subQuery;\n        const mainTable = {\n          name: mainTableAs,\n          quotedName: null,\n          as: null,\n          model\n        };\n        const topLevelInfo = {\n          names: mainTable,\n          options,\n          subQuery\n        };\n        let mainJoinQueries = [];\n        for (const include of options.include) {\n          if (include.separate) {\n            continue;\n          }\n          const joinQueries = this.generateInclude(include, {\n            externalAs: mainTableAs,\n            internalAs: mainTableAs\n          }, topLevelInfo);\n          mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n        }\n        return Utils.joinSQLFragments([\"SELECT TOP 100 PERCENT\", attributes.join(\", \"), \"FROM (\", [\"SELECT\", options.limit && `TOP ${options.limit}`, \"* FROM (\", [\"SELECT ROW_NUMBER() OVER (\", [\"ORDER BY\", orders.mainQueryOrder.join(\", \")], `) as row_num, ${tmpTable}.* FROM (`, [\"SELECT DISTINCT\", `${tmpTable}.* FROM ${tables} AS ${tmpTable}`, mainJoinQueries, where && `WHERE ${where}`], `) AS ${tmpTable}`], `) AS ${tmpTable} WHERE row_num > ${offset}`], `) AS ${tmpTable}`]);\n      }\n      return Utils.joinSQLFragments([\"SELECT TOP 100 PERCENT\", attributes.join(\", \"), \"FROM (\", [\"SELECT\", options.limit && `TOP ${options.limit}`, \"* FROM (\", [\"SELECT ROW_NUMBER() OVER (\", [\"ORDER BY\", orders.mainQueryOrder.join(\", \")], `) as row_num, * FROM ${tables} AS ${tmpTable}`, where && `WHERE ${where}`], `) AS ${tmpTable} WHERE row_num > ${offset}`], `) AS ${tmpTable}`]);\n    }\n    return Utils.joinSQLFragments([\"SELECT\", isSQLServer2008 && options.limit && `TOP ${options.limit}`, attributes.join(\", \"), `FROM ${tables}`, mainTableAs && `AS ${mainTableAs}`, options.tableHint && TableHints[options.tableHint] && `WITH (${TableHints[options.tableHint]})`]);\n  }\n  addLimitAndOffset(options, model) {\n    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, \"11.0.0\")) {\n      return \"\";\n    }\n    const offset = options.offset || 0;\n    const isSubQuery = options.subQuery === void 0 ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation : options.subQuery;\n    let fragment = \"\";\n    let orders = {};\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n    if (options.limit || options.offset) {\n      if (!options.order || options.order.length === 0 || options.include && orders.subQueryOrder.length === 0) {\n        let primaryKey = model.primaryKeyField;\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(primaryKey)}`;\n        const aliasedAttribute = (options.attributes || []).find(attr => Array.isArray(attr) && attr[1] && (attr[0] === primaryKey || attr[1] === primaryKey));\n        if (aliasedAttribute) {\n          const modelName = this.quoteIdentifier(options.tableAs || model.name);\n          const alias = this._getAliasForField(modelName, aliasedAttribute[1], options);\n          primaryKey = new Utils.Col(alias || aliasedAttribute[1]);\n        }\n        if (!options.order || !options.order.length) {\n          fragment += ` ORDER BY ${tablePkFragment}`;\n        } else {\n          const orderFieldNames = (options.order || []).map(order => {\n            const value = Array.isArray(order) ? order[0] : order;\n            if (value instanceof Utils.Col) {\n              return value.col;\n            }\n            if (value instanceof Utils.Literal) {\n              return value.val;\n            }\n            return value;\n          });\n          const primaryKeyFieldAlreadyPresent = orderFieldNames.some(fieldName => fieldName === (primaryKey.col || primaryKey));\n          if (!primaryKeyFieldAlreadyPresent) {\n            fragment += options.order && !isSubQuery ? \", \" : \" ORDER BY \";\n            fragment += tablePkFragment;\n          }\n        }\n      }\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n    return fragment;\n  }\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n  quoteIdentifier(identifier, force) {\n    return `[${identifier.replace(/[[\\]']+/g, \"\")}]`;\n  }\n}\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(Utils.removeTicks(identifier, \"'\"), \"'\");\n}\nmodule.exports = MSSQLQueryGenerator;","map":{"version":3,"names":["_","require","Utils","DataTypes","TableHints","AbstractQueryGenerator","randomBytes","semver","Op","throwMethodUndefined","methodName","Error","MSSQLQueryGenerator","createDatabaseQuery","databaseName","options","__spreadValues","collate","collation","escape","wrapSingleQuote","quoteIdentifier","join","dropDatabaseQuery","createSchema","schema","dropSchema","quotedSchema","showSchemasQuery","versionQuery","createTableQuery","tableName","attributes","primaryKeys","foreignKeys","attributesClauseParts","commentStr","attr","Object","prototype","hasOwnProperty","call","dataType","match","includes","commentMatch","commentText","replace","trim","commentTemplate","push","pkString","map","pk","uniqueKeys","each","columns","indexName","customIndex","fields","field","length","fkey","quotedTableName","quoteTable","joinSQLFragments","describeTableQuery","sql","renameTableQuery","before","after","showTablesQuery","tableExistsQuery","table","schemaName","dropTableQuery","quoteTbl","addColumnQuery","key","comment","isString","attributeToSQL","context","column","removeColumnQuery","attributeName","changeColumnQuery","attrString","constraintString","commentString","quotedAttrName","definition","renameColumnQuery","attrBefore","newName","keys","bulkInsertQuery","attrValueHashes","quotedTable","tuples","allAttributes","allQueries","needIdentityInsertWrapper","outputFragment","returning","returnValues","generateReturnValues","emptyQuery","forEach","attrValueHash","firstAttr","autoIncrement","forOwn","value","quotedAttributes","tupleStr","commands","offset","batch","Math","floor","max","slice","min","generatedQuery","v","updateQuery","where","limit","updateArgs","query","upsertQuery","insertValues","updateValues","model","targetTableAlias","sourceTableAlias","primaryKeysAttrs","identityAttrs","uniqueAttrs","tableNameQuoted","rawAttributes","primaryKey","unique","index","_indexes","fieldName","name","attribute","updateKeys","insertKeys","insertKeysQuoted","insertValuesEscaped","sourceTableQuery","joinCondition","clauses","or","filter","clause","valid","getJoinSnippet","array","filteredUpdateClauses","updateSnippet","insertSnippet","truncateTableQuery","deleteQuery","whereClause","getWhereConditions","showIndexesQuery","showConstraintsQuery","removeIndexQuery","indexNameOrAttributes","underscore","quoteIdentifiers","isPlainObject","type","references","Model","sequelize","log","onDelete","onUpdate","template","ENUM","values","toSql","toString","allowNull","defaultValueSchemable","defaultValue","_binary","withoutForeignKeyConstraints","toUpperCase","attributesToSQL","result","existingConstraints","createTrigger","dropTrigger","renameTrigger","createFunction","dropFunction","renameFunction","_getForeignKeysQueryPrefix","catalogName","getForeignKeysQuery","getForeignKeyQuery","getPrimaryKeyConstraintQuery","dropForeignKeyQuery","foreignKey","getDefaultConstraintQuery","dropConstraintQuery","constraintName","setIsolationLevelQuery","generateTransactionId","startTransactionQuery","transaction","parent","commitTransactionQuery","rollbackTransactionQuery","selectFromTableFragment","tables","mainTableAs","_throwOnEmptyAttributes","modelName","as","dbVersion","databaseVersion","isSQLServer2008","lt","isSubQuery","hasIncludeWhere","hasIncludeRequired","hasMultiAssociation","orders","mainQueryOrder","order","getQueryOrders","primaryKeyField","tmpTable","include","subQuery","mainTable","quotedName","topLevelInfo","names","mainJoinQueries","separate","joinQueries","generateInclude","externalAs","internalAs","concat","mainQuery","tableHint","addLimitAndOffset","fragment","subQueryOrder","tablePkFragment","tableAs","aliasedAttribute","find","Array","isArray","alias","_getAliasForField","Col","orderFieldNames","col","Literal","val","primaryKeyFieldAlreadyPresent","some","booleanValue","identifier","force","addTicks","removeTicks","module","exports"],"sources":["C:\\Users\\teply\\OneDrive\\Рабочий стол\\web_project\\client\\node_modules\\sequelize\\src\\dialects\\mssql\\query-generator.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst DataTypes = require('../../data-types');\nconst TableHints = require('../../table-hints');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst randomBytes = require('crypto').randomBytes;\nconst semver = require('semver');\nconst Op = require('../../operators');\n\n/* istanbul ignore next */\nconst throwMethodUndefined = function(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n};\n\nclass MSSQLQueryGenerator extends AbstractQueryGenerator {\n  createDatabaseQuery(databaseName, options) {\n    options = { collate: null, ...options };\n\n    const collation = options.collate ? `COLLATE ${this.escape(options.collate)}` : '';\n\n    return [\n      'IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')',\n      'BEGIN',\n      'CREATE DATABASE', this.quoteIdentifier(databaseName),\n      `${collation};`,\n      'END;'\n    ].join(' ');\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return [\n      'IF EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')',\n      'BEGIN',\n      'DROP DATABASE', this.quoteIdentifier(databaseName), ';',\n      'END;'\n    ].join(' ');\n  }\n\n  createSchema(schema) {\n    return [\n      'IF NOT EXISTS (SELECT schema_name',\n      'FROM information_schema.schemata',\n      'WHERE schema_name =', wrapSingleQuote(schema), ')',\n      'BEGIN',\n      \"EXEC sp_executesql N'CREATE SCHEMA\",\n      this.quoteIdentifier(schema),\n      \";'\",\n      'END;'\n    ].join(' ');\n  }\n\n  dropSchema(schema) {\n    // Mimics Postgres CASCADE, will drop objects belonging to the schema\n    const quotedSchema = wrapSingleQuote(schema);\n    return [\n      'IF EXISTS (SELECT schema_name',\n      'FROM information_schema.schemata',\n      'WHERE schema_name =', quotedSchema, ')',\n      'BEGIN',\n      'DECLARE @id INT, @ms_sql NVARCHAR(2000);',\n      'DECLARE @cascade TABLE (',\n      'id INT NOT NULL IDENTITY PRIMARY KEY,',\n      'ms_sql NVARCHAR(2000) NOT NULL );',\n      'INSERT INTO @cascade ( ms_sql )',\n      \"SELECT CASE WHEN o.type IN ('F','PK')\",\n      \"THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'\",\n      \"ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END\",\n      'FROM sys.objects o',\n      'JOIN sys.schemas s on o.schema_id = s.schema_id',\n      'LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id',\n      \"WHERE o.type IN ('F', 'PK', 'U') AND s.name = \", quotedSchema,\n      'ORDER BY o.type ASC;',\n      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',\n      'WHILE @id IS NOT NULL',\n      'BEGIN',\n      'BEGIN TRY EXEC sp_executesql @ms_sql; END TRY',\n      'BEGIN CATCH BREAK; THROW; END CATCH;',\n      'DELETE FROM @cascade WHERE id = @id;',\n      'SELECT @id = NULL, @ms_sql = NULL;',\n      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',\n      'END',\n      \"EXEC sp_executesql N'DROP SCHEMA\", this.quoteIdentifier(schema), \";'\",\n      'END;'\n    ].join(' ');\n  }\n\n  showSchemasQuery() {\n    return [\n      'SELECT \"name\" as \"schema_name\" FROM sys.schemas as s',\n      'WHERE \"s\".\"name\" NOT IN (',\n      \"'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'\",\n      ')', 'AND', '\"s\".\"name\" NOT LIKE', \"'db_%'\"\n    ].join(' ');\n  }\n\n  versionQuery() {\n    // Uses string manipulation to convert the MS Maj.Min.Patch.Build to semver Maj.Min.Patch\n    return [\n      'DECLARE @ms_ver NVARCHAR(20);',\n      \"SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));\",\n      \"SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'\"\n    ].join(' ');\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [],\n      foreignKeys = {},\n      attributesClauseParts = [];\n\n    let commentStr = '';\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n\n        if (dataType.includes('COMMENT ')) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          const commentText = commentMatch[2].replace('COMMENT', '').trim();\n          commentStr += this.commentTemplate(commentText, tableName, attr);\n          // remove comment related substring from dataType\n          dataType = commentMatch[1];\n        }\n\n        if (dataType.includes('PRIMARY KEY')) {\n          primaryKeys.push(attr);\n\n          if (dataType.includes('REFERENCES')) {\n            // MSSQL doesn't support inline REFERENCES declarations: move to the end\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n            foreignKeys[attr] = match[2];\n          } else {\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n          }\n        } else if (dataType.includes('REFERENCES')) {\n          // MSSQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n        }\n      }\n    }\n\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n          attributesClauseParts.push(`CONSTRAINT ${\n            this.quoteIdentifier(indexName)\n          } UNIQUE (${\n            columns.fields.map(field => this.quoteIdentifier(field)).join(', ')\n          })`);\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClauseParts.push(`PRIMARY KEY (${pkString})`);\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClauseParts.push(`FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`);\n      }\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n\n    return Utils.joinSQLFragments([\n      `IF OBJECT_ID('${quotedTableName}', 'U') IS NULL`,\n      `CREATE TABLE ${quotedTableName} (${attributesClauseParts.join(', ')})`,\n      ';',\n      commentStr\n    ]);\n  }\n\n  describeTableQuery(tableName, schema) {\n    let sql = [\n      'SELECT',\n      \"c.COLUMN_NAME AS 'Name',\",\n      \"c.DATA_TYPE AS 'Type',\",\n      \"c.CHARACTER_MAXIMUM_LENGTH AS 'Length',\",\n      \"c.IS_NULLABLE as 'IsNull',\",\n      \"COLUMN_DEFAULT AS 'Default',\",\n      \"pk.CONSTRAINT_TYPE AS 'Constraint',\",\n      \"COLUMNPROPERTY(OBJECT_ID('[' + c.TABLE_SCHEMA + '].[' + c.TABLE_NAME + ']'), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',\",\n      \"CAST(prop.value AS NVARCHAR) AS 'Comment'\",\n      'FROM',\n      'INFORMATION_SCHEMA.TABLES t',\n      'INNER JOIN',\n      'INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA',\n      'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ',\n      'cu.column_name, tc.CONSTRAINT_TYPE ',\n      'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc ',\n      'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu ',\n      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ',\n      'and tc.constraint_name=cu.constraint_name ',\n      'and tc.CONSTRAINT_TYPE=\\'PRIMARY KEY\\') pk ',\n      'ON pk.table_schema=c.table_schema ',\n      'AND pk.table_name=c.table_name ',\n      'AND pk.column_name=c.column_name ',\n      'INNER JOIN sys.columns AS sc',\n      \"ON sc.object_id = OBJECT_ID('[' + t.TABLE_SCHEMA + '].[' + t.TABLE_NAME + ']') AND sc.name = c.column_name\",\n      'LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id',\n      'AND prop.minor_id = sc.column_id',\n      \"AND prop.name = 'MS_Description'\",\n      'WHERE t.TABLE_NAME =', wrapSingleQuote(tableName)\n    ].join(' ');\n\n    if (schema) {\n      sql += `AND t.TABLE_SCHEMA =${wrapSingleQuote(schema)}`;\n    }\n\n    return sql;\n  }\n\n  renameTableQuery(before, after) {\n    return `EXEC sp_rename ${this.quoteTable(before)}, ${this.quoteTable(after)};`;\n  }\n\n  showTablesQuery() {\n    return \"SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';\";\n  }\n\n  tableExistsQuery(table) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema || 'dbo';\n\n    return `SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = ${this.escape(tableName)} AND TABLE_SCHEMA = ${this.escape(schemaName)}`;\n  }\n\n  dropTableQuery(tableName) {\n    const quoteTbl = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\n      `IF OBJECT_ID('${quoteTbl}', 'U') IS NOT NULL`,\n      'DROP TABLE',\n      quoteTbl,\n      ';'\n    ]);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    // FIXME: attributeToSQL SHOULD be using attributes in addColumnQuery\n    //        but instead we need to pass the key along as the field here\n    dataType.field = key;\n    let commentStr = '';\n\n    if (dataType.comment && _.isString(dataType.comment)) {\n      commentStr = this.commentTemplate(dataType.comment, table, key);\n      // attributeToSQL will try to include `COMMENT 'Comment Text'` when it returns if the comment key\n      // is present. This is needed for createTable statement where that part is extracted with regex.\n      // Here we can intercept the object and remove comment property since we have the original object.\n      delete dataType['comment'];\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'ADD',\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, { context: 'addColumn' }),\n      ';',\n      commentStr\n    ]);\n  }\n\n  commentTemplate(comment, table, column) {\n    return ' EXEC sp_addextendedproperty ' +\n        `@name = N'MS_Description', @value = ${this.escape(comment)}, ` +\n        '@level0type = N\\'Schema\\', @level0name = \\'dbo\\', ' +\n        `@level1type = N'Table', @level1name = ${this.quoteIdentifier(table)}, ` +\n        `@level2type = N'Column', @level2name = ${this.quoteIdentifier(column)};`;\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP COLUMN',\n      this.quoteIdentifier(attributeName),\n      ';'\n    ]);\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [],\n      constraintString = [];\n    let commentString = '';\n\n    for (const attributeName in attributes) {\n      const quotedAttrName = this.quoteIdentifier(attributeName);\n      let definition = attributes[attributeName];\n      if (definition.includes('COMMENT ')) {\n        const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);\n        const commentText = commentMatch[2].replace('COMMENT', '').trim();\n        commentString += this.commentTemplate(commentText, tableName, attributeName);\n        // remove comment related substring from dataType\n        definition = commentMatch[1];\n      }\n      if (definition.includes('REFERENCES')) {\n        constraintString.push(`FOREIGN KEY (${quotedAttrName}) ${definition.replace(/.+?(?=REFERENCES)/, '')}`);\n      } else {\n        attrString.push(`${quotedAttrName} ${definition}`);\n      }\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      attrString.length && `ALTER COLUMN ${attrString.join(', ')}`,\n      constraintString.length && `ADD ${constraintString.join(', ')}`,\n      ';',\n      commentString\n    ]);\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return Utils.joinSQLFragments([\n      'EXEC sp_rename',\n      `'${this.quoteTable(tableName)}.${attrBefore}',`,\n      `'${newName}',`,\n      \"'COLUMN'\",\n      ';'\n    ]);\n  }\n\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    const quotedTable = this.quoteTable(tableName);\n    options = options || {};\n    attributes = attributes || {};\n\n    const tuples = [];\n    const allAttributes = [];\n    const allQueries = [];\n\n    let needIdentityInsertWrapper = false,\n      outputFragment = '';\n\n    if (options.returning) {\n      const returnValues = this.generateReturnValues(attributes, options);\n\n      outputFragment = returnValues.outputFragment;\n    }\n\n    const emptyQuery = `INSERT INTO ${quotedTable}${outputFragment} DEFAULT VALUES`;\n\n    attrValueHashes.forEach(attrValueHash => {\n      // special case for empty objects with primary keys\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        allQueries.push(emptyQuery);\n        return;\n      }\n\n      // normal case\n      _.forOwn(attrValueHash, (value, key) => {\n        if (value !== null && attributes[key] && attributes[key].autoIncrement) {\n          needIdentityInsertWrapper = true;\n        }\n\n        if (!allAttributes.includes(key)) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement)\n            return;\n\n          allAttributes.push(key);\n        }\n      });\n    });\n\n    if (allAttributes.length > 0) {\n      attrValueHashes.forEach(attrValueHash => {\n        tuples.push(`(${\n          allAttributes.map(key =>\n            this.escape(attrValueHash[key])).join(',')\n        })`);\n      });\n\n      const quotedAttributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');\n      allQueries.push(tupleStr => `INSERT INTO ${quotedTable} (${quotedAttributes})${outputFragment} VALUES ${tupleStr};`);\n    }\n    const commands = [];\n    let offset = 0;\n    const batch = Math.floor(250 / (allAttributes.length + 1)) + 1;\n    while (offset < Math.max(tuples.length, 1)) {\n      const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));\n      let generatedQuery = allQueries.map(v => typeof v === 'string' ? v : v(tupleStr)).join(';');\n      if (needIdentityInsertWrapper) {\n        generatedQuery = `SET IDENTITY_INSERT ${quotedTable} ON; ${generatedQuery}; SET IDENTITY_INSERT ${quotedTable} OFF;`;\n      }\n      commands.push(generatedQuery);\n      offset += batch;\n    }\n    return commands.join(';');\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n    if (options.limit) {\n      const updateArgs = `UPDATE TOP(${this.escape(options.limit)})`;\n      sql.query = sql.query.replace('UPDATE', updateArgs);\n    }\n    return sql;\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    let needIdentityInsertWrapper = false;\n\n    //Obtain primaryKeys, uniquekeys and identity attrs from rawAttributes as model is not passed\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    }\n\n    //Add unique indexes defined by indexes option to uniqueAttrs\n    for (const index of model._indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === 'string' ? field : field.name || field.attribute;\n          if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map(key => this.quoteIdentifier(key)).join(', ');\n    const insertValuesEscaped = insertKeys.map(key => this.escape(insertValues[key])).join(', ');\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`; //Virtual Table\n    let joinCondition;\n\n    //IDENTITY_INSERT Condition\n    identityAttrs.forEach(key => {\n      if (insertValues[key] && insertValues[key] !== null) {\n        needIdentityInsertWrapper = true;\n        /*\n         * IDENTITY_INSERT Column Cannot be updated, only inserted\n         * http://stackoverflow.com/a/30176254/2254360\n         */\n      }\n    });\n\n    //Filter NULL Clauses\n    const clauses = where[Op.or].filter(clause => {\n      let valid = true;\n      /*\n       * Exclude NULL Composite PK/UK. Partial Composite clauses should also be excluded as it doesn't guarantee a single row\n       */\n      for (const key in clause) {\n        if (typeof clause[key] === 'undefined' || clause[key] == null) {\n          valid = false;\n          break;\n        }\n      }\n      return valid;\n    });\n\n    /*\n     * Generate ON condition using PK(s).\n     * If not, generate using UK(s). Else throw error\n     */\n    const getJoinSnippet = array => {\n      return array.map(key => {\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n\n    if (clauses.length === 0) {\n      throw new Error('Primary Key or Unique key should be passed to upsert query');\n    } else {\n      // Search for primary key attribute in clauses -- Model can have two separate unique keys\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n        if (primaryKeysAttrs.includes(keys[0])) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(' AND ');\n          break;\n        }\n      }\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(' AND ');\n      }\n    }\n\n    // Remove the IDENTITY_INSERT Column from update\n    const filteredUpdateClauses = updateKeys.filter(key => !identityAttrs.includes(key))\n      .map(key => {\n        const value = this.escape(updateValues[key]);\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${value}`;\n      });\n    const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses.join(', ')}` : '';\n\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n\n    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;\n    if (needIdentityInsertWrapper) {\n      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;\n    }\n    return query;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    const whereClause = this.getWhereConditions(where, null, model, options);\n\n    return Utils.joinSQLFragments([\n      'DELETE',\n      options.limit && `TOP(${this.escape(options.limit)})`,\n      'FROM',\n      table,\n      whereClause && `WHERE ${whereClause}`,\n      ';',\n      'SELECT @@ROWCOUNT AS AFFECTEDROWS',\n      ';'\n    ]);\n  }\n\n  showIndexesQuery(tableName) {\n    return `EXEC sys.sp_helpindex @objname = N'${this.quoteTable(tableName)}';`;\n  }\n\n  showConstraintsQuery(tableName) {\n    return `EXEC sp_helpconstraint @objname = ${this.escape(this.quoteTable(tableName))};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX ${this.quoteIdentifiers(indexName)} ON ${this.quoteIdentifiers(tableName)}`;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    // handle self referential constraints\n    if (attribute.references) {\n\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log('MSSQL does not support self referencial constraints, '\n          + 'we will remove it but we recommend restructuring your query');\n        attribute.onDelete = '';\n        attribute.onUpdate = '';\n      }\n    }\n\n    let template;\n\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n\n      // enums are a special case\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map(value => {\n        return this.escape(value);\n      }).join(', ') }))`;\n      return template;\n    }\n    template = attribute.type.toString();\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ' NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' IDENTITY(1,1)';\n    }\n\n    // Blobs/texts cannot have a defaultValue\n    if (attribute.type !== 'TEXT' && attribute.type._binary !== true &&\n        Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    if (attribute.comment && typeof attribute.comment === 'string') {\n      template += ` COMMENT ${attribute.comment}`;\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {},\n      existingConstraints = [];\n    let key,\n      attribute;\n\n    for (key in attributes) {\n      attribute = attributes[key];\n\n      if (attribute.references) {\n        if (existingConstraints.includes(attribute.references.model.toString())) {\n          // no cascading constraints to a table more than once\n          attribute.onDelete = '';\n          attribute.onUpdate = '';\n        } else {\n          existingConstraints.push(attribute.references.model.toString());\n\n          // NOTE: this really just disables cascading updates for all\n          //       definitions. Can be made more robust to support the\n          //       few cases where MSSQL actually supports them\n          attribute.onUpdate = '';\n        }\n\n      }\n\n      if (key && !attribute.field) attribute.field = key;\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  createTrigger() {\n    throwMethodUndefined('createTrigger');\n  }\n\n  dropTrigger() {\n    throwMethodUndefined('dropTrigger');\n  }\n\n  renameTrigger() {\n    throwMethodUndefined('renameTrigger');\n  }\n\n  createFunction() {\n    throwMethodUndefined('createFunction');\n  }\n\n  dropFunction() {\n    throwMethodUndefined('dropFunction');\n  }\n\n  renameFunction() {\n    throwMethodUndefined('renameFunction');\n  }\n\n  /**\n   * Generate common SQL prefix for ForeignKeysQuery.\n   *\n   * @param {string} catalogName\n   * @returns {string}\n   */\n  _getForeignKeysQueryPrefix(catalogName) {\n    return `${'SELECT ' +\n        'constraint_name = OBJ.NAME, ' +\n        'constraintName = OBJ.NAME, '}${\n      catalogName ? `constraintCatalog = '${catalogName}', ` : ''\n    }constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), ` +\n        'tableName = TB.NAME, ' +\n        `tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), ${\n          catalogName ? `tableCatalog = '${catalogName}', ` : ''\n        }columnName = COL.NAME, ` +\n        `referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), ${\n          catalogName ? `referencedCatalog = '${catalogName}', ` : ''\n        }referencedTableName = RTB.NAME, ` +\n        'referencedColumnName = RCOL.NAME ' +\n      'FROM sys.foreign_key_columns FKC ' +\n        'INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID ' +\n        'INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID ' +\n        'INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID ' +\n        'INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID ' +\n        'INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID';\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys details of a table.\n   *\n   * @param {string|object} table\n   * @param {string} catalogName database name\n   * @returns {string}\n   */\n  getForeignKeysQuery(table, catalogName) {\n    const tableName = table.tableName || table;\n    let sql = `${this._getForeignKeysQueryPrefix(catalogName)\n    } WHERE TB.NAME =${wrapSingleQuote(tableName)}`;\n\n    if (table.schema) {\n      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;\n    }\n    return sql;\n  }\n\n  getForeignKeyQuery(table, attributeName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      this._getForeignKeysQueryPrefix(),\n      'WHERE',\n      `TB.NAME =${wrapSingleQuote(tableName)}`,\n      'AND',\n      `COL.NAME =${wrapSingleQuote(attributeName)}`,\n      table.schema && `AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`\n    ]);\n  }\n\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n    return Utils.joinSQLFragments([\n      'SELECT K.TABLE_NAME AS tableName,',\n      'K.COLUMN_NAME AS columnName,',\n      'K.CONSTRAINT_NAME AS constraintName',\n      'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C',\n      'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K',\n      'ON C.TABLE_NAME = K.TABLE_NAME',\n      'AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG',\n      'AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA',\n      'AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME',\n      'WHERE C.CONSTRAINT_TYPE = \\'PRIMARY KEY\\'',\n      `AND K.COLUMN_NAME = ${wrapSingleQuote(attributeName)}`,\n      `AND K.TABLE_NAME = ${tableName}`,\n      ';'\n    ]);\n  }\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP',\n      this.quoteIdentifier(foreignKey)\n    ]);\n  }\n\n  getDefaultConstraintQuery(tableName, attributeName) {\n    const quotedTable = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\n      'SELECT name FROM sys.default_constraints',\n      `WHERE PARENT_OBJECT_ID = OBJECT_ID('${quotedTable}', 'U')`,\n      `AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('${attributeName}')`,\n      `AND object_id = OBJECT_ID('${quotedTable}', 'U'))`,\n      ';'\n    ]);\n  }\n\n  dropConstraintQuery(tableName, constraintName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP CONSTRAINT',\n      this.quoteIdentifier(constraintName),\n      ';'\n    ]);\n  }\n\n  setIsolationLevelQuery() {\n\n  }\n\n  generateTransactionId() {\n    return randomBytes(10).toString('hex');\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return 'BEGIN TRANSACTION;';\n  }\n\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return 'COMMIT TRANSACTION;';\n  }\n\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return 'ROLLBACK TRANSACTION;';\n  }\n\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {\n    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });\n\n    const dbVersion = this.sequelize.options.databaseVersion;\n    const isSQLServer2008 = semver.valid(dbVersion) && semver.lt(dbVersion, '11.0.0');\n\n    if (isSQLServer2008 && options.offset) {\n      // For earlier versions of SQL server, we need to nest several queries\n      // in order to emulate the OFFSET behavior.\n      //\n      // 1. The outermost query selects all items from the inner query block.\n      //    This is due to a limitation in SQL server with the use of computed\n      //    columns (e.g. SELECT ROW_NUMBER()...AS x) in WHERE clauses.\n      // 2. The next query handles the LIMIT and OFFSET behavior by getting\n      //    the TOP N rows of the query where the row number is > OFFSET\n      // 3. The innermost query is the actual set we want information from\n\n      const offset = options.offset || 0;\n      const isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n      let orders = { mainQueryOrder: [] };\n      if (options.order) {\n        orders = this.getQueryOrders(options, model, isSubQuery);\n      }\n\n      if (orders.mainQueryOrder.length === 0) {\n        orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));\n      }\n\n      const tmpTable = mainTableAs || 'OffsetTable';\n\n      if (options.include) {\n        const subQuery = options.subQuery === undefined ? options.limit && options.hasMultiAssociation : options.subQuery;\n        const mainTable = {\n          name: mainTableAs,\n          quotedName: null,\n          as: null,\n          model\n        };\n        const topLevelInfo = {\n          names: mainTable,\n          options,\n          subQuery\n        };\n\n        let mainJoinQueries = [];\n        for (const include of options.include) {\n          if (include.separate) {\n            continue;\n          }\n          const joinQueries = this.generateInclude(include, { externalAs: mainTableAs, internalAs: mainTableAs }, topLevelInfo);\n          mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n        }\n\n        return Utils.joinSQLFragments([\n          'SELECT TOP 100 PERCENT',\n          attributes.join(', '),\n          'FROM (',\n          [\n            'SELECT',\n            options.limit && `TOP ${options.limit}`,\n            '* FROM (',\n            [\n              'SELECT ROW_NUMBER() OVER (',\n              [\n                'ORDER BY',\n                orders.mainQueryOrder.join(', ')\n              ],\n              `) as row_num, ${tmpTable}.* FROM (`,\n              [\n                'SELECT DISTINCT',\n                `${tmpTable}.* FROM ${tables} AS ${tmpTable}`,\n                mainJoinQueries,\n                where && `WHERE ${where}`\n              ],\n              `) AS ${tmpTable}`\n            ],\n            `) AS ${tmpTable} WHERE row_num > ${offset}`\n          ],\n          `) AS ${tmpTable}`\n        ]);\n      }\n      return Utils.joinSQLFragments([\n        'SELECT TOP 100 PERCENT',\n        attributes.join(', '),\n        'FROM (',\n        [\n          'SELECT',\n          options.limit && `TOP ${options.limit}`,\n          '* FROM (',\n          [\n            'SELECT ROW_NUMBER() OVER (',\n            [\n              'ORDER BY',\n              orders.mainQueryOrder.join(', ')\n            ],\n            `) as row_num, * FROM ${tables} AS ${tmpTable}`,\n            where && `WHERE ${where}`\n          ],\n          `) AS ${tmpTable} WHERE row_num > ${offset}`\n        ],\n        `) AS ${tmpTable}`\n      ]);\n    }\n\n    return Utils.joinSQLFragments([\n      'SELECT',\n      isSQLServer2008 && options.limit && `TOP ${options.limit}`,\n      attributes.join(', '),\n      `FROM ${tables}`,\n      mainTableAs && `AS ${mainTableAs}`,\n      options.tableHint && TableHints[options.tableHint] && `WITH (${TableHints[options.tableHint]})`\n    ]);\n  }\n\n  addLimitAndOffset(options, model) {\n    // Skip handling of limit and offset as postfixes for older SQL Server versions\n    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, '11.0.0')) {\n      return '';\n    }\n\n    const offset = options.offset || 0;\n    const isSubQuery = options.subQuery === undefined\n      ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation\n      : options.subQuery;\n\n    let fragment = '';\n    let orders = {};\n\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n\n    if (options.limit || options.offset) {\n      // TODO: document why this is adding the primary key of the model in ORDER BY\n      //  if options.include is set\n      if (!options.order || options.order.length === 0 || options.include && orders.subQueryOrder.length === 0) {\n        let primaryKey = model.primaryKeyField;\n\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(primaryKey)}`;\n        const aliasedAttribute = (options.attributes || []).find(attr => Array.isArray(attr)\n            && attr[1]\n            && (attr[0] === primaryKey || attr[1] === primaryKey));\n\n        if (aliasedAttribute) {\n          const modelName = this.quoteIdentifier(options.tableAs || model.name);\n          const alias = this._getAliasForField(modelName, aliasedAttribute[1], options);\n\n          primaryKey = new Utils.Col(alias || aliasedAttribute[1]);\n        }\n\n        if (!options.order || !options.order.length) {\n          fragment += ` ORDER BY ${tablePkFragment}`;\n        } else {\n          const orderFieldNames = (options.order || []).map(order => {\n            const value = Array.isArray(order) ? order[0] : order;\n\n            if (value instanceof Utils.Col) {\n              return value.col;\n            }\n\n            if (value instanceof Utils.Literal) {\n              return value.val;\n            }\n\n            return value;\n          });\n          const primaryKeyFieldAlreadyPresent = orderFieldNames.some(\n            fieldName => fieldName === (primaryKey.col || primaryKey)\n          );\n\n          if (!primaryKeyFieldAlreadyPresent) {\n            fragment += options.order && !isSubQuery ? ', ' : ' ORDER BY ';\n            fragment += tablePkFragment;\n          }\n        }\n      }\n\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n\n    return fragment;\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  /**\n   * Quote identifier in sql clause\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    return `[${identifier.replace(/[[\\]']+/g, '')}]`;\n  }\n}\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(Utils.removeTicks(identifier, \"'\"), \"'\");\n}\n\nmodule.exports = MSSQLQueryGenerator;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}