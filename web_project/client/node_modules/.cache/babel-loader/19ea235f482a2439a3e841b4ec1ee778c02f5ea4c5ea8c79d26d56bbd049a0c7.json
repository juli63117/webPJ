{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nconst AbstractConnectionManager = require(\"../abstract/connection-manager\");\nconst SequelizeErrors = require(\"../../errors\");\nconst {\n  logger\n} = require(\"../../utils/logger\");\nconst DataTypes = require(\"../../data-types\").snowflake;\nconst debug = logger.debugContext(\"connection:snowflake\");\nconst parserStore = require(\"../parserStore\")(\"snowflake\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"snowflake-sdk\");\n    this.refreshTypeParser(DataTypes);\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n  async connect(config) {\n    const connectionConfig = __spreadValues({\n      account: config.host,\n      username: config.username,\n      password: config.password,\n      database: config.database,\n      warehouse: config.warehouse,\n      role: config.role\n    }, config.dialectOptions);\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        this.lib.createConnection(connectionConfig).connect((err, conn) => {\n          if (err) {\n            console.log(err);\n            reject(err);\n          } else {\n            resolve(conn);\n          }\n        });\n      });\n      debug(\"connection acquired\");\n      if (!this.sequelize.config.keepDefaultTimezone) {\n        const tzOffset = this.sequelize.options.timezone === \"+00:00\" ? \"Etc/UTC\" : this.sequelize.options.timezone;\n        const isNamedTzOffset = /\\//.test(tzOffset);\n        if (isNamedTzOffset) {\n          await new Promise((resolve, reject) => {\n            connection.execute({\n              sqlText: `ALTER SESSION SET timezone = '${tzOffset}'`,\n              complete(err) {\n                if (err) {\n                  console.log(err);\n                  reject(err);\n                } else {\n                  resolve();\n                }\n              }\n            });\n          });\n        } else {\n          throw Error(\"only support time zone name for snowflake!\");\n        }\n      }\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case \"ECONNREFUSED\":\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case \"ER_ACCESS_DENIED_ERROR\":\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case \"ENOTFOUND\":\n          throw new SequelizeErrors.HostNotFoundError(err);\n        case \"EHOSTUNREACH\":\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case \"EINVAL\":\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n  async disconnect(connection) {\n    if (!connection.isUp()) {\n      debug(\"connection tried to disconnect but was already at CLOSED state\");\n      return;\n    }\n    return new Promise((resolve, reject) => {\n      connection.destroy(err => {\n        if (err) {\n          console.error(`Unable to disconnect: ${err.message}`);\n          reject(err);\n        } else {\n          console.log(`Disconnected connection with id: ${connection.getId()}`);\n          resolve(connection.getId());\n        }\n      });\n    });\n  }\n  validate(connection) {\n    return connection.isUp();\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"names":["AbstractConnectionManager","require","SequelizeErrors","logger","DataTypes","snowflake","debug","debugContext","parserStore","ConnectionManager","constructor","dialect","sequelize","config","port","lib","_loadDialectModule","refreshTypeParser","_refreshTypeParser","dataType","refresh","_clearTypeParser","clear","_typecast","field","next","get","type","options","connect","connectionConfig","__spreadValues","account","host","username","password","database","warehouse","role","dialectOptions","connection","Promise","resolve","reject","createConnection","err","conn","console","log","keepDefaultTimezone","tzOffset","timezone","isNamedTzOffset","test","execute","sqlText","complete","Error","code","ConnectionRefusedError","AccessDeniedError","HostNotFoundError","HostNotReachableError","InvalidConnectionError","ConnectionError","disconnect","isUp","destroy","error","message","getId","validate","module","exports","default"],"sources":["C:\\Users\\teply\\OneDrive\\Рабочий стол\\web_project\\client\\node_modules\\sequelize\\src\\dialects\\snowflake\\connection-manager.js"],"sourcesContent":["'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst SequelizeErrors = require('../../errors');\nconst { logger } = require('../../utils/logger');\nconst DataTypes = require('../../data-types').snowflake;\nconst debug = logger.debugContext('connection:snowflake');\nconst parserStore = require('../parserStore')('snowflake');\n\n/**\n * Snowflake Connection Manager\n *\n * Get connections, validate and disconnect them.\n *\n * @private\n */\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('snowflake-sdk');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n\n  /**\n   * Connect with a snowflake database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once connection is connected.\n   *\n   * @param {object} config\n   * @returns {Promise<Connection>}\n   * @private\n   */\n  async connect(config) {\n    const connectionConfig = {\n      account: config.host,\n      username: config.username,\n      password: config.password,\n      database: config.database,\n      warehouse: config.warehouse,\n      role: config.role,\n      /*\n      flags: '-FOUND_ROWS',\n      timezone: this.sequelize.options.timezone,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true,\n      */\n      ...config.dialectOptions\n    };\n\n    try {\n\n      const connection = await new Promise((resolve, reject) => {\n        this.lib.createConnection(connectionConfig).connect((err, conn) => {\n          if (err) {\n            console.log(err);\n            reject(err);\n          } else {\n            resolve(conn);\n          }\n        });\n      });\n\n      debug('connection acquired');\n\n      if (!this.sequelize.config.keepDefaultTimezone) {\n        // default value is '+00:00', put a quick workaround for it.\n        const tzOffset = this.sequelize.options.timezone === '+00:00' ? 'Etc/UTC' : this.sequelize.options.timezone;\n        const isNamedTzOffset = /\\//.test(tzOffset);\n        if ( isNamedTzOffset ) {\n          await new Promise((resolve, reject) => {\n            connection.execute({\n              sqlText: `ALTER SESSION SET timezone = '${tzOffset}'`,\n              complete(err) {\n                if (err) {\n                  console.log(err);\n                  reject(err);\n                } else {\n                  resolve();\n                }\n              }\n            });\n          });\n        } else {\n          throw Error('only support time zone name for snowflake!');\n        }\n      }\n\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case 'ECONNREFUSED':\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case 'ER_ACCESS_DENIED_ERROR':\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case 'ENOTFOUND':\n          throw new SequelizeErrors.HostNotFoundError(err);\n        case 'EHOSTUNREACH':\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case 'EINVAL':\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    // Don't disconnect connections with CLOSED state\n    if (!connection.isUp()) {\n      debug('connection tried to disconnect but was already at CLOSED state');\n      return;\n    }\n\n    return new Promise((resolve, reject) => {\n      connection.destroy(err => {\n        if (err) {\n          console.error(`Unable to disconnect: ${err.message}`);\n          reject(err);\n        } else {\n          console.log(`Disconnected connection with id: ${connection.getId()}`);\n          resolve(connection.getId());\n        }\n      });\n    });\n  }\n\n  validate(connection) {\n    return connection.isUp();\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}