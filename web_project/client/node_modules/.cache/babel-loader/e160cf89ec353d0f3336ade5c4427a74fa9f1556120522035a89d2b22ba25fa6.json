{"ast":null,"code":"\"use strict\";\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst AbstractConnectionManager = require(\"../abstract/connection-manager\");\nconst {\n  logger\n} = require(\"../../utils/logger\");\nconst debug = logger.debugContext(\"connection:sqlite\");\nconst dataTypes = require(\"../../data-types\").sqlite;\nconst sequelizeErrors = require(\"../../errors\");\nconst parserStore = require(\"../parserStore\")(\"sqlite\");\nconst {\n  promisify\n} = require(\"util\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n    if (this.sequelize.options.host === \"localhost\") {\n      delete this.sequelize.options.host;\n    }\n    this.connections = {};\n    this.lib = this._loadDialectModule(\"sqlite3\");\n    this.refreshTypeParser(dataTypes);\n  }\n  async _onProcessExit() {\n    await Promise.all(Object.getOwnPropertyNames(this.connections).map(connection => promisify(callback => this.connections[connection].close(callback))()));\n    return super._onProcessExit.call(this);\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  async getConnection(options) {\n    options = options || {};\n    options.uuid = options.uuid || \"default\";\n    if (!!this.sequelize.options.storage !== null && this.sequelize.options.storage !== void 0) {\n      options.storage = this.sequelize.options.storage;\n    } else {\n      options.storage = this.sequelize.options.host || \":memory:\";\n    }\n    options.inMemory = options.storage === \":memory:\" ? 1 : 0;\n    const dialectOptions = this.sequelize.options.dialectOptions;\n    const defaultReadWriteMode = this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE;\n    options.readWriteMode = dialectOptions && dialectOptions.mode || defaultReadWriteMode;\n    if (this.connections[options.inMemory || options.uuid]) {\n      return this.connections[options.inMemory || options.uuid];\n    }\n    if (!options.inMemory && (options.readWriteMode & this.lib.OPEN_CREATE) !== 0) {\n      fs.mkdirSync(path.dirname(options.storage), {\n        recursive: true\n      });\n    }\n    const connection = await new Promise((resolve, reject) => {\n      this.connections[options.inMemory || options.uuid] = new this.lib.Database(options.storage, options.readWriteMode, err => {\n        if (err) return reject(new sequelizeErrors.ConnectionError(err));\n        debug(`connection acquired ${options.uuid}`);\n        resolve(this.connections[options.inMemory || options.uuid]);\n      });\n    });\n    if (this.sequelize.config.password) {\n      connection.run(`PRAGMA KEY=${this.sequelize.escape(this.sequelize.config.password)}`);\n    }\n    if (this.sequelize.options.foreignKeys !== false) {\n      connection.run(\"PRAGMA FOREIGN_KEYS=ON\");\n    }\n    return connection;\n  }\n  releaseConnection(connection, force) {\n    if (connection.filename === \":memory:\" && force !== true) return;\n    if (connection.uuid) {\n      connection.close();\n      debug(`connection released ${connection.uuid}`);\n      delete this.connections[connection.uuid];\n    }\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"names":["fs","require","path","AbstractConnectionManager","logger","debug","debugContext","dataTypes","sqlite","sequelizeErrors","parserStore","promisify","ConnectionManager","constructor","dialect","sequelize","options","host","connections","lib","_loadDialectModule","refreshTypeParser","_onProcessExit","Promise","all","Object","getOwnPropertyNames","map","connection","callback","close","call","_refreshTypeParser","dataType","refresh","_clearTypeParser","clear","getConnection","uuid","storage","inMemory","dialectOptions","defaultReadWriteMode","OPEN_READWRITE","OPEN_CREATE","readWriteMode","mode","mkdirSync","dirname","recursive","resolve","reject","Database","err","ConnectionError","config","password","run","escape","foreignKeys","releaseConnection","force","filename","module","exports","default"],"sources":["C:\\Users\\teply\\OneDrive\\Рабочий стол\\web_project\\client\\node_modules\\sequelize\\src\\dialects\\sqlite\\connection-manager.js"],"sourcesContent":["'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst { logger } = require('../../utils/logger');\nconst debug = logger.debugContext('connection:sqlite');\nconst dataTypes = require('../../data-types').sqlite;\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('sqlite');\nconst { promisify } = require('util');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n\n    // We attempt to parse file location from a connection uri\n    // but we shouldn't match sequelize default host.\n    if (this.sequelize.options.host === 'localhost') {\n      delete this.sequelize.options.host;\n    }\n\n    this.connections = {};\n    this.lib = this._loadDialectModule('sqlite3');\n    this.refreshTypeParser(dataTypes);\n  }\n\n  async _onProcessExit() {\n    await Promise.all(\n      Object.getOwnPropertyNames(this.connections)\n        .map(connection => promisify(callback => this.connections[connection].close(callback))())\n    );\n    return super._onProcessExit.call(this);\n  }\n\n  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async getConnection(options) {\n    options = options || {};\n    options.uuid = options.uuid || 'default';\n\n    if (!!this.sequelize.options.storage !== null && this.sequelize.options.storage !== undefined) {\n      // Check explicitely for the storage option to not be set since an empty string signals\n      // SQLite will create a temporary disk-based database in that case.\n      options.storage = this.sequelize.options.storage;\n    } else {\n      options.storage = this.sequelize.options.host || ':memory:';\n    }\n\n    options.inMemory = options.storage === ':memory:' ? 1 : 0;\n\n    const dialectOptions = this.sequelize.options.dialectOptions;\n    const defaultReadWriteMode = this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE;\n\n    options.readWriteMode = dialectOptions && dialectOptions.mode || defaultReadWriteMode;\n\n    if (this.connections[options.inMemory || options.uuid]) {\n      return this.connections[options.inMemory || options.uuid];\n    }\n\n    if (!options.inMemory && (options.readWriteMode & this.lib.OPEN_CREATE) !== 0) {\n      // automatic path provision for `options.storage`\n      fs.mkdirSync(path.dirname(options.storage), { recursive: true });\n    }\n\n    const connection = await new Promise((resolve, reject) => {\n      this.connections[options.inMemory || options.uuid] = new this.lib.Database(\n        options.storage,\n        options.readWriteMode,\n        err => {\n          if (err) return reject(new sequelizeErrors.ConnectionError(err));\n          debug(`connection acquired ${options.uuid}`);\n          resolve(this.connections[options.inMemory || options.uuid]);\n        }\n      );\n    });\n\n    if (this.sequelize.config.password) {\n      // Make it possible to define and use password for sqlite encryption plugin like sqlcipher\n      connection.run(`PRAGMA KEY=${this.sequelize.escape(this.sequelize.config.password)}`);\n    }\n    if (this.sequelize.options.foreignKeys !== false) {\n      // Make it possible to define and use foreign key constraints unless\n      // explicitly disallowed. It's still opt-in per relation\n      connection.run('PRAGMA FOREIGN_KEYS=ON');\n    }\n\n    return connection;\n  }\n\n  releaseConnection(connection, force) {\n    if (connection.filename === ':memory:' && force !== true) return;\n\n    if (connection.uuid) {\n      connection.close();\n      debug(`connection released ${connection.uuid}`);\n      delete this.connections[connection.uuid];\n    }\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}