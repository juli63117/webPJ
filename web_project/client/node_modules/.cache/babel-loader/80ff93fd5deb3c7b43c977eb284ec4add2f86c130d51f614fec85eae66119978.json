{"ast":null,"code":"\"use strict\";\n\nconst {\n  Pool,\n  TimeoutError\n} = require(\"sequelize-pool\");\nconst _ = require(\"lodash\");\nconst semver = require(\"semver\");\nconst errors = require(\"../../errors\");\nconst {\n  logger\n} = require(\"../../utils/logger\");\nconst deprecations = require(\"../../utils/deprecations\");\nconst debug = logger.debugContext(\"pool\");\nclass ConnectionManager {\n  constructor(dialect, sequelize) {\n    const config = _.cloneDeep(sequelize.config);\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.dialectName = this.sequelize.options.dialect;\n    if (config.pool === false) {\n      throw new Error(\"Support for pool:false was removed in v4.0\");\n    }\n    config.pool = _.defaults(config.pool || {}, {\n      max: 5,\n      min: 0,\n      idle: 1e4,\n      acquire: 6e4,\n      evict: 1e3,\n      validate: this._validate.bind(this)\n    });\n    this.initPools();\n  }\n  refreshTypeParser(dataTypes) {\n    _.each(dataTypes, dataType => {\n      if (Object.prototype.hasOwnProperty.call(dataType, \"parse\")) {\n        if (dataType.types[this.dialectName]) {\n          this._refreshTypeParser(dataType);\n        } else {\n          throw new Error(`Parse function not supported for type ${dataType.key} in dialect ${this.dialectName}`);\n        }\n      }\n    });\n  }\n  _loadDialectModule(moduleName) {\n    try {\n      if (this.sequelize.config.dialectModulePath) {\n        return require(this.sequelize.config.dialectModulePath);\n      }\n      if (this.sequelize.config.dialectModule) {\n        return this.sequelize.config.dialectModule;\n      }\n      return require(moduleName);\n    } catch (err) {\n      if (err.code === \"MODULE_NOT_FOUND\") {\n        if (this.sequelize.config.dialectModulePath) {\n          throw new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`);\n        }\n        throw new Error(`Please install ${moduleName} package manually`);\n      }\n      throw err;\n    }\n  }\n  async _onProcessExit() {\n    if (!this.pool) {\n      return;\n    }\n    await this.pool.drain();\n    debug(\"connection drain due to process exit\");\n    return await this.pool.destroyAllNow();\n  }\n  async close() {\n    this.getConnection = async function getConnection() {\n      throw new Error(\"ConnectionManager.getConnection was called after the connection manager was closed!\");\n    };\n    return await this._onProcessExit();\n  }\n  initPools() {\n    const config = this.config;\n    if (!config.replication) {\n      this.pool = new Pool({\n        name: \"sequelize\",\n        create: () => this._connect(config),\n        destroy: async connection => {\n          const result = await this._disconnect(connection);\n          debug(\"connection destroy\");\n          return result;\n        },\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      });\n      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);\n      return;\n    }\n    if (!Array.isArray(config.replication.read)) {\n      config.replication.read = [config.replication.read];\n    }\n    config.replication.write = _.defaults(config.replication.write, _.omit(config, \"replication\"));\n    config.replication.read = config.replication.read.map(readConfig => _.defaults(readConfig, _.omit(this.config, \"replication\")));\n    let reads = 0;\n    this.pool = {\n      release: client => {\n        if (client.queryType === \"read\") {\n          this.pool.read.release(client);\n        } else {\n          this.pool.write.release(client);\n        }\n      },\n      acquire: (queryType, useMaster) => {\n        useMaster = useMaster === void 0 ? false : useMaster;\n        if (queryType === \"SELECT\" && !useMaster) {\n          return this.pool.read.acquire();\n        }\n        return this.pool.write.acquire();\n      },\n      destroy: connection => {\n        this.pool[connection.queryType].destroy(connection);\n        debug(\"connection destroy\");\n      },\n      destroyAllNow: async () => {\n        await Promise.all([this.pool.read.destroyAllNow(), this.pool.write.destroyAllNow()]);\n        debug(\"all connections destroyed\");\n      },\n      drain: async () => Promise.all([this.pool.write.drain(), this.pool.read.drain()]),\n      read: new Pool({\n        name: \"sequelize:read\",\n        create: async () => {\n          const nextRead = reads++ % config.replication.read.length;\n          const connection = await this._connect(config.replication.read[nextRead]);\n          connection.queryType = \"read\";\n          return connection;\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      }),\n      write: new Pool({\n        name: \"sequelize:write\",\n        create: async () => {\n          const connection = await this._connect(config.replication.write);\n          connection.queryType = \"write\";\n          return connection;\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      })\n    };\n    debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);\n  }\n  async getConnection(options) {\n    options = options || {};\n    if (this.sequelize.options.databaseVersion === 0) {\n      if (!this.versionPromise) {\n        this.versionPromise = (async () => {\n          try {\n            const connection = await this._connect(this.config.replication.write || this.config);\n            const _options = {};\n            _options.transaction = {\n              connection\n            };\n            _options.logging = () => {};\n            _options.logging.__testLoggingFn = true;\n            if (this.sequelize.options.databaseVersion === 0) {\n              const version = await this.sequelize.databaseVersion(_options);\n              const parsedVersion = _.get(semver.coerce(version), \"version\") || version;\n              this.sequelize.options.databaseVersion = semver.valid(parsedVersion) ? parsedVersion : this.dialect.defaultVersion;\n            }\n            if (semver.lt(this.sequelize.options.databaseVersion, this.dialect.defaultVersion)) {\n              deprecations.unsupportedEngine();\n              debug(`Unsupported database engine version ${this.sequelize.options.databaseVersion}`);\n            }\n            this.versionPromise = null;\n            return await this._disconnect(connection);\n          } catch (err) {\n            this.versionPromise = null;\n            throw err;\n          }\n        })();\n      }\n      await this.versionPromise;\n    }\n    let result;\n    try {\n      await this.sequelize.runHooks(\"beforePoolAcquire\", options);\n      result = await this.pool.acquire(options.type, options.useMaster);\n      await this.sequelize.runHooks(\"afterPoolAcquire\", result, options);\n    } catch (error) {\n      if (error instanceof TimeoutError) throw new errors.ConnectionAcquireTimeoutError(error);\n      throw error;\n    }\n    debug(\"connection acquired\");\n    return result;\n  }\n  releaseConnection(connection) {\n    this.pool.release(connection);\n    debug(\"connection released\");\n  }\n  async destroyConnection(connection) {\n    await this.pool.destroy(connection);\n    debug(`connection ${connection.uuid} destroyed`);\n  }\n  async _connect(config) {\n    await this.sequelize.runHooks(\"beforeConnect\", config);\n    const connection = await this.dialect.connectionManager.connect(config);\n    await this.sequelize.runHooks(\"afterConnect\", connection, config);\n    return connection;\n  }\n  async _disconnect(connection) {\n    await this.sequelize.runHooks(\"beforeDisconnect\", connection);\n    await this.dialect.connectionManager.disconnect(connection);\n    return this.sequelize.runHooks(\"afterDisconnect\", connection);\n  }\n  _validate(connection) {\n    if (!this.dialect.connectionManager.validate) {\n      return true;\n    }\n    return this.dialect.connectionManager.validate(connection);\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"names":["Pool","TimeoutError","require","_","semver","errors","logger","deprecations","debug","debugContext","ConnectionManager","constructor","dialect","sequelize","config","cloneDeep","versionPromise","dialectName","options","pool","Error","defaults","max","min","idle","acquire","evict","validate","_validate","bind","initPools","refreshTypeParser","dataTypes","each","dataType","Object","prototype","hasOwnProperty","call","types","_refreshTypeParser","key","_loadDialectModule","moduleName","dialectModulePath","dialectModule","err","code","_onProcessExit","drain","destroyAllNow","close","getConnection","replication","name","create","_connect","destroy","connection","result","_disconnect","acquireTimeoutMillis","idleTimeoutMillis","reapIntervalMillis","maxUses","Array","isArray","read","write","omit","map","readConfig","reads","release","client","queryType","useMaster","Promise","all","nextRead","length","databaseVersion","_options","transaction","logging","__testLoggingFn","version","parsedVersion","get","coerce","valid","defaultVersion","lt","unsupportedEngine","runHooks","type","error","ConnectionAcquireTimeoutError","releaseConnection","destroyConnection","uuid","connectionManager","connect","disconnect","module","exports","default"],"sources":["C:\\Users\\teply\\OneDrive\\Рабочий стол\\web_project\\client\\node_modules\\sequelize\\src\\dialects\\abstract\\connection-manager.js"],"sourcesContent":["'use strict';\n\nconst { Pool, TimeoutError } = require('sequelize-pool');\nconst _ = require('lodash');\nconst semver = require('semver');\nconst errors = require('../../errors');\nconst { logger } = require('../../utils/logger');\nconst deprecations = require('../../utils/deprecations');\nconst debug = logger.debugContext('pool');\n\n/**\n * Abstract Connection Manager\n *\n * Connection manager which handles pooling & replication.\n * Uses sequelize-pool for pooling\n *\n * @private\n */\nclass ConnectionManager {\n  constructor(dialect, sequelize) {\n    const config = _.cloneDeep(sequelize.config);\n\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.dialectName = this.sequelize.options.dialect;\n\n    if (config.pool === false) {\n      throw new Error('Support for pool:false was removed in v4.0');\n    }\n\n    config.pool = _.defaults(config.pool || {}, {\n      max: 5,\n      min: 0,\n      idle: 10000,\n      acquire: 60000,\n      evict: 1000,\n      validate: this._validate.bind(this)\n    });\n\n    this.initPools();\n  }\n\n  refreshTypeParser(dataTypes) {\n    _.each(dataTypes, dataType => {\n      if (Object.prototype.hasOwnProperty.call(dataType, 'parse')) {\n        if (dataType.types[this.dialectName]) {\n          this._refreshTypeParser(dataType);\n        } else {\n          throw new Error(`Parse function not supported for type ${dataType.key} in dialect ${this.dialectName}`);\n        }\n      }\n    });\n  }\n\n  /**\n   * Try to load dialect module from various configured options.\n   * Priority goes like dialectModulePath > dialectModule > require(default)\n   *\n   * @param {string} moduleName Name of dialect module to lookup\n   *\n   * @private\n   * @returns {object}\n   */\n  _loadDialectModule(moduleName) {\n    try {\n      if (this.sequelize.config.dialectModulePath) {\n        return require(this.sequelize.config.dialectModulePath);\n      }\n      if (this.sequelize.config.dialectModule) {\n        return this.sequelize.config.dialectModule;\n      }\n      return require(moduleName);\n\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        if (this.sequelize.config.dialectModulePath) {\n          throw new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`);\n        }\n        throw new Error(`Please install ${moduleName} package manually`);\n      }\n\n      throw err;\n    }\n  }\n\n  /**\n   * Handler which executes on process exit or connection manager shutdown\n   *\n   * @private\n   * @returns {Promise}\n   */\n  async _onProcessExit() {\n    if (!this.pool) {\n      return;\n    }\n\n    await this.pool.drain();\n    debug('connection drain due to process exit');\n\n    return await this.pool.destroyAllNow();\n  }\n\n  /**\n   * Drain the pool and close it permanently\n   *\n   * @returns {Promise}\n   */\n  async close() {\n    // Mark close of pool\n    this.getConnection = async function getConnection() {\n      throw new Error('ConnectionManager.getConnection was called after the connection manager was closed!');\n    };\n\n    return await this._onProcessExit();\n  }\n\n  /**\n   * Initialize connection pool. By default pool autostart is set to false, so no connection will be\n   * be created unless `pool.acquire` is called.\n   */\n  initPools() {\n    const config = this.config;\n\n    if (!config.replication) {\n      this.pool = new Pool({\n        name: 'sequelize',\n        create: () => this._connect(config),\n        destroy: async connection => {\n          const result = await this._disconnect(connection);\n          debug('connection destroy');\n          return result;\n        },\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      });\n\n      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);\n\n      return;\n    }\n\n    if (!Array.isArray(config.replication.read)) {\n      config.replication.read = [config.replication.read];\n    }\n\n    // Map main connection config\n    config.replication.write = _.defaults(config.replication.write, _.omit(config, 'replication'));\n\n    // Apply defaults to each read config\n    config.replication.read = config.replication.read.map(readConfig =>\n      _.defaults(readConfig, _.omit(this.config, 'replication'))\n    );\n\n    // custom pooling for replication (original author @janmeier)\n    let reads = 0;\n    this.pool = {\n      release: client => {\n        if (client.queryType === 'read') {\n          this.pool.read.release(client);\n        } else {\n          this.pool.write.release(client);\n        }\n      },\n      acquire: (queryType, useMaster) => {\n        useMaster = useMaster === undefined ? false : useMaster;\n        if (queryType === 'SELECT' && !useMaster) {\n          return this.pool.read.acquire();\n        }\n        return this.pool.write.acquire();\n      },\n      destroy: connection => {\n        this.pool[connection.queryType].destroy(connection);\n        debug('connection destroy');\n      },\n      destroyAllNow: async () => {\n        await Promise.all([\n          this.pool.read.destroyAllNow(),\n          this.pool.write.destroyAllNow()\n        ]);\n\n        debug('all connections destroyed');\n      },\n      drain: async () => Promise.all([\n        this.pool.write.drain(),\n        this.pool.read.drain()\n      ]),\n      read: new Pool({\n        name: 'sequelize:read',\n        create: async () => {\n          // round robin config\n          const nextRead = reads++ % config.replication.read.length;\n          const connection = await this._connect(config.replication.read[nextRead]);\n          connection.queryType = 'read';\n          return connection;\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      }),\n      write: new Pool({\n        name: 'sequelize:write',\n        create: async () => {\n          const connection = await this._connect(config.replication.write);\n          connection.queryType = 'write';\n          return connection;\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      })\n    };\n\n    debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);\n  }\n\n  /**\n   * Get connection from pool. It sets database version if it's not already set.\n   * Call pool.acquire to get a connection\n   *\n   * @param {object}   [options]                 Pool options\n   * @param {string}   [options.type]            Set which replica to use. Available options are `read` and `write`\n   * @param {boolean}  [options.useMaster=false] Force master or write replica to get connection from\n   *\n   * @returns {Promise<Connection>}\n   */\n  async getConnection(options) {\n    options = options || {};\n\n    if (this.sequelize.options.databaseVersion === 0) {\n      if (!this.versionPromise) {\n        this.versionPromise = (async () => {\n          try {\n            const connection = await this._connect(this.config.replication.write || this.config);\n            const _options = {};\n\n            _options.transaction = { connection }; // Cheat .query to use our private connection\n            _options.logging = () => {};\n            _options.logging.__testLoggingFn = true;\n\n            //connection might have set databaseVersion value at initialization,\n            //avoiding a useless round trip\n            if (this.sequelize.options.databaseVersion === 0) {\n              const version = await this.sequelize.databaseVersion(_options);\n              const parsedVersion = _.get(semver.coerce(version), 'version') || version;\n              this.sequelize.options.databaseVersion = semver.valid(parsedVersion)\n                ? parsedVersion\n                : this.dialect.defaultVersion;\n            }\n\n            if (semver.lt(this.sequelize.options.databaseVersion, this.dialect.defaultVersion)) {\n              deprecations.unsupportedEngine();\n              debug(`Unsupported database engine version ${this.sequelize.options.databaseVersion}`);\n            }\n\n            this.versionPromise = null;\n            return await this._disconnect(connection);\n          } catch (err) {\n            this.versionPromise = null;\n            throw err;\n          }\n        })();\n      }\n      await this.versionPromise;\n    }\n\n    let result;\n\n    try {\n\n      await this.sequelize.runHooks('beforePoolAcquire', options);\n\n      result = await this.pool.acquire(options.type, options.useMaster);\n\n      await this.sequelize.runHooks('afterPoolAcquire', result, options);\n\n    } catch (error) {\n      if (error instanceof TimeoutError) throw new errors.ConnectionAcquireTimeoutError(error);\n      throw error;\n    }\n\n    debug('connection acquired');\n\n    return result;\n  }\n\n  /**\n   * Release a pooled connection so it can be utilized by other connection requests\n   *\n   * @param {Connection} connection\n   */\n  releaseConnection(connection) {\n    this.pool.release(connection);\n    debug('connection released');\n  }\n\n  /**\n   * Destroys a pooled connection and removes it from the pool.\n   *\n   * @param {Connection} connection\n   */\n  async destroyConnection(connection) {\n    await this.pool.destroy(connection);\n    debug(`connection ${connection.uuid} destroyed`);\n  }\n\n  /**\n   * Call dialect library to get connection\n   *\n   * @param {*} config Connection config\n   * @private\n   * @returns {Promise<Connection>}\n   */\n  async _connect(config) {\n    await this.sequelize.runHooks('beforeConnect', config);\n    const connection = await this.dialect.connectionManager.connect(config);\n    await this.sequelize.runHooks('afterConnect', connection, config);\n    return connection;\n  }\n\n  /**\n   * Call dialect library to disconnect a connection\n   *\n   * @param {Connection} connection\n   * @private\n   * @returns {Promise}\n   */\n  async _disconnect(connection) {\n    await this.sequelize.runHooks('beforeDisconnect', connection);\n    await this.dialect.connectionManager.disconnect(connection);\n    return this.sequelize.runHooks('afterDisconnect', connection);\n  }\n\n  /**\n   * Determine if a connection is still valid or not\n   *\n   * @param {Connection} connection\n   *\n   * @returns {boolean}\n   */\n  _validate(connection) {\n    if (!this.dialect.connectionManager.validate) {\n      return true;\n    }\n\n    return this.dialect.connectionManager.validate(connection);\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}