{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = require(\"lodash\");\nconst Utils = require(\"../../utils\");\nconst DataTypes = require(\"../../data-types\");\nconst Transaction = require(\"../../transaction\");\nconst QueryTypes = require(\"../../query-types\");\nclass QueryInterface {\n  constructor(sequelize, queryGenerator) {\n    this.sequelize = sequelize;\n    this.queryGenerator = queryGenerator;\n  }\n  async createDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createDatabaseQuery(database, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async dropDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropDatabaseQuery(database);\n    return await this.sequelize.query(sql, options);\n  }\n  async createSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n  async dropSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n  async dropAllSchemas(options) {\n    options = options || {};\n    if (!this.queryGenerator._dialect.supports.schemas) {\n      return this.sequelize.drop(options);\n    }\n    const schemas = await this.showAllSchemas(options);\n    return Promise.all(schemas.map(schemaName => this.dropSchema(schemaName, options)));\n  }\n  async showAllSchemas(options) {\n    options = __spreadProps(__spreadValues({}, options), {\n      raw: true,\n      type: this.sequelize.QueryTypes.SELECT\n    });\n    const showSchemasSql = this.queryGenerator.showSchemasQuery(options);\n    const schemaNames = await this.sequelize.query(showSchemasSql, options);\n    return _.flatten(schemaNames.map(value => value.schema_name ? value.schema_name : value));\n  }\n  async databaseVersion(options) {\n    return await this.sequelize.query(this.queryGenerator.versionQuery(), __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.VERSION\n    }));\n  }\n  async createTable(tableName, attributes, options, model) {\n    let sql = \"\";\n    options = __spreadValues({}, options);\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, uniqueKey => {\n        if (uniqueKey.customIndex === void 0) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n    attributes = _.mapValues(attributes, attribute => this.sequelize.normalizeAttribute(attribute));\n    await this.ensureEnums(tableName, attributes, options, model);\n    if (!tableName.schema && (options.schema || !!model && model._schema)) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n    attributes = this.queryGenerator.attributesToSQL(attributes, {\n      table: tableName,\n      context: \"createTable\",\n      withoutForeignKeyConstraints: options.withoutForeignKeyConstraints\n    });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async tableExists(tableName, options) {\n    const sql = this.queryGenerator.tableExistsQuery(tableName);\n    const out = await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.SHOWTABLES\n    }));\n    return out.length === 1;\n  }\n  async dropTable(tableName, options) {\n    options = __spreadValues({}, options);\n    options.cascade = options.cascade || options.force || false;\n    const sql = this.queryGenerator.dropTableQuery(tableName, options);\n    await this.sequelize.query(sql, options);\n  }\n  async _dropAllTables(tableNames, skip, options) {\n    for (const tableName of tableNames) {\n      if (!skip.includes(tableName.tableName || tableName)) {\n        await this.dropTable(tableName, __spreadProps(__spreadValues({}, options), {\n          cascade: true\n        }));\n      }\n    }\n  }\n  async dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n    const tableNames = await this.showAllTables(options);\n    const foreignKeys = await this.getForeignKeysForTables(tableNames, options);\n    for (const tableName of tableNames) {\n      let normalizedTableName = tableName;\n      if (_.isObject(tableName)) {\n        normalizedTableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n      for (const foreignKey of foreignKeys[normalizedTableName]) {\n        await this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, foreignKey));\n      }\n    }\n    await this._dropAllTables(tableNames, skip, options);\n  }\n  async renameTable(before, after, options) {\n    options = options || {};\n    const sql = this.queryGenerator.renameTableQuery(before, after);\n    return await this.sequelize.query(sql, options);\n  }\n  async showAllTables(options) {\n    options = __spreadProps(__spreadValues({}, options), {\n      raw: true,\n      type: QueryTypes.SHOWTABLES\n    });\n    const showTablesSql = this.queryGenerator.showTablesQuery(this.sequelize.config.database);\n    const tableNames = await this.sequelize.query(showTablesSql, options);\n    return _.flatten(tableNames);\n  }\n  async describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n    if (typeof options === \"string\") {\n      schema = options;\n    } else if (typeof options === \"object\" && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n    if (typeof tableName === \"object\" && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.DESCRIBE\n    });\n    try {\n      const data = await this.sequelize.query(sql, options);\n      if (_.isEmpty(data)) {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n      return data;\n    } catch (e) {\n      if (e.original && e.original.code === \"ER_NO_SUCH_TABLE\") {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n      throw e;\n    }\n  }\n  async addColumn(table, key, attribute, options) {\n    if (!table || !key || !attribute) {\n      throw new Error(\"addColumn takes at least 3 arguments (table, attribute name, attribute definition)\");\n    }\n    options = options || {};\n    attribute = this.sequelize.normalizeAttribute(attribute);\n    return await this.sequelize.query(this.queryGenerator.addColumnQuery(table, key, attribute), options);\n  }\n  async removeColumn(tableName, attributeName, options) {\n    return this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, attributeName), options);\n  }\n  normalizeAttribute(dataTypeOrOptions) {\n    let attribute;\n    if (Object.values(DataTypes).includes(dataTypeOrOptions)) {\n      attribute = {\n        type: dataTypeOrOptions,\n        allowNull: true\n      };\n    } else {\n      attribute = dataTypeOrOptions;\n    }\n    return this.sequelize.normalizeAttribute(attribute);\n  }\n  quoteIdentifier(identifier2, force) {\n    return this.queryGenerator.quoteIdentifier(identifier2, force);\n  }\n  quoteIdentifiers(identifiers) {\n    return this.queryGenerator.quoteIdentifiers(identifiers);\n  }\n  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    options = options || {};\n    const query = this.queryGenerator.attributesToSQL({\n      [attributeName]: this.normalizeAttribute(dataTypeOrOptions)\n    }, {\n      context: \"changeColumn\",\n      table: tableName\n    });\n    const sql = this.queryGenerator.changeColumnQuery(tableName, query);\n    return this.sequelize.query(sql, options);\n  }\n  async assertTableHasColumn(tableName, columnName, options) {\n    const description = await this.describeTable(tableName, options);\n    if (description[columnName]) {\n      return description;\n    }\n    throw new Error(`Table ${tableName} doesn't have the column ${columnName}`);\n  }\n  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    const data = (await this.assertTableHasColumn(tableName, attrNameBefore, options))[attrNameBefore];\n    const _options = {};\n    _options[attrNameAfter] = {\n      attribute: attrNameAfter,\n      type: data.type,\n      allowNull: data.allowNull,\n      defaultValue: data.defaultValue\n    };\n    if (data.defaultValue === null && !data.allowNull) {\n      delete _options[attrNameAfter].defaultValue;\n    }\n    const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, this.queryGenerator.attributesToSQL(_options));\n    return await this.sequelize.query(sql, options);\n  }\n  async addIndex(tableName, attributes, options, rawTablename) {\n    if (!Array.isArray(attributes)) {\n      rawTablename = options;\n      options = attributes;\n      attributes = options.fields;\n    }\n    if (!rawTablename) {\n      rawTablename = tableName;\n    }\n    options = Utils.cloneDeep(options);\n    options.fields = attributes;\n    const sql = this.queryGenerator.addIndexQuery(tableName, options, rawTablename);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      supportsSearchPath: false\n    }));\n  }\n  async showIndex(tableName, options) {\n    const sql = this.queryGenerator.showIndexesQuery(tableName, options);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.SHOWINDEXES\n    }));\n  }\n  async getForeignKeysForTables(tableNames, options) {\n    if (tableNames.length === 0) {\n      return {};\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n    const results = await Promise.all(tableNames.map(tableName => this.sequelize.query(this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database), options)));\n    const result = {};\n    tableNames.forEach((tableName, i) => {\n      if (_.isObject(tableName)) {\n        tableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n      result[tableName] = Array.isArray(results[i]) ? results[i].map(r => r.constraint_name) : [results[i] && results[i].constraint_name];\n      result[tableName] = result[tableName].filter(_.identity);\n    });\n    return result;\n  }\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database);\n    return this.sequelize.query(query, queryOptions);\n  }\n  async removeIndex(tableName, indexNameOrAttributes, options) {\n    options = options || {};\n    const sql = this.queryGenerator.removeIndexQuery(tableName, indexNameOrAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async addConstraint(tableName, options) {\n    if (!options.fields) {\n      throw new Error(\"Fields must be specified through options.fields\");\n    }\n    if (!options.type) {\n      throw new Error(\"Constraint type must be specified through options.type\");\n    }\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.addConstraintQuery(tableName, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async showConstraint(tableName, constraintName, options) {\n    const sql = this.queryGenerator.showConstraintsQuery(tableName, constraintName);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.SHOWCONSTRAINTS\n    }));\n  }\n  async removeConstraint(tableName, constraintName, options) {\n    return this.sequelize.query(this.queryGenerator.removeConstraintQuery(tableName, constraintName), options);\n  }\n  async insert(instance, tableName, values, options) {\n    options = Utils.cloneDeep(options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.queryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);\n    options.type = QueryTypes.INSERT;\n    options.instance = instance;\n    const results = await this.sequelize.query(sql, options);\n    if (instance) results[0].isNewRecord = false;\n    return results;\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = options.conflictFields || [];\n    if (options.upsertKeys.length === 0) {\n      const primaryKeys = Object.values(model.primaryKeys).map(item => item.field);\n      const uniqueKeys = Object.values(model.uniqueKeys).filter(c => c.fields.length > 0).map(c => c.fields);\n      const indexKeys = Object.values(model._indexes).filter(c => c.unique && c.fields.length > 0).map(c => c.fields);\n      for (const field of options.updateOnDuplicate) {\n        const uniqueKey = uniqueKeys.find(fields => fields.includes(field));\n        if (uniqueKey) {\n          options.upsertKeys = uniqueKey;\n          break;\n        }\n        const indexKey = indexKeys.find(fields => fields.includes(field));\n        if (indexKey) {\n          options.upsertKeys = indexKey;\n          break;\n        }\n      }\n      if (options.upsertKeys.length === 0 || _.intersection(options.updateOnDuplicate, primaryKeys).length) {\n        options.upsertKeys = primaryKeys;\n      }\n      options.upsertKeys = _.uniq(options.upsertKeys);\n    }\n    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async bulkInsert(tableName, records, options, attributes) {\n    options = __spreadValues({}, options);\n    options.type = QueryTypes.INSERT;\n    const results = await this.sequelize.query(this.queryGenerator.bulkInsertQuery(tableName, records, options, attributes), options);\n    return results[0];\n  }\n  async update(instance, tableName, values, identifier2, options) {\n    options = __spreadValues({}, options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier2, options, instance.constructor.rawAttributes);\n    options.type = QueryTypes.UPDATE;\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n  async bulkUpdate(tableName, values, identifier2, options, attributes) {\n    options = Utils.cloneDeep(options);\n    if (typeof identifier2 === \"object\") identifier2 = Utils.cloneDeep(identifier2);\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier2, options, attributes);\n    const table = _.isObject(tableName) ? tableName : {\n      tableName\n    };\n    const model = options.model ? options.model : _.find(this.sequelize.modelManager.models, {\n      tableName: table.tableName\n    });\n    options.type = QueryTypes.BULKUPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n  async delete(instance, tableName, identifier2, options) {\n    const cascades = [];\n    const sql = this.queryGenerator.deleteQuery(tableName, identifier2, {}, instance.constructor);\n    options = __spreadValues({}, options);\n    if (!!instance.constructor && !!instance.constructor.associations) {\n      const keys = Object.keys(instance.constructor.associations);\n      const length = keys.length;\n      let association;\n      for (let i = 0; i < length; i++) {\n        association = instance.constructor.associations[keys[i]];\n        if (association.options && association.options.onDelete && association.options.onDelete.toLowerCase() === \"cascade\" && association.options.useHooks === true) {\n          cascades.push(association.accessors.get);\n        }\n      }\n    }\n    for (const cascade of cascades) {\n      let instances = await instance[cascade](options);\n      if (!instances) continue;\n      if (!Array.isArray(instances)) instances = [instances];\n      for (const _instance of instances) await _instance.destroy(options);\n    }\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n  async bulkDelete(tableName, where, options, model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      limit: null\n    });\n    if (options.truncate === true) {\n      return this.sequelize.query(this.queryGenerator.truncateTableQuery(tableName, options), options);\n    }\n    if (typeof identifier === \"object\") where = Utils.cloneDeep(where);\n    return await this.sequelize.query(this.queryGenerator.deleteQuery(tableName, where, options, model), options);\n  }\n  async select(model, tableName, optionsArg) {\n    const options = __spreadProps(__spreadValues({}, optionsArg), {\n      type: QueryTypes.SELECT,\n      model\n    });\n    return await this.sequelize.query(this.queryGenerator.selectQuery(tableName, options, model), options);\n  }\n  async increment(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.arithmeticQuery(\"+\", tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n  async decrement(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.arithmeticQuery(\"-\", tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n  async rawSelect(tableName, options, attributeSelector, Model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      raw: true,\n      plain: true,\n      type: QueryTypes.SELECT\n    });\n    const sql = this.queryGenerator.selectQuery(tableName, options, Model);\n    if (attributeSelector === void 0) {\n      throw new Error(\"Please pass an attribute selector!\");\n    }\n    const data = await this.sequelize.query(sql, options);\n    if (!options.plain) {\n      return data;\n    }\n    const result = data ? data[attributeSelector] : null;\n    if (!options || !options.dataType) {\n      return result;\n    }\n    const dataType = options.dataType;\n    if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {\n      if (result !== null) {\n        return parseFloat(result);\n      }\n    }\n    if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {\n      if (result !== null) {\n        return parseInt(result, 10);\n      }\n    }\n    if (dataType instanceof DataTypes.DATE) {\n      if (result !== null && !(result instanceof Date)) {\n        return new Date(result);\n      }\n    }\n    return result;\n  }\n  async createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray, options) {\n    const sql = this.queryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async dropTrigger(tableName, triggerName, options) {\n    const sql = this.queryGenerator.dropTrigger(tableName, triggerName);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async renameTrigger(tableName, oldTriggerName, newTriggerName, options) {\n    const sql = this.queryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    const sql = this.queryGenerator.createFunction(functionName, params, returnType, language, body, optionsArray, options);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async dropFunction(functionName, params, options) {\n    const sql = this.queryGenerator.dropFunction(functionName, params);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async renameFunction(oldFunctionName, params, newFunctionName, options) {\n    const sql = this.queryGenerator.renameFunction(oldFunctionName, params, newFunctionName);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  ensureEnums() {}\n  async setIsolationLevel(transaction, value, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to set isolation level for a transaction without transaction object!\");\n    }\n    if (transaction.parent || !value) {\n      return;\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction\n    });\n    const sql = this.queryGenerator.setIsolationLevelQuery(value, {\n      parent: transaction.parent\n    });\n    if (!sql) return;\n    return await this.sequelize.query(sql, options);\n  }\n  async startTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to start a transaction without transaction object!\");\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction\n    });\n    options.transaction.name = transaction.parent ? transaction.name : void 0;\n    const sql = this.queryGenerator.startTransactionQuery(transaction);\n    return await this.sequelize.query(sql, options);\n  }\n  async deferConstraints(transaction, options) {\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction\n    });\n    const sql = this.queryGenerator.deferConstraintsQuery(options);\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async commitTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to commit a transaction without transaction object!\");\n    }\n    if (transaction.parent) {\n      return;\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    });\n    const sql = this.queryGenerator.commitTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n    transaction.finished = \"commit\";\n    return await promise;\n  }\n  async rollbackTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to rollback a transaction without transaction object!\");\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    });\n    options.transaction.name = transaction.parent ? transaction.name : void 0;\n    const sql = this.queryGenerator.rollbackTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n    transaction.finished = \"rollback\";\n    return await promise;\n  }\n}\nexports.QueryInterface = QueryInterface;","map":{"version":3,"names":["_","require","Utils","DataTypes","Transaction","QueryTypes","QueryInterface","constructor","sequelize","queryGenerator","createDatabase","database","options","sql","createDatabaseQuery","query","dropDatabase","dropDatabaseQuery","createSchema","schema","dropSchema","dropAllSchemas","_dialect","supports","schemas","drop","showAllSchemas","Promise","all","map","schemaName","__spreadProps","__spreadValues","raw","type","SELECT","showSchemasSql","showSchemasQuery","schemaNames","flatten","value","schema_name","databaseVersion","versionQuery","VERSION","createTable","tableName","attributes","model","uniqueKeys","forOwn","uniqueKey","customIndex","mapValues","attribute","normalizeAttribute","ensureEnums","_schema","addSchema","attributesToSQL","table","context","withoutForeignKeyConstraints","createTableQuery","tableExists","tableExistsQuery","out","SHOWTABLES","length","dropTable","cascade","force","dropTableQuery","_dropAllTables","tableNames","skip","includes","dropAllTables","showAllTables","foreignKeys","getForeignKeysForTables","normalizedTableName","isObject","foreignKey","dropForeignKeyQuery","renameTable","before","after","renameTableQuery","showTablesSql","showTablesQuery","config","describeTable","schemaDelimiter","describeTableQuery","DESCRIBE","data","isEmpty","Error","e","original","code","addColumn","key","addColumnQuery","removeColumn","attributeName","removeColumnQuery","dataTypeOrOptions","Object","values","allowNull","quoteIdentifier","identifier2","quoteIdentifiers","identifiers","changeColumn","changeColumnQuery","assertTableHasColumn","columnName","description","renameColumn","attrNameBefore","attrNameAfter","_options","defaultValue","renameColumnQuery","addIndex","rawTablename","Array","isArray","fields","cloneDeep","addIndexQuery","supportsSearchPath","showIndex","showIndexesQuery","SHOWINDEXES","FOREIGNKEYS","results","getForeignKeysQuery","result","forEach","i","r","constraint_name","filter","identity","getForeignKeyReferencesForTable","queryOptions","removeIndex","indexNameOrAttributes","removeIndexQuery","addConstraint","addConstraintQuery","showConstraint","constraintName","showConstraintsQuery","SHOWCONSTRAINTS","removeConstraint","removeConstraintQuery","insert","instance","hasTrigger","insertQuery","rawAttributes","INSERT","isNewRecord","upsert","insertValues","updateValues","where","UPSERT","updateOnDuplicate","keys","upsertKeys","conflictFields","primaryKeys","item","field","c","indexKeys","_indexes","unique","find","indexKey","intersection","uniq","bulkInsert","records","bulkInsertQuery","update","updateQuery","UPDATE","bulkUpdate","modelManager","models","BULKUPDATE","delete","cascades","deleteQuery","associations","association","onDelete","toLowerCase","useHooks","push","accessors","get","instances","_instance","destroy","bulkDelete","defaults","limit","truncate","truncateTableQuery","identifier","select","optionsArg","selectQuery","increment","incrementAmountsByField","extraAttributesToBeUpdated","arithmeticQuery","decrement","rawSelect","attributeSelector","Model","plain","dataType","DECIMAL","FLOAT","parseFloat","INTEGER","BIGINT","parseInt","DATE","Date","createTrigger","triggerName","timingType","fireOnArray","functionName","functionParams","optionsArray","dropTrigger","renameTrigger","oldTriggerName","newTriggerName","createFunction","params","returnType","language","body","dropFunction","renameFunction","oldFunctionName","newFunctionName","setIsolationLevel","transaction","parent","setIsolationLevelQuery","startTransaction","name","startTransactionQuery","deferConstraints","deferConstraintsQuery","commitTransaction","completesTransaction","commitTransactionQuery","promise","finished","rollbackTransaction","rollbackTransactionQuery","exports"],"sources":["C:\\Users\\teply\\OneDrive\\Рабочий стол\\web_project\\client\\node_modules\\sequelize\\src\\dialects\\abstract\\query-interface.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\n\nconst Utils = require('../../utils');\nconst DataTypes = require('../../data-types');\nconst Transaction = require('../../transaction');\nconst QueryTypes = require('../../query-types');\n\n/**\n * The interface that Sequelize uses to talk to all databases\n */\nclass QueryInterface {\n  constructor(sequelize, queryGenerator) {\n    this.sequelize = sequelize;\n    this.queryGenerator = queryGenerator;\n  }\n\n  /**\n   * Create a database\n   *\n   * @param {string} database  Database name to create\n   * @param {object} [options] Query options\n   * @param {string} [options.charset] Database default character set, MYSQL only\n   * @param {string} [options.collate] Database default collation\n   * @param {string} [options.encoding] Database default character set, PostgreSQL only\n   * @param {string} [options.ctype] Database character classification, PostgreSQL only\n   * @param {string} [options.template] The name of the template from which to create the new database, PostgreSQL only\n   *\n   * @returns {Promise}\n   */\n  async createDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createDatabaseQuery(database, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Drop a database\n   *\n   * @param {string} database  Database name to drop\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async dropDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropDatabaseQuery(database);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Create a schema\n   *\n   * @param {string} schema    Schema name to create\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async createSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Drop a schema\n   *\n   * @param {string} schema    Schema name to drop\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async dropSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Drop all schemas\n   *\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async dropAllSchemas(options) {\n    options = options || {};\n\n    if (!this.queryGenerator._dialect.supports.schemas) {\n      return this.sequelize.drop(options);\n    }\n    const schemas = await this.showAllSchemas(options);\n    return Promise.all(schemas.map(schemaName => this.dropSchema(schemaName, options)));\n  }\n\n  /**\n   * Show all schemas\n   *\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise<Array>}\n   */\n  async showAllSchemas(options) {\n    options = {\n      ...options,\n      raw: true,\n      type: this.sequelize.QueryTypes.SELECT\n    };\n\n    const showSchemasSql = this.queryGenerator.showSchemasQuery(options);\n\n    const schemaNames = await this.sequelize.query(showSchemasSql, options);\n\n    return _.flatten(schemaNames.map(value => value.schema_name ? value.schema_name : value));\n  }\n\n  /**\n   * Return database version\n   *\n   * @param {object}    [options]      Query options\n   * @param {QueryType} [options.type] Query type\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async databaseVersion(options) {\n    return await this.sequelize.query(\n      this.queryGenerator.versionQuery(),\n      { ...options, type: QueryTypes.VERSION }\n    );\n  }\n\n  /**\n   * Create a table with given set of attributes\n   *\n   * ```js\n   * queryInterface.createTable(\n   *   'nameOfTheNewTable',\n   *   {\n   *     id: {\n   *       type: Sequelize.INTEGER,\n   *       primaryKey: true,\n   *       autoIncrement: true\n   *     },\n   *     createdAt: {\n   *       type: Sequelize.DATE\n   *     },\n   *     updatedAt: {\n   *       type: Sequelize.DATE\n   *     },\n   *     attr1: Sequelize.STRING,\n   *     attr2: Sequelize.INTEGER,\n   *     attr3: {\n   *       type: Sequelize.BOOLEAN,\n   *       defaultValue: false,\n   *       allowNull: false\n   *     },\n   *     //foreign key usage\n   *     attr4: {\n   *       type: Sequelize.INTEGER,\n   *       references: {\n   *         model: 'another_table_name',\n   *         key: 'id'\n   *       },\n   *       onUpdate: 'cascade',\n   *       onDelete: 'cascade'\n   *     }\n   *   },\n   *   {\n   *     engine: 'MYISAM',    // default: 'InnoDB'\n   *     charset: 'latin1',   // default: null\n   *     schema: 'public',    // default: public, PostgreSQL only.\n   *     comment: 'my table', // comment for table\n   *     collate: 'latin1_danish_ci' // collation, MYSQL only\n   *   }\n   * )\n   * ```\n   *\n   * @param {string} tableName  Name of table to create\n   * @param {object} attributes Object representing a list of table attributes to create\n   * @param {object} [options] create table and query options\n   * @param {Model}  [model] model class\n   *\n   * @returns {Promise}\n   */\n  async createTable(tableName, attributes, options, model) {\n    let sql = '';\n\n    options = { ...options };\n\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, uniqueKey => {\n        if (uniqueKey.customIndex === undefined) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n\n    attributes = _.mapValues(\n      attributes,\n      attribute => this.sequelize.normalizeAttribute(attribute)\n    );\n\n    // Postgres requires special SQL commands for ENUM/ENUM[]\n    await this.ensureEnums(tableName, attributes, options, model);\n\n    if (\n      !tableName.schema &&\n      (options.schema || !!model && model._schema)\n    ) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n\n    attributes = this.queryGenerator.attributesToSQL(attributes, {\n      table: tableName,\n      context: 'createTable',\n      withoutForeignKeyConstraints: options.withoutForeignKeyConstraints\n    });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Returns a promise that will resolve to true if the table exists in the database, false otherwise.\n   *\n   * @param {TableName} tableName - The name of the table\n   * @param {QueryOptions} options - Query options\n   * @returns {Promise<boolean>}\n   */\n  async tableExists(tableName, options) {\n    const sql = this.queryGenerator.tableExistsQuery(tableName);\n\n    const out = await this.sequelize.query(sql, {\n      ...options,\n      type: QueryTypes.SHOWTABLES\n    });\n\n    return out.length === 1;\n  }\n\n  /**\n   * Drop a table from database\n   *\n   * @param {string} tableName Table name to drop\n   * @param {object} options   Query options\n   *\n   * @returns {Promise}\n   */\n  async dropTable(tableName, options) {\n    // if we're forcing we should be cascading unless explicitly stated otherwise\n    options = { ...options };\n    options.cascade = options.cascade || options.force || false;\n\n    const sql = this.queryGenerator.dropTableQuery(tableName, options);\n\n    await this.sequelize.query(sql, options);\n  }\n\n  async _dropAllTables(tableNames, skip, options) {\n    for (const tableName of tableNames) {\n      // if tableName is not in the Array of tables names then don't drop it\n      if (!skip.includes(tableName.tableName || tableName)) {\n        await this.dropTable(tableName, { ...options, cascade: true } );\n      }\n    }\n  }\n\n  /**\n   * Drop all tables from database\n   *\n   * @param {object} [options] query options\n   * @param {Array}  [options.skip] List of table to skip\n   *\n   * @returns {Promise}\n   */\n  async dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n\n    const tableNames = await this.showAllTables(options);\n    const foreignKeys = await this.getForeignKeysForTables(tableNames, options);\n\n    for (const tableName of tableNames) {\n      let normalizedTableName = tableName;\n      if (_.isObject(tableName)) {\n        normalizedTableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n\n      for (const foreignKey of foreignKeys[normalizedTableName]) {\n        await this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, foreignKey));\n      }\n    }\n    await this._dropAllTables(tableNames, skip, options);\n  }\n\n  /**\n   * Rename a table\n   *\n   * @param {string} before    Current name of table\n   * @param {string} after     New name from table\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async renameTable(before, after, options) {\n    options = options || {};\n    const sql = this.queryGenerator.renameTableQuery(before, after);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Get all tables in current database\n   *\n   * @param {object}    [options] Query options\n   * @param {boolean}   [options.raw=true] Run query in raw mode\n   * @param {QueryType} [options.type=QueryType.SHOWTABLE] query type\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async showAllTables(options) {\n    options = {\n      ...options,\n      raw: true,\n      type: QueryTypes.SHOWTABLES\n    };\n\n    const showTablesSql = this.queryGenerator.showTablesQuery(this.sequelize.config.database);\n    const tableNames = await this.sequelize.query(showTablesSql, options);\n    return _.flatten(tableNames);\n  }\n\n  /**\n   * Describe a table structure\n   *\n   * This method returns an array of hashes containing information about all attributes in the table.\n   *\n   * ```js\n   * {\n   *    name: {\n   *      type:         'VARCHAR(255)', // this will be 'CHARACTER VARYING' for pg!\n   *      allowNull:    true,\n   *      defaultValue: null\n   *    },\n   *    isBetaMember: {\n   *      type:         'TINYINT(1)', // this will be 'BOOLEAN' for pg!\n   *      allowNull:    false,\n   *      defaultValue: false\n   *    }\n   * }\n   * ```\n   *\n   * @param {string} tableName table name\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise<object>}\n   */\n  async describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n\n    if (typeof options === 'string') {\n      schema = options;\n    } else if (typeof options === 'object' && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n\n    if (typeof tableName === 'object' && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n\n    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = { ...options, type: QueryTypes.DESCRIBE };\n\n    try {\n      const data = await this.sequelize.query(sql, options);\n      /*\n       * If no data is returned from the query, then the table name may be wrong.\n       * Query generators that use information_schema for retrieving table info will just return an empty result set,\n       * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).\n       */\n      if (_.isEmpty(data)) {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n\n      return data;\n    } catch (e) {\n      if (e.original && e.original.code === 'ER_NO_SUCH_TABLE') {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n\n      throw e;\n    }\n  }\n\n  /**\n   * Add a new column to a table\n   *\n   * ```js\n   * queryInterface.addColumn('tableA', 'columnC', Sequelize.STRING, {\n   *    after: 'columnB' // after option is only supported by MySQL\n   * });\n   * ```\n   *\n   * @param {string} table     Table to add column to\n   * @param {string} key       Column name\n   * @param {object} attribute Attribute definition\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async addColumn(table, key, attribute, options) {\n    if (!table || !key || !attribute) {\n      throw new Error('addColumn takes at least 3 arguments (table, attribute name, attribute definition)');\n    }\n\n    options = options || {};\n    attribute = this.sequelize.normalizeAttribute(attribute);\n    return await this.sequelize.query(this.queryGenerator.addColumnQuery(table, key, attribute), options);\n  }\n\n  /**\n   * Remove a column from a table\n   *\n   * @param {string} tableName      Table to remove column from\n   * @param {string} attributeName  Column name to remove\n   * @param {object} [options]      Query options\n   */\n  async removeColumn(tableName, attributeName, options) {\n    return this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, attributeName), options);\n  }\n\n  normalizeAttribute(dataTypeOrOptions) {\n    let attribute;\n    if (Object.values(DataTypes).includes(dataTypeOrOptions)) {\n      attribute = { type: dataTypeOrOptions, allowNull: true };\n    } else {\n      attribute = dataTypeOrOptions;\n    }\n\n    return this.sequelize.normalizeAttribute(attribute);\n  }\n\n  /**\n   * Split a list of identifiers by \".\" and quote each part\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    return this.queryGenerator.quoteIdentifier(identifier, force);\n  }\n\n  /**\n   * Split a list of identifiers by \".\" and quote each part.\n   *\n   * @param {string} identifiers \n   * \n   * @returns {string}\n   */\n  quoteIdentifiers(identifiers) {\n    return this.queryGenerator.quoteIdentifiers(identifiers);\n  }\n\n  /**\n   * Change a column definition\n   *\n   * @param {string} tableName          Table name to change from\n   * @param {string} attributeName      Column name\n   * @param {object} dataTypeOrOptions  Attribute definition for new column\n   * @param {object} [options]          Query options\n   */\n  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    options = options || {};\n\n    const query = this.queryGenerator.attributesToSQL({\n      [attributeName]: this.normalizeAttribute(dataTypeOrOptions)\n    }, {\n      context: 'changeColumn',\n      table: tableName\n    });\n    const sql = this.queryGenerator.changeColumnQuery(tableName, query);\n\n    return this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Rejects if the table doesn't have the specified column, otherwise returns the column description.\n   *\n   * @param {string} tableName\n   * @param {string} columnName\n   * @param {object} options\n   * @private\n   */\n  async assertTableHasColumn(tableName, columnName, options) {\n    const description = await this.describeTable(tableName, options);\n    if (description[columnName]) {\n      return description;\n    }\n    throw new Error(`Table ${tableName} doesn't have the column ${columnName}`);\n  }\n\n  /**\n   * Rename a column\n   *\n   * @param {string} tableName        Table name whose column to rename\n   * @param {string} attrNameBefore   Current column name\n   * @param {string} attrNameAfter    New column name\n   * @param {object} [options]        Query option\n   *\n   * @returns {Promise}\n   */\n  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    const data = (await this.assertTableHasColumn(tableName, attrNameBefore, options))[attrNameBefore];\n\n    const _options = {};\n\n    _options[attrNameAfter] = {\n      attribute: attrNameAfter,\n      type: data.type,\n      allowNull: data.allowNull,\n      defaultValue: data.defaultValue\n    };\n\n    // fix: a not-null column cannot have null as default value\n    if (data.defaultValue === null && !data.allowNull) {\n      delete _options[attrNameAfter].defaultValue;\n    }\n\n    const sql = this.queryGenerator.renameColumnQuery(\n      tableName,\n      attrNameBefore,\n      this.queryGenerator.attributesToSQL(_options)\n    );\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Add an index to a column\n   *\n   * @param {string|object}  tableName Table name to add index on, can be a object with schema\n   * @param {Array}   [attributes]     Use options.fields instead, List of attributes to add index on\n   * @param {object}  options          indexes options\n   * @param {Array}   options.fields   List of attributes to add index on\n   * @param {boolean} [options.concurrently] Pass CONCURRENT so other operations run while the index is created\n   * @param {boolean} [options.unique] Create a unique index\n   * @param {string}  [options.using]  Useful for GIN indexes\n   * @param {string}  [options.operator] Index operator\n   * @param {string}  [options.type]   Type of index, available options are UNIQUE|FULLTEXT|SPATIAL\n   * @param {string}  [options.name]   Name of the index. Default is <table>_<attr1>_<attr2>\n   * @param {object}  [options.where]  Where condition on index, for partial indexes\n   * @param {string}  [rawTablename]   table name, this is just for backward compatibiity\n   *\n   * @returns {Promise}\n   */\n  async addIndex(tableName, attributes, options, rawTablename) {\n    // Support for passing tableName, attributes, options or tableName, options (with a fields param which is the attributes)\n    if (!Array.isArray(attributes)) {\n      rawTablename = options;\n      options = attributes;\n      attributes = options.fields;\n    }\n\n    if (!rawTablename) {\n      // Map for backwards compat\n      rawTablename = tableName;\n    }\n\n    options = Utils.cloneDeep(options);\n    options.fields = attributes;\n    const sql = this.queryGenerator.addIndexQuery(tableName, options, rawTablename);\n    return await this.sequelize.query(sql, { ...options, supportsSearchPath: false });\n  }\n\n  /**\n   * Show indexes on a table\n   *\n   * @param {string} tableName table name\n   * @param {object} [options]   Query options\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async showIndex(tableName, options) {\n    const sql = this.queryGenerator.showIndexesQuery(tableName, options);\n    return await this.sequelize.query(sql, { ...options, type: QueryTypes.SHOWINDEXES });\n  }\n\n\n  /**\n   * Returns all foreign key constraints of requested tables\n   *\n   * @param {string[]} tableNames table names\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async getForeignKeysForTables(tableNames, options) {\n    if (tableNames.length === 0) {\n      return {};\n    }\n\n    options = { ...options, type: QueryTypes.FOREIGNKEYS };\n\n    const results = await Promise.all(tableNames.map(tableName =>\n      this.sequelize.query(this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database), options)));\n\n    const result = {};\n\n    tableNames.forEach((tableName, i) => {\n      if (_.isObject(tableName)) {\n        tableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n\n      result[tableName] = Array.isArray(results[i])\n        ? results[i].map(r => r.constraint_name)\n        : [results[i] && results[i].constraint_name];\n\n      result[tableName] = result[tableName].filter(_.identity);\n    });\n\n    return result;\n  }\n\n  /**\n   * Get foreign key references details for the table\n   *\n   * Those details contains constraintSchema, constraintName, constraintCatalog\n   * tableCatalog, tableSchema, tableName, columnName,\n   * referencedTableCatalog, referencedTableCatalog, referencedTableSchema, referencedTableName, referencedColumnName.\n   * Remind: constraint informations won't return if it's sqlite.\n   *\n   * @param {string} tableName table name\n   * @param {object} [options]  Query options\n   */\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = {\n      ...options,\n      type: QueryTypes.FOREIGNKEYS\n    };\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database);\n    return this.sequelize.query(query, queryOptions);\n  }\n\n  /**\n   * Remove an already existing index from a table\n   *\n   * @param {string} tableName                    Table name to drop index from\n   * @param {string|string[]} indexNameOrAttributes  Index name or list of attributes that in the index\n   * @param {object} [options]                    Query options\n   * @param {boolean} [options.concurrently]      Pass CONCURRENTLY so other operations run while the index is created\n   *\n   * @returns {Promise}\n   */\n  async removeIndex(tableName, indexNameOrAttributes, options) {\n    options = options || {};\n    const sql = this.queryGenerator.removeIndexQuery(tableName, indexNameOrAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Add a constraint to a table\n   *\n   * Available constraints:\n   * - UNIQUE\n   * - DEFAULT (MSSQL only)\n   * - CHECK (MySQL - Ignored by the database engine )\n   * - FOREIGN KEY\n   * - PRIMARY KEY\n   *\n   * @example <caption>UNIQUE</caption>\n   * queryInterface.addConstraint('Users', {\n   *   fields: ['email'],\n   *   type: 'unique',\n   *   name: 'custom_unique_constraint_name'\n   * });\n   *\n   * @example <caption>CHECK</caption>\n   * queryInterface.addConstraint('Users', {\n   *   fields: ['roles'],\n   *   type: 'check',\n   *   where: {\n   *      roles: ['user', 'admin', 'moderator', 'guest']\n   *   }\n   * });\n   *\n   * @example <caption>Default - MSSQL only</caption>\n   * queryInterface.addConstraint('Users', {\n   *    fields: ['roles'],\n   *    type: 'default',\n   *    defaultValue: 'guest'\n   * });\n   *\n   * @example <caption>Primary Key</caption>\n   * queryInterface.addConstraint('Users', {\n   *    fields: ['username'],\n   *    type: 'primary key',\n   *    name: 'custom_primary_constraint_name'\n   * });\n   *\n   * @example <caption>Foreign Key</caption>\n   * queryInterface.addConstraint('Posts', {\n   *   fields: ['username'],\n   *   type: 'foreign key',\n   *   name: 'custom_fkey_constraint_name',\n   *   references: { //Required field\n   *     table: 'target_table_name',\n   *     field: 'target_column_name'\n   *   },\n   *   onDelete: 'cascade',\n   *   onUpdate: 'cascade'\n   * });\n   *\n   * @example <caption>Composite Foreign Key</caption>\n   * queryInterface.addConstraint('TableName', {\n   *   fields: ['source_column_name', 'other_source_column_name'],\n   *   type: 'foreign key',\n   *   name: 'custom_fkey_constraint_name',\n   *   references: { //Required field\n   *     table: 'target_table_name',\n   *     fields: ['target_column_name', 'other_target_column_name']\n   *   },\n   *   onDelete: 'cascade',\n   *   onUpdate: 'cascade'\n   * });\n   *\n   * @param {string} tableName                   Table name where you want to add a constraint\n   * @param {object} options                     An object to define the constraint name, type etc\n   * @param {string} options.type                Type of constraint. One of the values in available constraints(case insensitive)\n   * @param {Array}  options.fields              Array of column names to apply the constraint over\n   * @param {string} [options.name]              Name of the constraint. If not specified, sequelize automatically creates a named constraint based on constraint type, table & column names\n   * @param {string} [options.defaultValue]      The value for the default constraint\n   * @param {object} [options.where]             Where clause/expression for the CHECK constraint\n   * @param {object} [options.references]        Object specifying target table, column name to create foreign key constraint\n   * @param {string} [options.references.table]  Target table name\n   * @param {string} [options.references.field]  Target column name\n   * @param {string} [options.references.fields] Target column names for a composite primary key. Must match the order of fields in options.fields.\n   * @param {string} [options.deferrable]        Sets the constraint to be deferred or immediately checked. See Sequelize.Deferrable. PostgreSQL Only\n   *\n   * @returns {Promise}\n   */\n  async addConstraint(tableName, options) {\n    if (!options.fields) {\n      throw new Error('Fields must be specified through options.fields');\n    }\n\n    if (!options.type) {\n      throw new Error('Constraint type must be specified through options.type');\n    }\n\n    options = Utils.cloneDeep(options);\n\n    const sql = this.queryGenerator.addConstraintQuery(tableName, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n  async showConstraint(tableName, constraintName, options) {\n    const sql = this.queryGenerator.showConstraintsQuery(tableName, constraintName);\n    return await this.sequelize.query(sql, { ...options, type: QueryTypes.SHOWCONSTRAINTS });\n  }\n\n  /**\n   * Remove a constraint from a table\n   *\n   * @param {string} tableName       Table name to drop constraint from\n   * @param {string} constraintName  Constraint name\n   * @param {object} options         Query options\n   */\n  async removeConstraint(tableName, constraintName, options) {\n    return this.sequelize.query(this.queryGenerator.removeConstraintQuery(tableName, constraintName), options);\n  }\n\n  async insert(instance, tableName, values, options) {\n    options = Utils.cloneDeep(options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.queryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);\n\n    options.type = QueryTypes.INSERT;\n    options.instance = instance;\n\n    const results = await this.sequelize.query(sql, options);\n    if (instance) results[0].isNewRecord = false;\n\n    return results;\n  }\n\n  /**\n   * Upsert\n   *\n   * @param {string} tableName    table to upsert on\n   * @param {object} insertValues values to be inserted, mapped to field name\n   * @param {object} updateValues values to be updated, mapped to field name\n   * @param {object} where        where conditions, which can be used for UPDATE part when INSERT fails\n   * @param {object} options      query options\n   *\n   * @returns {Promise<boolean,?number>} Resolves an array with <created, primaryKey>\n   */\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = { ...options };\n\n    const model = options.model;\n\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = options.conflictFields || [];\n\n    if (options.upsertKeys.length === 0) {\n      const primaryKeys = Object.values(model.primaryKeys).map(item => item.field);\n      const uniqueKeys = Object.values(model.uniqueKeys).filter(c => c.fields.length > 0).map(c => c.fields);\n      const indexKeys = Object.values(model._indexes).filter(c => c.unique && c.fields.length > 0).map(c => c.fields);\n      // For fields in updateValues, try to find a constraint or unique index\n      // that includes given field. Only first matching upsert key is used.\n      for (const field of options.updateOnDuplicate) {\n        const uniqueKey = uniqueKeys.find(fields => fields.includes(field));\n        if (uniqueKey) {\n          options.upsertKeys = uniqueKey;\n          break;\n        }\n\n        const indexKey = indexKeys.find(fields => fields.includes(field));\n        if (indexKey) {\n          options.upsertKeys = indexKey;\n          break;\n        }\n      }\n\n      // Always use PK, if no constraint available OR update data contains PK\n      if (\n        options.upsertKeys.length === 0\n        || _.intersection(options.updateOnDuplicate, primaryKeys).length\n      ) {\n        options.upsertKeys = primaryKeys;\n      }\n\n      options.upsertKeys = _.uniq(options.upsertKeys);\n    }\n\n    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Insert multiple records into a table\n   *\n   * @example\n   * queryInterface.bulkInsert('roles', [{\n   *    label: 'user',\n   *    createdAt: new Date(),\n   *    updatedAt: new Date()\n   *  }, {\n   *    label: 'admin',\n   *    createdAt: new Date(),\n   *    updatedAt: new Date()\n   *  }]);\n   *\n   * @param {string} tableName   Table name to insert record to\n   * @param {Array}  records     List of records to insert\n   * @param {object} options     Various options, please see Model.bulkCreate options\n   * @param {object} attributes  Various attributes mapped by field name\n   *\n   * @returns {Promise}\n   */\n  async bulkInsert(tableName, records, options, attributes) {\n    options = { ...options };\n    options.type = QueryTypes.INSERT;\n\n    const results = await this.sequelize.query(\n      this.queryGenerator.bulkInsertQuery(tableName, records, options, attributes),\n      options\n    );\n\n    return results[0];\n  }\n\n  async update(instance, tableName, values, identifier, options) {\n    options = { ...options };\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier, options, instance.constructor.rawAttributes);\n\n    options.type = QueryTypes.UPDATE;\n\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Update multiple records of a table\n   *\n   * @example\n   * queryInterface.bulkUpdate('roles', {\n   *     label: 'admin',\n   *   }, {\n   *     userType: 3,\n   *   },\n   * );\n   *\n   * @param {string} tableName     Table name to update\n   * @param {object} values        Values to be inserted, mapped to field name\n   * @param {object} identifier    A hash with conditions OR an ID as integer OR a string with conditions\n   * @param {object} [options]     Various options, please see Model.bulkCreate options\n   * @param {object} [attributes]  Attributes on return objects if supported by SQL dialect\n   *\n   * @returns {Promise}\n   */\n  async bulkUpdate(tableName, values, identifier, options, attributes) {\n    options = Utils.cloneDeep(options);\n    if (typeof identifier === 'object') identifier = Utils.cloneDeep(identifier);\n\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier, options, attributes);\n    const table = _.isObject(tableName) ? tableName : { tableName };\n    const model = options.model ? options.model : _.find(this.sequelize.modelManager.models, { tableName: table.tableName });\n\n    options.type = QueryTypes.BULKUPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n\n  async delete(instance, tableName, identifier, options) {\n    const cascades = [];\n    const sql = this.queryGenerator.deleteQuery(tableName, identifier, {}, instance.constructor);\n\n    options = { ...options };\n\n    // Check for a restrict field\n    if (!!instance.constructor && !!instance.constructor.associations) {\n      const keys = Object.keys(instance.constructor.associations);\n      const length = keys.length;\n      let association;\n\n      for (let i = 0; i < length; i++) {\n        association = instance.constructor.associations[keys[i]];\n        if (association.options && association.options.onDelete &&\n          association.options.onDelete.toLowerCase() === 'cascade' &&\n          association.options.useHooks === true) {\n          cascades.push(association.accessors.get);\n        }\n      }\n    }\n\n    for (const cascade of cascades) {\n      let instances = await instance[cascade](options);\n      // Check for hasOne relationship with non-existing associate (\"has zero\")\n      if (!instances) continue;\n      if (!Array.isArray(instances)) instances = [instances];\n      for (const _instance of instances) await _instance.destroy(options);\n    }\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Delete multiple records from a table\n   *\n   * @param {string}  tableName            table name from where to delete records\n   * @param {object}  where                where conditions to find records to delete\n   * @param {object}  [options]            options\n   * @param {boolean} [options.truncate]   Use truncate table command\n   * @param {boolean} [options.cascade=false]         Only used in conjunction with TRUNCATE. Truncates  all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.\n   * @param {boolean} [options.restartIdentity=false] Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table.\n   * @param {Model}   [model]              Model\n   *\n   * @returns {Promise}\n   */\n  async bulkDelete(tableName, where, options, model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, { limit: null });\n\n    if (options.truncate === true) {\n      return this.sequelize.query(\n        this.queryGenerator.truncateTableQuery(tableName, options),\n        options\n      );\n    }\n\n    if (typeof identifier === 'object') where = Utils.cloneDeep(where);\n\n    return await this.sequelize.query(\n      this.queryGenerator.deleteQuery(tableName, where, options, model),\n      options\n    );\n  }\n\n  async select(model, tableName, optionsArg) {\n    const options = { ...optionsArg, type: QueryTypes.SELECT, model };\n\n    return await this.sequelize.query(\n      this.queryGenerator.selectQuery(tableName, options, model),\n      options\n    );\n  }\n\n  async increment(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n\n    const sql = this.queryGenerator.arithmeticQuery('+', tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n\n    return await this.sequelize.query(sql, options);\n  }\n\n  async decrement(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n\n    const sql = this.queryGenerator.arithmeticQuery('-', tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n\n    return await this.sequelize.query(sql, options);\n  }\n\n  async rawSelect(tableName, options, attributeSelector, Model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      raw: true,\n      plain: true,\n      type: QueryTypes.SELECT\n    });\n\n    const sql = this.queryGenerator.selectQuery(tableName, options, Model);\n\n    if (attributeSelector === undefined) {\n      throw new Error('Please pass an attribute selector!');\n    }\n\n    const data = await this.sequelize.query(sql, options);\n    if (!options.plain) {\n      return data;\n    }\n\n    const result = data ? data[attributeSelector] : null;\n\n    if (!options || !options.dataType) {\n      return result;\n    }\n\n    const dataType = options.dataType;\n\n    if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {\n      if (result !== null) {\n        return parseFloat(result);\n      }\n    }\n    if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {\n      if (result !== null) {\n        return parseInt(result, 10);\n      }\n    }\n    if (dataType instanceof DataTypes.DATE) {\n      if (result !== null && !(result instanceof Date)) {\n        return new Date(result);\n      }\n    }\n    return result;\n  }\n\n  async createTrigger(\n    tableName,\n    triggerName,\n    timingType,\n    fireOnArray,\n    functionName,\n    functionParams,\n    optionsArray,\n    options\n  ) {\n    const sql = this.queryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  async dropTrigger(tableName, triggerName, options) {\n    const sql = this.queryGenerator.dropTrigger(tableName, triggerName);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  async renameTrigger(tableName, oldTriggerName, newTriggerName, options) {\n    const sql = this.queryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  /**\n   * Create an SQL function\n   *\n   * @example\n   * queryInterface.createFunction(\n   *   'someFunction',\n   *   [\n   *     {type: 'integer', name: 'param', direction: 'IN'}\n   *   ],\n   *   'integer',\n   *   'plpgsql',\n   *   'RETURN param + 1;',\n   *   [\n   *     'IMMUTABLE',\n   *     'LEAKPROOF'\n   *   ],\n   *   {\n   *    variables:\n   *      [\n   *        {type: 'integer', name: 'myVar', default: 100}\n   *      ],\n   *      force: true\n   *   };\n   * );\n   *\n   * @param {string}  functionName  Name of SQL function to create\n   * @param {Array}   params        List of parameters declared for SQL function\n   * @param {string}  returnType    SQL type of function returned value\n   * @param {string}  language      The name of the language that the function is implemented in\n   * @param {string}  body          Source code of function\n   * @param {Array}   optionsArray  Extra-options for creation\n   * @param {object}  [options]     query options\n   * @param {boolean} options.force If force is true, any existing functions with the same parameters will be replaced. For postgres, this means using `CREATE OR REPLACE FUNCTION` instead of `CREATE FUNCTION`. Default is false\n   * @param {Array<object>}   options.variables List of declared variables. Each variable should be an object with string fields `type` and `name`, and optionally having a `default` field as well.\n   *\n   * @returns {Promise}\n   */\n  async createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    const sql = this.queryGenerator.createFunction(functionName, params, returnType, language, body, optionsArray, options);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  /**\n   * Drop an SQL function\n   *\n   * @example\n   * queryInterface.dropFunction(\n   *   'someFunction',\n   *   [\n   *     {type: 'varchar', name: 'param1', direction: 'IN'},\n   *     {type: 'integer', name: 'param2', direction: 'INOUT'}\n   *   ]\n   * );\n   *\n   * @param {string} functionName Name of SQL function to drop\n   * @param {Array}  params       List of parameters declared for SQL function\n   * @param {object} [options]    query options\n   *\n   * @returns {Promise}\n   */\n  async dropFunction(functionName, params, options) {\n    const sql = this.queryGenerator.dropFunction(functionName, params);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  /**\n   * Rename an SQL function\n   *\n   * @example\n   * queryInterface.renameFunction(\n   *   'fooFunction',\n   *   [\n   *     {type: 'varchar', name: 'param1', direction: 'IN'},\n   *     {type: 'integer', name: 'param2', direction: 'INOUT'}\n   *   ],\n   *   'barFunction'\n   * );\n   *\n   * @param {string} oldFunctionName  Current name of function\n   * @param {Array}  params           List of parameters declared for SQL function\n   * @param {string} newFunctionName  New name of function\n   * @param {object} [options]        query options\n   *\n   * @returns {Promise}\n   */\n  async renameFunction(oldFunctionName, params, newFunctionName, options) {\n    const sql = this.queryGenerator.renameFunction(oldFunctionName, params, newFunctionName);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  // Helper methods useful for querying\n\n  /**\n   * @private\n   */\n  ensureEnums() {\n    // noop by default\n  }\n\n  async setIsolationLevel(transaction, value, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to set isolation level for a transaction without transaction object!');\n    }\n\n    if (transaction.parent || !value) {\n      // Not possible to set a separate isolation level for savepoints\n      return;\n    }\n\n    options = { ...options, transaction: transaction.parent || transaction };\n\n    const sql = this.queryGenerator.setIsolationLevelQuery(value, {\n      parent: transaction.parent\n    });\n\n    if (!sql) return;\n\n    return await this.sequelize.query(sql, options);\n  }\n\n  async startTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to start a transaction without transaction object!');\n    }\n\n    options = { ...options, transaction: transaction.parent || transaction };\n    options.transaction.name = transaction.parent ? transaction.name : undefined;\n    const sql = this.queryGenerator.startTransactionQuery(transaction);\n\n    return await this.sequelize.query(sql, options);\n  }\n\n  async deferConstraints(transaction, options) {\n    options = { ...options, transaction: transaction.parent || transaction };\n\n    const sql = this.queryGenerator.deferConstraintsQuery(options);\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  async commitTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to commit a transaction without transaction object!');\n    }\n    if (transaction.parent) {\n      // Savepoints cannot be committed\n      return;\n    }\n\n    options = {\n      ...options,\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    };\n\n    const sql = this.queryGenerator.commitTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n\n    transaction.finished = 'commit';\n\n    return await promise;\n  }\n\n  async rollbackTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to rollback a transaction without transaction object!');\n    }\n\n    options = {\n      ...options,\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    };\n    options.transaction.name = transaction.parent ? transaction.name : undefined;\n    const sql = this.queryGenerator.rollbackTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n\n    transaction.finished = 'rollback';\n\n    return await promise;\n  }\n}\n\nexports.QueryInterface = QueryInterface;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}