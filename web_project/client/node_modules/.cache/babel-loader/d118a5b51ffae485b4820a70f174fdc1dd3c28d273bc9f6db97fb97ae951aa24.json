{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = require(\"lodash\");\nconst Utils = require(\"../../utils\");\nconst AbstractQueryGenerator = require(\"../abstract/query-generator\");\nconst util = require(\"util\");\nconst Op = require(\"../../operators\");\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst FOREIGN_KEY_FIELDS = [\"CONSTRAINT_NAME as constraint_name\", \"CONSTRAINT_NAME as constraintName\", \"CONSTRAINT_SCHEMA as constraintSchema\", \"CONSTRAINT_SCHEMA as constraintCatalog\", \"TABLE_NAME as tableName\", \"TABLE_SCHEMA as tableSchema\", \"TABLE_SCHEMA as tableCatalog\", \"COLUMN_NAME as columnName\", \"REFERENCED_TABLE_SCHEMA as referencedTableSchema\", \"REFERENCED_TABLE_SCHEMA as referencedTableCatalog\", \"REFERENCED_TABLE_NAME as referencedTableName\", \"REFERENCED_COLUMN_NAME as referencedColumnName\"].join(\",\");\nconst SNOWFLAKE_RESERVED_WORDS = \"account,all,alter,and,any,as,between,by,case,cast,check,column,connect,connections,constraint,create,cross,current,current_date,current_time,current_timestamp,current_user,database,delete,distinct,drop,else,exists,false,following,for,from,full,grant,group,gscluster,having,ilike,in,increment,inner,insert,intersect,into,is,issue,join,lateral,left,like,localtime,localtimestamp,minus,natural,not,null,of,on,or,order,organization,qualify,regexp,revoke,right,rlike,row,rows,sample,schema,select,set,some,start,table,tablesample,then,to,trigger,true,try_cast,union,unique,update,using,values,view,when,whenever,where,with\".split(\",\");\nconst typeWithoutDefault = /* @__PURE__ */new Set([\"BLOB\", \"TEXT\", \"GEOMETRY\", \"JSON\"]);\nclass SnowflakeQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n    this.OperatorMap = __spreadProps(__spreadValues({}, this.OperatorMap), {\n      [Op.regexp]: \"REGEXP\",\n      [Op.notRegexp]: \"NOT REGEXP\"\n    });\n  }\n  createDatabaseQuery(databaseName, options) {\n    options = __spreadValues({\n      charset: null,\n      collate: null\n    }, options);\n    return Utils.joinSQLFragments([\"CREATE DATABASE IF NOT EXISTS\", this.quoteIdentifier(databaseName), options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`, options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`, \";\"]);\n  }\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;\n  }\n  createSchema() {\n    return \"SHOW TABLES\";\n  }\n  showSchemasQuery() {\n    return \"SHOW TABLES\";\n  }\n  versionQuery() {\n    return \"SELECT CURRENT_VERSION()\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    options = __spreadValues({\n      charset: null,\n      rowFormat: null\n    }, options);\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      let match;\n      if (dataType.includes(\"PRIMARY KEY\")) {\n        primaryKeys.push(attr);\n        if (dataType.includes(\"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace(\"PRIMARY KEY\", \"\")}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace(\"PRIMARY KEY\", \"\")}`);\n        }\n      } else if (dataType.includes(\"REFERENCES\")) {\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(\", \");\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(\", \");\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== \"string\") {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n    return Utils.joinSQLFragments([\"CREATE TABLE IF NOT EXISTS\", table, `(${attributesClause})`, options.comment && typeof options.comment === \"string\" && `COMMENT ${this.escape(options.comment)}`, options.charset && `DEFAULT CHARSET=${options.charset}`, options.collate && `COLLATE ${options.collate}`, options.rowFormat && `ROW_FORMAT=${options.rowFormat}`, \";\"]);\n  }\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(this.addSchema({\n      tableName,\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter\n    }));\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n  showTablesQuery(database) {\n    return Utils.joinSQLFragments([\"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'\", database ? `AND TABLE_SCHEMA = ${this.escape(database)}` : \"AND TABLE_SCHEMA NOT IN ( 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA', 'SYS')\", \";\"]);\n  }\n  tableExistsQuery(table) {\n    const tableName = table.tableName || table;\n    const schema = table.schema;\n    return Utils.joinSQLFragments([\"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'\", `AND TABLE_SCHEMA = ${schema !== void 0 ? this.escape(schema) : \"CURRENT_SCHEMA()\"}`, `AND TABLE_NAME = ${this.escape(tableName)}`, \";\"]);\n  }\n  addColumnQuery(table, key, dataType) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(table), \"ADD\", this.quoteIdentifier(key), this.attributeToSQL(dataType, {\n      context: \"addColumn\",\n      tableName: table,\n      foreignKey: key\n    }), \";\"]);\n  }\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP\", this.quoteIdentifier(attributeName), \";\"]);\n  }\n  changeColumnQuery(tableName, attributes) {\n    const query = (...subQuerys) => Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"ALTER COLUMN\", ...subQuerys, \";\"]);\n    const sql = [];\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      const attrSql = [];\n      if (definition.includes(\"NOT NULL\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"SET NOT NULL\"));\n        definition = definition.replace(\"NOT NULL\", \"\").trim();\n      } else if (!definition.includes(\"REFERENCES\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"DROP NOT NULL\"));\n      }\n      if (definition.includes(\"DEFAULT\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"SET DEFAULT\", definition.match(/DEFAULT ([^;]+)/)[1]));\n        definition = definition.replace(/(DEFAULT[^;]+)/, \"\").trim();\n      } else if (!definition.includes(\"REFERENCES\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"DROP DEFAULT\"));\n      }\n      if (definition.match(/UNIQUE;*$/)) {\n        definition = definition.replace(/UNIQUE;*$/, \"\");\n        attrSql.push(query(\"ADD UNIQUE (\", this.quoteIdentifier(attributeName), \")\").replace(\"ALTER COLUMN\", \"\"));\n      }\n      if (definition.includes(\"REFERENCES\")) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, \"\");\n        attrSql.push(query(\"ADD FOREIGN KEY (\", this.quoteIdentifier(attributeName), \")\", definition).replace(\"ALTER COLUMN\", \"\"));\n      } else {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"TYPE\", definition));\n      }\n      sql.push(attrSql.join(\"\"));\n    }\n    return sql.join(\"\");\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`'${attrBefore}' '${attrName}' ${definition}`);\n    }\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"RENAME COLUMN\", attrString.join(\" to \"), \";\"]);\n  }\n  handleSequelizeMethod(attr, tableName, factory, options, prepend) {\n    if (attr instanceof Utils.Json) {\n      if (attr.conditions) {\n        const conditions = this.parseConditionObject(attr.conditions).map(condition => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n      if (attr.path) {\n        let str;\n        if (this._checkValidJsonStatement(attr.path)) {\n          str = attr.path;\n        } else {\n          const paths = _.toPath(attr.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n        if (attr.value) {\n          str += util.format(\" = %s\", this.escape(attr.value));\n        }\n        return str;\n      }\n    } else if (attr instanceof Utils.Cast) {\n      if (/timestamp/i.test(attr.type)) {\n        attr.type = \"datetime\";\n      } else if (attr.json && /boolean/i.test(attr.type)) {\n        attr.type = \"char\";\n      } else if (/double precision/i.test(attr.type) || /boolean/i.test(attr.type) || /integer/i.test(attr.type)) {\n        attr.type = \"decimal\";\n      } else if (/text/i.test(attr.type)) {\n        attr.type = \"char\";\n      }\n    }\n    return super.handleSequelizeMethod(attr, tableName, factory, options, prepend);\n  }\n  truncateTableQuery(tableName) {\n    return Utils.joinSQLFragments([\"TRUNCATE\", this.quoteTable(tableName)]);\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    const limit = options.limit && ` LIMIT ${this.escape(options.limit)}`;\n    let primaryKeys = \"\";\n    let primaryKeysSelection = \"\";\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n    if (limit) {\n      if (!model) {\n        throw new Error(\"Cannot LIMIT delete without a model.\");\n      }\n      const pks = Object.values(model.primaryKeys).map(pk => this.quoteIdentifier(pk.field)).join(\",\");\n      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;\n      primaryKeysSelection = pks;\n      return Utils.joinSQLFragments([\"DELETE FROM\", table, \"WHERE\", primaryKeys, \"IN (SELECT\", primaryKeysSelection, \"FROM\", table, whereClause, limit, \")\", \";\"]);\n    }\n    return Utils.joinSQLFragments([\"DELETE FROM\", table, whereClause, \";\"]);\n  }\n  showIndexesQuery() {\n    return \"SELECT '' FROM DUAL\";\n  }\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    return Utils.joinSQLFragments([\"SELECT CONSTRAINT_CATALOG AS constraintCatalog,\", \"CONSTRAINT_NAME AS constraintName,\", \"CONSTRAINT_SCHEMA AS constraintSchema,\", \"CONSTRAINT_TYPE AS constraintType,\", \"TABLE_NAME AS tableName,\", \"TABLE_SCHEMA AS tableSchema\", \"from INFORMATION_SCHEMA.TABLE_CONSTRAINTS\", `WHERE table_name='${tableName}'`, constraintName && `AND constraint_name = '${constraintName}'`, schemaName && `AND TABLE_SCHEMA = '${schemaName}'`, \";\"]);\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return Utils.joinSQLFragments([\"DROP INDEX\", this.quoteIdentifier(indexName), \"ON\", this.quoteTable(tableName), \";\"]);\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    const attributeString = attribute.type.toString({\n      escape: this.escape.bind(this)\n    });\n    let template = attributeString;\n    if (attribute.allowNull === false) {\n      template += \" NOT NULL\";\n    }\n    if (attribute.autoIncrement) {\n      template += \" AUTOINCREMENT\";\n    }\n    if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n    if (attribute.first) {\n      template += \" FIRST\";\n    }\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n    if (attribute.references) {\n      if (options && options.context === \"addColumn\" && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {};\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n    return result;\n  }\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n      break;\n    }\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n    return hasJsonFunction;\n  }\n  dataTypeMapping(tableName, attr, dataType) {\n    if (dataType.includes(\"PRIMARY KEY\")) {\n      dataType = dataType.replace(\"PRIMARY KEY\", \"\");\n    }\n    if (dataType.includes(\"SERIAL\")) {\n      if (dataType.includes(\"BIGINT\")) {\n        dataType = dataType.replace(\"SERIAL\", \"BIGSERIAL\");\n        dataType = dataType.replace(\"BIGINT\", \"\");\n      } else if (dataType.includes(\"SMALLINT\")) {\n        dataType = dataType.replace(\"SERIAL\", \"SMALLSERIAL\");\n        dataType = dataType.replace(\"SMALLINT\", \"\");\n      } else {\n        dataType = dataType.replace(\"INTEGER\", \"\");\n      }\n      dataType = dataType.replace(\"NOT NULL\", \"\");\n    }\n    return dataType;\n  }\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\"SELECT\", FOREIGN_KEY_FIELDS, `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`, `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`, \"AND REFERENCED_TABLE_NAME IS NOT NULL\", \";\"]);\n  }\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : \"\";\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n    return Utils.joinSQLFragments([\"SELECT\", FOREIGN_KEY_FIELDS, \"FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE\", \"WHERE (\", [`REFERENCED_TABLE_NAME = ${quotedTableName}`, table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`, `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`], \") OR (\", [`TABLE_NAME = ${quotedTableName}`, table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`, `AND COLUMN_NAME = ${quotedColumnName}`, \"AND REFERENCED_TABLE_NAME IS NOT NULL\"], \")\"]);\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP FOREIGN KEY\", this.quoteIdentifier(foreignKey), \";\"]);\n  }\n  addLimitAndOffset(options) {\n    let fragment = [];\n    if (options.offset !== null && options.offset !== void 0 && options.offset !== 0) {\n      fragment = fragment.concat([\" LIMIT \", this.escape(options.limit), \" OFFSET \", this.escape(options.offset)]);\n    } else if (options.limit !== null && options.limit !== void 0) {\n      fragment = [\" LIMIT \", this.escape(options.limit)];\n    }\n    return fragment.join(\"\");\n  }\n  quoteIdentifier(identifier, force) {\n    const optForceQuote = force || false;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n    if (optForceQuote === true || optQuoteIdentifiers !== false || identifier.includes(\".\") || identifier.includes(\"->\") || SNOWFLAKE_RESERVED_WORDS.includes(rawIdentifier.toLowerCase())) {\n      return Utils.addTicks(rawIdentifier, '\"');\n    }\n    return rawIdentifier;\n  }\n}\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, \"'\");\n}\nmodule.exports = SnowflakeQueryGenerator;","map":{"version":3,"names":["_","require","Utils","AbstractQueryGenerator","util","Op","JSON_FUNCTION_REGEX","JSON_OPERATOR_REGEX","TOKEN_CAPTURE_REGEX","FOREIGN_KEY_FIELDS","join","SNOWFLAKE_RESERVED_WORDS","split","typeWithoutDefault","Set","SnowflakeQueryGenerator","constructor","options","OperatorMap","__spreadProps","__spreadValues","regexp","notRegexp","createDatabaseQuery","databaseName","charset","collate","joinSQLFragments","quoteIdentifier","escape","dropDatabaseQuery","createSchema","showSchemasQuery","versionQuery","createTableQuery","tableName","attributes","rowFormat","primaryKeys","foreignKeys","attrStr","attr","Object","prototype","hasOwnProperty","call","dataType","match","includes","push","replace","table","quoteTable","attributesClause","pkString","map","pk","uniqueKeys","each","columns","indexName","customIndex","fields","field","length","fkey","comment","describeTableQuery","schema","schemaDelimiter","addSchema","_schema","_schemaDelimiter","showTablesQuery","database","tableExistsQuery","addColumnQuery","key","attributeToSQL","context","foreignKey","removeColumnQuery","attributeName","changeColumnQuery","query","subQuerys","sql","definition","dataTypeMapping","attrSql","trim","renameColumnQuery","attrBefore","attrString","attrName","handleSequelizeMethod","factory","prepend","Json","conditions","parseConditionObject","condition","jsonPathExtractionQuery","path","tail","value","str","_checkValidJsonStatement","paths","toPath","column","shift","format","Cast","test","type","json","truncateTableQuery","deleteQuery","where","model","whereClause","getWhereConditions","limit","primaryKeysSelection","Error","pks","values","primaryKeyAttributes","showIndexesQuery","showConstraintsQuery","constraintName","schemaName","removeIndexQuery","indexNameOrAttributes","underscore","attribute","isPlainObject","attributeString","toString","bind","template","allowNull","autoIncrement","has","_binary","defaultValueSchemable","defaultValue","unique","primaryKey","first","after","references","fkName","onDelete","toUpperCase","onUpdate","attributesToSQL","result","stmt","currentIndex","openingBrackets","closingBrackets","hasJsonFunction","hasInvalidToken","string","substr","functionMatches","exec","indexOf","operatorMatches","tokenMatches","capturedToken","getForeignKeysQuery","getForeignKeyQuery","columnName","quotedSchemaName","wrapSingleQuote","quotedTableName","quotedColumnName","dropForeignKeyQuery","addLimitAndOffset","fragment","offset","concat","identifier","force","optForceQuote","optQuoteIdentifiers","quoteIdentifiers","rawIdentifier","removeTicks","toLowerCase","addTicks","module","exports"],"sources":["C:\\Users\\teply\\OneDrive\\Рабочий стол\\web_project\\client\\node_modules\\sequelize\\src\\dialects\\snowflake\\query-generator.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst util = require('util');\nconst Op = require('../../operators');\n\n\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst FOREIGN_KEY_FIELDS = [\n  'CONSTRAINT_NAME as constraint_name',\n  'CONSTRAINT_NAME as constraintName',\n  'CONSTRAINT_SCHEMA as constraintSchema',\n  'CONSTRAINT_SCHEMA as constraintCatalog',\n  'TABLE_NAME as tableName',\n  'TABLE_SCHEMA as tableSchema',\n  'TABLE_SCHEMA as tableCatalog',\n  'COLUMN_NAME as columnName',\n  'REFERENCED_TABLE_SCHEMA as referencedTableSchema',\n  'REFERENCED_TABLE_SCHEMA as referencedTableCatalog',\n  'REFERENCED_TABLE_NAME as referencedTableName',\n  'REFERENCED_COLUMN_NAME as referencedColumnName'\n].join(',');\n\n/**\n * list of reserved words in Snowflake\n * source: https://docs.snowflake.com/en/sql-reference/reserved-keywords.html\n *\n * @private\n */\nconst SNOWFLAKE_RESERVED_WORDS = 'account,all,alter,and,any,as,between,by,case,cast,check,column,connect,connections,constraint,create,cross,current,current_date,current_time,current_timestamp,current_user,database,delete,distinct,drop,else,exists,false,following,for,from,full,grant,group,gscluster,having,ilike,in,increment,inner,insert,intersect,into,is,issue,join,lateral,left,like,localtime,localtimestamp,minus,natural,not,null,of,on,or,order,organization,qualify,regexp,revoke,right,rlike,row,rows,sample,schema,select,set,some,start,table,tablesample,then,to,trigger,true,try_cast,union,unique,update,using,values,view,when,whenever,where,with'.split(',');\n\nconst typeWithoutDefault = new Set(['BLOB', 'TEXT', 'GEOMETRY', 'JSON']);\n\nclass SnowflakeQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n\n    this.OperatorMap = {\n      ...this.OperatorMap,\n      [Op.regexp]: 'REGEXP',\n      [Op.notRegexp]: 'NOT REGEXP'\n    };\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = {\n      charset: null,\n      collate: null,\n      ...options\n    };\n\n    return Utils.joinSQLFragments([\n      'CREATE DATABASE IF NOT EXISTS',\n      this.quoteIdentifier(databaseName),\n      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,\n      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,\n      ';'\n    ]);\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;\n  }\n\n  createSchema() {\n    return 'SHOW TABLES';\n  }\n\n  showSchemasQuery() {\n    return 'SHOW TABLES';\n  }\n\n  versionQuery() {\n    return 'SELECT CURRENT_VERSION()';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = {\n      charset: null,\n      rowFormat: null,\n      ...options\n    };\n\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      let match;\n\n      if (dataType.includes('PRIMARY KEY')) {\n        primaryKeys.push(attr);\n\n        if (dataType.includes('REFERENCES')) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n        }\n      } else if (dataType.includes('REFERENCES')) {\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n\n    return Utils.joinSQLFragments([\n      'CREATE TABLE IF NOT EXISTS',\n      table,\n      `(${attributesClause})`,\n      options.comment && typeof options.comment === 'string' && `COMMENT ${this.escape(options.comment)}`,\n      options.charset && `DEFAULT CHARSET=${options.charset}`,\n      options.collate && `COLLATE ${options.collate}`,\n      options.rowFormat && `ROW_FORMAT=${options.rowFormat}`,\n      ';'\n    ]);\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(\n      this.addSchema({\n        tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      })\n    );\n\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n\n  showTablesQuery(database) {\n    return Utils.joinSQLFragments([\n      'SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \\'BASE TABLE\\'',\n      database ? `AND TABLE_SCHEMA = ${this.escape(database)}` : 'AND TABLE_SCHEMA NOT IN ( \\'INFORMATION_SCHEMA\\', \\'PERFORMANCE_SCHEMA\\', \\'SYS\\')',\n      ';'\n    ]);\n  }\n\n  tableExistsQuery(table) {\n    const tableName = table.tableName || table;\n    const schema = table.schema;\n\n    return Utils.joinSQLFragments([\n      'SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \\'BASE TABLE\\'',\n      `AND TABLE_SCHEMA = ${schema !== undefined ? this.escape(schema) : 'CURRENT_SCHEMA()'}`,\n      `AND TABLE_NAME = ${this.escape(tableName)}`,\n      ';'\n    ]);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'ADD',\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        context: 'addColumn',\n        tableName: table,\n        foreignKey: key\n      }),\n      ';'\n    ]);\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP',\n      this.quoteIdentifier(attributeName),\n      ';'\n    ]);\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const query = (...subQuerys) => Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'ALTER COLUMN',\n      ...subQuerys,\n      ';'\n    ]);\n    const sql = [];\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      const attrSql = [];\n\n      if (definition.includes('NOT NULL')) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), 'SET NOT NULL'));\n\n        definition = definition.replace('NOT NULL', '').trim();\n      } else if (!definition.includes('REFERENCES')) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), 'DROP NOT NULL'));\n      }\n\n      if (definition.includes('DEFAULT')) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), 'SET DEFAULT', definition.match(/DEFAULT ([^;]+)/)[1]));\n\n        definition = definition.replace(/(DEFAULT[^;]+)/, '').trim();\n      } else if (!definition.includes('REFERENCES')) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), 'DROP DEFAULT'));\n      }\n\n      if (definition.match(/UNIQUE;*$/)) {\n        definition = definition.replace(/UNIQUE;*$/, '');\n        attrSql.push(query('ADD UNIQUE (', this.quoteIdentifier(attributeName), ')').replace('ALTER COLUMN', ''));\n      }\n\n      if (definition.includes('REFERENCES')) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        attrSql.push(query('ADD FOREIGN KEY (', this.quoteIdentifier(attributeName), ')', definition).replace('ALTER COLUMN', ''));\n      } else {\n        attrSql.push(query(this.quoteIdentifier(attributeName), 'TYPE', definition));\n      }\n\n      sql.push(attrSql.join(''));\n    }\n\n    return sql.join('');\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`'${attrBefore}' '${attrName}' ${definition}`);\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'RENAME COLUMN',\n      attrString.join(' to '),\n      ';'\n    ]);\n  }\n\n  handleSequelizeMethod(attr, tableName, factory, options, prepend) {\n    if (attr instanceof Utils.Json) {\n      // Parse nested object\n      if (attr.conditions) {\n        const conditions = this.parseConditionObject(attr.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      }\n      if (attr.path) {\n        let str;\n\n        // Allow specifying conditions using the sqlite json functions\n        if (this._checkValidJsonStatement(attr.path)) {\n          str = attr.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(attr.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (attr.value) {\n          str += util.format(' = %s', this.escape(attr.value));\n        }\n\n        return str;\n      }\n    } else if (attr instanceof Utils.Cast) {\n      if (/timestamp/i.test(attr.type)) {\n        attr.type = 'datetime';\n      } else if (attr.json && /boolean/i.test(attr.type)) {\n        // true or false cannot be casted as booleans within a JSON structure\n        attr.type = 'char';\n      } else if (/double precision/i.test(attr.type) || /boolean/i.test(attr.type) || /integer/i.test(attr.type)) {\n        attr.type = 'decimal';\n      } else if (/text/i.test(attr.type)) {\n        attr.type = 'char';\n      }\n    }\n\n    return super.handleSequelizeMethod(attr, tableName, factory, options, prepend);\n  }\n\n  truncateTableQuery(tableName) {\n    return Utils.joinSQLFragments([\n      'TRUNCATE',\n      this.quoteTable(tableName)\n    ]);\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    const limit = options.limit && ` LIMIT ${this.escape(options.limit)}`;\n    let primaryKeys = '';\n    let primaryKeysSelection = '';\n\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n\n    if (limit) {\n      if (!model) {\n        throw new Error('Cannot LIMIT delete without a model.');\n      }\n\n      const pks = Object.values(model.primaryKeys).map(pk => this.quoteIdentifier(pk.field)).join(',');\n\n      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;\n      primaryKeysSelection = pks;\n\n      return Utils.joinSQLFragments([\n        'DELETE FROM',\n        table,\n        'WHERE',\n        primaryKeys,\n        'IN (SELECT',\n        primaryKeysSelection,\n        'FROM',\n        table,\n        whereClause,\n        limit,\n        ')',\n        ';'\n      ]);\n    }\n    return Utils.joinSQLFragments([\n      'DELETE FROM',\n      table,\n      whereClause,\n      ';'\n    ]);\n  }\n\n  showIndexesQuery() {\n    return 'SELECT \\'\\' FROM DUAL';\n  }\n\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n\n    return Utils.joinSQLFragments([\n      'SELECT CONSTRAINT_CATALOG AS constraintCatalog,',\n      'CONSTRAINT_NAME AS constraintName,',\n      'CONSTRAINT_SCHEMA AS constraintSchema,',\n      'CONSTRAINT_TYPE AS constraintType,',\n      'TABLE_NAME AS tableName,',\n      'TABLE_SCHEMA AS tableSchema',\n      'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS',\n      `WHERE table_name='${tableName}'`,\n      constraintName && `AND constraint_name = '${constraintName}'`,\n      schemaName && `AND TABLE_SCHEMA = '${schemaName}'`,\n      ';'\n    ]);\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return Utils.joinSQLFragments([\n      'DROP INDEX',\n      this.quoteIdentifier(indexName),\n      'ON',\n      this.quoteTable(tableName),\n      ';'\n    ]);\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });\n    let template = attributeString;\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' AUTOINCREMENT';\n    }\n\n    // BLOB/TEXT/GEOMETRY/JSON cannot have a default value\n    if (!typeWithoutDefault.has(attributeString)\n      && attribute.type._binary !== true\n      && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n\n    if (attribute.first) {\n      template += ' FIRST';\n    }\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n\n    if (attribute.references) {\n      if (options && options.context === 'addColumn' && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   * @private\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  dataTypeMapping(tableName, attr, dataType) {\n    if (dataType.includes('PRIMARY KEY')) {\n      dataType = dataType.replace('PRIMARY KEY', '');\n    }\n\n    if (dataType.includes('SERIAL')) {\n      if (dataType.includes('BIGINT')) {\n        dataType = dataType.replace('SERIAL', 'BIGSERIAL');\n        dataType = dataType.replace('BIGINT', '');\n      } else if (dataType.includes('SMALLINT')) {\n        dataType = dataType.replace('SERIAL', 'SMALLSERIAL');\n        dataType = dataType.replace('SMALLINT', '');\n      } else {\n        dataType = dataType.replace('INTEGER', '');\n      }\n      dataType = dataType.replace('NOT NULL', '');\n    }\n\n    return dataType;\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {object} table  The table.\n   * @param  {string} schemaName The name of the schema.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      'SELECT',\n      FOREIGN_KEY_FIELDS,\n      `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`,\n      `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`,\n      'AND REFERENCED_TABLE_NAME IS NOT NULL',\n      ';'\n    ]);\n  }\n\n  /**\n   * Generates an SQL query that returns the foreign key constraint of a given column.\n   *\n   * @param  {object} table  The table.\n   * @param  {string} columnName The name of the column.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : '';\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n\n    return Utils.joinSQLFragments([\n      'SELECT',\n      FOREIGN_KEY_FIELDS,\n      'FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE',\n      'WHERE (',\n      [\n        `REFERENCED_TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`\n      ],\n      ') OR (',\n      [\n        `TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND COLUMN_NAME = ${quotedColumnName}`,\n        'AND REFERENCED_TABLE_NAME IS NOT NULL'\n      ],\n      ')'\n    ]);\n  }\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @param  {string} foreignKey The name of the foreign key constraint.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP FOREIGN KEY',\n      this.quoteIdentifier(foreignKey),\n      ';'\n    ]);\n  }\n\n  addLimitAndOffset(options) {\n    let fragment = [];\n    if (options.offset !== null && options.offset !== undefined && options.offset !== 0) {\n      fragment = fragment.concat([' LIMIT ', this.escape(options.limit), ' OFFSET ', this.escape(options.offset)]);\n    } else if ( options.limit !== null && options.limit !== undefined ) {\n      fragment = [' LIMIT ', this.escape(options.limit)];\n    }\n    return fragment.join('');\n  }\n\n  /**\n   * Quote identifier in sql clause\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    const optForceQuote = force || false;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n\n    if (\n      optForceQuote === true ||\n      optQuoteIdentifiers !== false ||\n      identifier.includes('.') ||\n      identifier.includes('->') ||\n      SNOWFLAKE_RESERVED_WORDS.includes(rawIdentifier.toLowerCase())\n    ) {\n      // In Snowflake if tables or attributes are created double-quoted,\n      // they are also case sensitive. If they contain any uppercase\n      // characters, they must always be double-quoted. This makes it\n      // impossible to write queries in portable SQL if tables are created in\n      // this way. Hence, we strip quotes if we don't want case sensitivity.\n      return Utils.addTicks(rawIdentifier, '\"');\n    }\n    return rawIdentifier;\n  }\n}\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, '\\'');\n}\n\nmodule.exports = SnowflakeQueryGenerator;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}