{"ast":null,"code":"\"use strict\";\n\nconst wkx = require(\"wkx\");\nconst _ = require(\"lodash\");\nconst momentTz = require(\"moment-timezone\");\nconst moment = require(\"moment\");\nmodule.exports = BaseTypes => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = \"https://mariadb.com/kb/en/library/resultset/#field-types\";\n  BaseTypes.DATE.types.mariadb = [\"DATETIME\"];\n  BaseTypes.STRING.types.mariadb = [\"VAR_STRING\"];\n  BaseTypes.CHAR.types.mariadb = [\"STRING\"];\n  BaseTypes.TEXT.types.mariadb = [\"BLOB\"];\n  BaseTypes.TINYINT.types.mariadb = [\"TINY\"];\n  BaseTypes.SMALLINT.types.mariadb = [\"SHORT\"];\n  BaseTypes.MEDIUMINT.types.mariadb = [\"INT24\"];\n  BaseTypes.INTEGER.types.mariadb = [\"LONG\"];\n  BaseTypes.BIGINT.types.mariadb = [\"LONGLONG\"];\n  BaseTypes.FLOAT.types.mariadb = [\"FLOAT\"];\n  BaseTypes.TIME.types.mariadb = [\"TIME\"];\n  BaseTypes.DATEONLY.types.mariadb = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.mariadb = [\"TINY\"];\n  BaseTypes.BLOB.types.mariadb = [\"TINYBLOB\", \"BLOB\", \"LONGBLOB\"];\n  BaseTypes.DECIMAL.types.mariadb = [\"NEWDECIMAL\"];\n  BaseTypes.UUID.types.mariadb = false;\n  BaseTypes.ENUM.types.mariadb = false;\n  BaseTypes.REAL.types.mariadb = [\"DOUBLE\"];\n  BaseTypes.DOUBLE.types.mariadb = [\"DOUBLE\"];\n  BaseTypes.GEOMETRY.types.mariadb = [\"GEOMETRY\"];\n  BaseTypes.JSON.types.mariadb = [\"JSON\"];\n  class DECIMAL extends BaseTypes.DECIMAL {\n    toSql() {\n      let definition = super.toSql();\n      if (this._unsigned) {\n        definition += \" UNSIGNED\";\n      }\n      if (this._zerofill) {\n        definition += \" ZEROFILL\";\n      }\n      return definition;\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return this._length ? `DATETIME(${this._length})` : \"DATETIME\";\n    }\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n      return date.format(\"YYYY-MM-DD HH:mm:ss.SSS\");\n    }\n    static parse(value, options) {\n      value = value.string();\n      if (value === null) {\n        return value;\n      }\n      if (momentTz.tz.zone(options.timezone)) {\n        value = momentTz.tz(value, options.timezone).toDate();\n      } else {\n        value = new Date(`${value} ${options.timezone}`);\n      }\n      return value;\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return value.string();\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"CHAR(36) BINARY\";\n    }\n  }\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    constructor(type, srid) {\n      super(type, srid);\n      if (_.isEmpty(this.type)) {\n        this.sqlType = this.key;\n      } else {\n        this.sqlType = this.type;\n      }\n    }\n    static parse(value) {\n      value = value.buffer();\n      if (!value || value.length === 0) {\n        return null;\n      }\n      value = value.slice(4);\n      return wkx.Geometry.parse(value).toGeoJSON({\n        shortCrs: true\n      });\n    }\n    toSql() {\n      return this.sqlType;\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql(options) {\n      return `ENUM(${this.values.map(value => options.escape(value)).join(\", \")})`;\n    }\n  }\n  class JSONTYPE extends BaseTypes.JSON {\n    _stringify(value, options) {\n      return options.operation === \"where\" && typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n  }\n  return {\n    ENUM,\n    DATE,\n    DATEONLY,\n    UUID,\n    GEOMETRY,\n    DECIMAL,\n    JSON: JSONTYPE\n  };\n};","map":{"version":3,"names":["wkx","require","_","momentTz","moment","module","exports","BaseTypes","ABSTRACT","prototype","dialectTypes","DATE","types","mariadb","STRING","CHAR","TEXT","TINYINT","SMALLINT","MEDIUMINT","INTEGER","BIGINT","FLOAT","TIME","DATEONLY","BOOLEAN","BLOB","DECIMAL","UUID","ENUM","REAL","DOUBLE","GEOMETRY","JSON","toSql","definition","_unsigned","_zerofill","_length","_stringify","date","options","isMoment","_applyTimezone","format","parse","value","string","tz","zone","timezone","toDate","Date","constructor","type","srid","isEmpty","sqlType","key","buffer","length","slice","Geometry","toGeoJSON","shortCrs","values","map","escape","join","JSONTYPE","operation","stringify"],"sources":["C:\\Users\\teply\\OneDrive\\Рабочий стол\\web_project\\client\\node_modules\\sequelize\\src\\dialects\\mariadb\\data-types.js"],"sourcesContent":["'use strict';\n\nconst wkx = require('wkx');\nconst _ = require('lodash');\nconst momentTz = require('moment-timezone');\nconst moment = require('moment');\n\nmodule.exports = BaseTypes => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = 'https://mariadb.com/kb/en/library/resultset/#field-types';\n\n  /**\n   * types: [buffer_type, ...]\n   *\n   * @see documentation : https://mariadb.com/kb/en/library/resultset/#field-types\n   * @see connector implementation : https://github.com/MariaDB/mariadb-connector-nodejs/blob/master/lib/const/field-type.js\n   */\n\n  BaseTypes.DATE.types.mariadb = ['DATETIME'];\n  BaseTypes.STRING.types.mariadb = ['VAR_STRING'];\n  BaseTypes.CHAR.types.mariadb = ['STRING'];\n  BaseTypes.TEXT.types.mariadb = ['BLOB'];\n  BaseTypes.TINYINT.types.mariadb = ['TINY'];\n  BaseTypes.SMALLINT.types.mariadb = ['SHORT'];\n  BaseTypes.MEDIUMINT.types.mariadb = ['INT24'];\n  BaseTypes.INTEGER.types.mariadb = ['LONG'];\n  BaseTypes.BIGINT.types.mariadb = ['LONGLONG'];\n  BaseTypes.FLOAT.types.mariadb = ['FLOAT'];\n  BaseTypes.TIME.types.mariadb = ['TIME'];\n  BaseTypes.DATEONLY.types.mariadb = ['DATE'];\n  BaseTypes.BOOLEAN.types.mariadb = ['TINY'];\n  BaseTypes.BLOB.types.mariadb = ['TINYBLOB', 'BLOB', 'LONGBLOB'];\n  BaseTypes.DECIMAL.types.mariadb = ['NEWDECIMAL'];\n  BaseTypes.UUID.types.mariadb = false;\n  BaseTypes.ENUM.types.mariadb = false;\n  BaseTypes.REAL.types.mariadb = ['DOUBLE'];\n  BaseTypes.DOUBLE.types.mariadb = ['DOUBLE'];\n  BaseTypes.GEOMETRY.types.mariadb = ['GEOMETRY'];\n  BaseTypes.JSON.types.mariadb = ['JSON'];\n\n  class DECIMAL extends BaseTypes.DECIMAL {\n    toSql() {\n      let definition = super.toSql();\n      if (this._unsigned) {\n        definition += ' UNSIGNED';\n      }\n      if (this._zerofill) {\n        definition += ' ZEROFILL';\n      }\n      return definition;\n    }\n  }\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return this._length ? `DATETIME(${this._length})` : 'DATETIME';\n    }\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n\n      return date.format('YYYY-MM-DD HH:mm:ss.SSS');\n    }\n    static parse(value, options) {\n      value = value.string();\n      if (value === null) {\n        return value;\n      }\n      if (momentTz.tz.zone(options.timezone)) {\n        value = momentTz.tz(value, options.timezone).toDate();\n      }\n      else {\n        value = new Date(`${value} ${options.timezone}`);\n      }\n      return value;\n    }\n  }\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return value.string();\n    }\n  }\n\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return 'CHAR(36) BINARY';\n    }\n  }\n\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    constructor(type, srid) {\n      super(type, srid);\n      if (_.isEmpty(this.type)) {\n        this.sqlType = this.key;\n      }\n      else {\n        this.sqlType = this.type;\n      }\n    }\n    static parse(value) {\n      value = value.buffer();\n      // Empty buffer, MySQL doesn't support POINT EMPTY\n      // check, https://dev.mysql.com/worklog/task/?id=2381\n      if (!value || value.length === 0) {\n        return null;\n      }\n      // For some reason, discard the first 4 bytes\n      value = value.slice(4);\n      return wkx.Geometry.parse(value).toGeoJSON({ shortCrs: true });\n    }\n    toSql() {\n      return this.sqlType;\n    }\n  }\n\n  class ENUM extends BaseTypes.ENUM {\n    toSql(options) {\n      return `ENUM(${this.values.map(value => options.escape(value)).join(', ')})`;\n    }\n  }\n\n  class JSONTYPE extends BaseTypes.JSON {\n    _stringify(value, options) {\n      return options.operation === 'where' && typeof value === 'string' ? value\n        : JSON.stringify(value);\n    }\n  }\n\n  return {\n    ENUM,\n    DATE,\n    DATEONLY,\n    UUID,\n    GEOMETRY,\n    DECIMAL,\n    JSON: JSONTYPE\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}