{"ast":null,"code":"\"use strict\";\n\nconst AbstractQuery = require(\"../abstract/query\");\nconst sequelizeErrors = require(\"../../errors\");\nconst parserStore = require(\"../parserStore\")(\"mssql\");\nconst _ = require(\"lodash\");\nconst {\n  logger\n} = require(\"../../utils/logger\");\nconst debug = logger.debugContext(\"sql:mssql\");\nconst minSafeIntegerAsBigInt = BigInt(Number.MIN_SAFE_INTEGER);\nconst maxSafeIntegerAsBigInt = BigInt(Number.MAX_SAFE_INTEGER);\nfunction getScale(aNum) {\n  if (!Number.isFinite(aNum)) return 0;\n  let e = 1;\n  while (Math.round(aNum * e) / e !== aNum) e *= 10;\n  return Math.log10(e);\n}\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return \"id\";\n  }\n  getSQLTypeFromJsType(value, TYPES) {\n    const paramType = {\n      type: TYPES.NVarChar,\n      typeOptions: {},\n      value\n    };\n    if (typeof value === \"number\") {\n      if (Number.isInteger(value)) {\n        if (value >= -2147483648 && value <= 2147483647) {\n          paramType.type = TYPES.Int;\n        } else {\n          paramType.type = TYPES.BigInt;\n        }\n      } else {\n        paramType.type = TYPES.Numeric;\n        paramType.typeOptions = {\n          precision: 30,\n          scale: getScale(value)\n        };\n      }\n    } else if (typeof value === \"bigint\") {\n      if (value < minSafeIntegerAsBigInt || value > maxSafeIntegerAsBigInt) {\n        paramType.type = TYPES.VarChar;\n        paramType.value = value.toString();\n      } else {\n        return this.getSQLTypeFromJsType(Number(value), TYPES);\n      }\n    } else if (typeof value === \"boolean\") {\n      paramType.type = TYPES.Bit;\n    }\n    if (Buffer.isBuffer(value)) {\n      paramType.type = TYPES.VarBinary;\n    }\n    return paramType;\n  }\n  async _run(connection, sql, parameters, errStack) {\n    this.sql = sql;\n    const {\n      options\n    } = this;\n    const complete = this._logQuery(sql, debug, parameters);\n    const query = new Promise((resolve, reject) => {\n      if (sql.startsWith(\"BEGIN TRANSACTION\")) {\n        return connection.beginTransaction(error => error ? reject(error) : resolve([]), options.transaction.name, connection.lib.ISOLATION_LEVEL[options.isolationLevel]);\n      }\n      if (sql.startsWith(\"COMMIT TRANSACTION\")) {\n        return connection.commitTransaction(error => error ? reject(error) : resolve([]));\n      }\n      if (sql.startsWith(\"ROLLBACK TRANSACTION\")) {\n        return connection.rollbackTransaction(error => error ? reject(error) : resolve([]), options.transaction.name);\n      }\n      if (sql.startsWith(\"SAVE TRANSACTION\")) {\n        return connection.saveTransaction(error => error ? reject(error) : resolve([]), options.transaction.name);\n      }\n      const rows2 = [];\n      const request = new connection.lib.Request(sql, (err, rowCount2) => err ? reject(err) : resolve([rows2, rowCount2]));\n      if (parameters) {\n        _.forOwn(parameters, (value, key) => {\n          const paramType = this.getSQLTypeFromJsType(value, connection.lib.TYPES);\n          request.addParameter(key, paramType.type, value, paramType.typeOptions);\n        });\n      }\n      request.on(\"row\", columns => {\n        rows2.push(columns);\n      });\n      connection.execSql(request);\n    });\n    let rows, rowCount;\n    try {\n      [rows, rowCount] = await query;\n    } catch (err) {\n      err.sql = sql;\n      err.parameters = parameters;\n      throw this.formatError(err, errStack);\n    }\n    complete();\n    if (Array.isArray(rows)) {\n      rows = rows.map(columns => {\n        const row = {};\n        for (const column of columns) {\n          const typeid = column.metadata.type.id;\n          const parse = parserStore.get(typeid);\n          let value = column.value;\n          if (value !== null & !!parse) {\n            value = parse(value);\n          }\n          row[column.metadata.colName] = value;\n        }\n        return row;\n      });\n    }\n    return this.formatResults(rows, rowCount);\n  }\n  run(sql, parameters) {\n    const errForStack = new Error();\n    return this.connection.queue.enqueue(() => this._run(this.connection, sql, parameters, errForStack.stack));\n  }\n  static formatBindParameters(sql, values, dialect) {\n    const bindParam = {};\n    const replacementFunc = (match, key, values2) => {\n      if (values2[key] !== void 0) {\n        bindParam[key] = values2[key];\n        return `@${key}`;\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, bindParam];\n  }\n  formatResults(data, rowCount) {\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n      return [this.instance || data, rowCount];\n    }\n    if (this.isShowTablesQuery()) {\n      return this.handleShowTablesQuery(data);\n    }\n    if (this.isDescribeQuery()) {\n      const result = {};\n      for (const _result of data) {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", \"\").replace(\"')\", \"\").replace(/'/g, \"\");\n        }\n        result[_result.Name] = {\n          type: _result.Type.toUpperCase(),\n          allowNull: _result.IsNull === \"YES\" ? true : false,\n          defaultValue: _result.Default,\n          primaryKey: _result.Constraint === \"PRIMARY KEY\",\n          autoIncrement: _result.IsIdentity === 1,\n          comment: _result.Comment\n        };\n        if (result[_result.Name].type.includes(\"CHAR\") && _result.Length) {\n          if (_result.Length === -1) {\n            result[_result.Name].type += \"(MAX)\";\n          } else {\n            result[_result.Name].type += `(${_result.Length})`;\n          }\n        }\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      return this.handleSelectQuery(data);\n    }\n    if (this.isShowIndexesQuery()) {\n      return this.handleShowIndexesQuery(data);\n    }\n    if (this.isCallQuery()) {\n      return data[0];\n    }\n    if (this.isBulkUpdateQuery()) {\n      if (this.options.returning) {\n        return this.handleSelectQuery(data);\n      }\n      return rowCount;\n    }\n    if (this.isBulkDeleteQuery()) {\n      return data[0] ? data[0].AFFECTEDROWS : 0;\n    }\n    if (this.isVersionQuery()) {\n      return data[0].version;\n    }\n    if (this.isForeignKeysQuery()) {\n      return data;\n    }\n    if (this.isUpsertQuery()) {\n      if (data && data.length === 0) {\n        return [this.instance || data, false];\n      }\n      this.handleInsertQuery(data);\n      return [this.instance || data, data[0].$action === \"INSERT\"];\n    }\n    if (this.isUpdateQuery()) {\n      return [this.instance || data, rowCount];\n    }\n    if (this.isShowConstraintsQuery()) {\n      return this.handleShowConstraintsQuery(data);\n    }\n    if (this.isRawQuery()) {\n      return [data, rowCount];\n    }\n    return data;\n  }\n  handleShowTablesQuery(results) {\n    return results.map(resultSet => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n  handleShowConstraintsQuery(data) {\n    return data.slice(1).map(result => {\n      const constraint = {};\n      for (const key in result) {\n        constraint[_.camelCase(key)] = result[key];\n      }\n      return constraint;\n    });\n  }\n  formatError(err, errStack) {\n    let match;\n    match = err.message.match(/Violation of (?:UNIQUE|PRIMARY) KEY constraint '([^']*)'. Cannot insert duplicate key in object '.*'.(:? The duplicate key value is \\((.*)\\).)?/);\n    match = match || err.message.match(/Cannot insert duplicate key row in object .* with unique index '(.*)'/);\n    if (match && match.length > 1) {\n      let fields = {};\n      const uniqueKey = this.model && this.model.uniqueKeys[match[1]];\n      let message = \"Validation error\";\n      if (uniqueKey && !!uniqueKey.msg) {\n        message = uniqueKey.msg;\n      }\n      if (match[3]) {\n        const values = match[3].split(\",\").map(part => part.trim());\n        if (uniqueKey) {\n          fields = _.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[match[1]] = match[3];\n        }\n      }\n      const errors = [];\n      _.forOwn(fields, (value, field) => {\n        errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n      });\n      return new sequelizeErrors.UniqueConstraintError({\n        message,\n        errors,\n        parent: err,\n        fields,\n        stack: errStack\n      });\n    }\n    match = err.message.match(/Failed on step '(.*)'.Could not create constraint. See previous errors./) || err.message.match(/The DELETE statement conflicted with the REFERENCE constraint \"(.*)\". The conflict occurred in database \"(.*)\", table \"(.*)\", column '(.*)'./) || err.message.match(/The (?:INSERT|MERGE|UPDATE) statement conflicted with the FOREIGN KEY constraint \"(.*)\". The conflict occurred in database \"(.*)\", table \"(.*)\", column '(.*)'./);\n    if (match && match.length > 0) {\n      return new sequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err,\n        stack: errStack\n      });\n    }\n    match = err.message.match(/Could not drop constraint. See previous errors./);\n    if (match && match.length > 0) {\n      let constraint = err.sql.match(/(?:constraint|index) \\[(.+?)\\]/i);\n      constraint = constraint ? constraint[1] : void 0;\n      let table = err.sql.match(/table \\[(.+?)\\]/i);\n      table = table ? table[1] : void 0;\n      return new sequelizeErrors.UnknownConstraintError({\n        message: match[1],\n        constraint,\n        table,\n        parent: err,\n        stack: errStack\n      });\n    }\n    return new sequelizeErrors.DatabaseError(err, {\n      stack: errStack\n    });\n  }\n  isShowOrDescribeQuery() {\n    let result = false;\n    result = result || this.sql.toLowerCase().startsWith(\"select c.column_name as 'name', c.data_type as 'type', c.is_nullable as 'isnull'\");\n    result = result || this.sql.toLowerCase().startsWith(\"select tablename = t.name, name = ind.name,\");\n    result = result || this.sql.toLowerCase().startsWith(\"exec sys.sp_helpindex @objname\");\n    return result;\n  }\n  isShowIndexesQuery() {\n    return this.sql.toLowerCase().startsWith(\"exec sys.sp_helpindex @objname\");\n  }\n  handleShowIndexesQuery(data) {\n    data = data.reduce((acc, item) => {\n      if (!(item.index_name in acc)) {\n        acc[item.index_name] = item;\n        item.fields = [];\n      }\n      item.index_keys.split(\",\").forEach(column => {\n        let columnName = column.trim();\n        if (columnName.includes(\"(-)\")) {\n          columnName = columnName.replace(\"(-)\", \"\");\n        }\n        acc[item.index_name].fields.push({\n          attribute: columnName,\n          length: void 0,\n          order: column.includes(\"(-)\") ? \"DESC\" : \"ASC\",\n          collate: void 0\n        });\n      });\n      delete item.index_keys;\n      return acc;\n    }, {});\n    return _.map(data, item => ({\n      primary: item.index_name.toLowerCase().startsWith(\"pk\"),\n      fields: item.fields,\n      name: item.index_name,\n      tableName: void 0,\n      unique: item.index_description.toLowerCase().includes(\"unique\"),\n      type: void 0\n    }));\n  }\n  handleInsertQuery(results, metaData) {\n    if (this.instance) {\n      const autoIncrementAttribute = this.model.autoIncrementAttribute;\n      let id = null;\n      let autoIncrementAttributeAlias = null;\n      if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementAttribute) && this.model.rawAttributes[autoIncrementAttribute].field !== void 0) autoIncrementAttributeAlias = this.model.rawAttributes[autoIncrementAttribute].field;\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementAttribute];\n      id = id || autoIncrementAttributeAlias && results && results[0][autoIncrementAttributeAlias];\n      this.instance[autoIncrementAttribute] = id;\n      if (this.instance.dataValues) {\n        for (const key in results[0]) {\n          if (Object.prototype.hasOwnProperty.call(results[0], key)) {\n            const record = results[0][key];\n            const attr = _.find(this.model.rawAttributes, attribute => attribute.fieldName === key || attribute.field === key);\n            this.instance.dataValues[attr && attr.fieldName || key] = record;\n          }\n        }\n      }\n    }\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;","map":{"version":3,"names":["AbstractQuery","require","sequelizeErrors","parserStore","_","logger","debug","debugContext","minSafeIntegerAsBigInt","BigInt","Number","MIN_SAFE_INTEGER","maxSafeIntegerAsBigInt","MAX_SAFE_INTEGER","getScale","aNum","isFinite","e","Math","round","log10","Query","getInsertIdField","getSQLTypeFromJsType","value","TYPES","paramType","type","NVarChar","typeOptions","isInteger","Int","Numeric","precision","scale","VarChar","toString","Bit","Buffer","isBuffer","VarBinary","_run","connection","sql","parameters","errStack","options","complete","_logQuery","query","Promise","resolve","reject","startsWith","beginTransaction","error","transaction","name","lib","ISOLATION_LEVEL","isolationLevel","commitTransaction","rollbackTransaction","saveTransaction","rows2","request","Request","err","rowCount2","forOwn","key","addParameter","on","columns","push","execSql","rows","rowCount","formatError","Array","isArray","map","row","column","typeid","metadata","id","parse","get","colName","formatResults","run","errForStack","Error","queue","enqueue","stack","formatBindParameters","values","dialect","bindParam","replacementFunc","match","values2","data","isInsertQuery","handleInsertQuery","instance","isShowTablesQuery","handleShowTablesQuery","isDescribeQuery","result","_result","Default","replace","Name","Type","toUpperCase","allowNull","IsNull","defaultValue","primaryKey","Constraint","autoIncrement","IsIdentity","comment","Comment","includes","Length","isSelectQuery","handleSelectQuery","isShowIndexesQuery","handleShowIndexesQuery","isCallQuery","isBulkUpdateQuery","returning","isBulkDeleteQuery","AFFECTEDROWS","isVersionQuery","version","isForeignKeysQuery","isUpsertQuery","length","$action","isUpdateQuery","isShowConstraintsQuery","handleShowConstraintsQuery","isRawQuery","results","resultSet","tableName","TABLE_NAME","schema","TABLE_SCHEMA","slice","constraint","camelCase","message","fields","uniqueKey","model","uniqueKeys","msg","split","part","trim","zipObject","errors","field","ValidationErrorItem","getUniqueConstraintErrorMessage","UniqueConstraintError","parent","ForeignKeyConstraintError","index","table","UnknownConstraintError","DatabaseError","isShowOrDescribeQuery","toLowerCase","reduce","acc","item","index_name","index_keys","forEach","columnName","attribute","order","collate","primary","unique","index_description","metaData","autoIncrementAttribute","autoIncrementAttributeAlias","Object","prototype","hasOwnProperty","call","rawAttributes","dataValues","record","attr","find","fieldName","module","exports","default"],"sources":["C:\\Users\\teply\\OneDrive\\Рабочий стол\\web_project\\client\\node_modules\\sequelize\\src\\dialects\\mssql\\query.js"],"sourcesContent":["'use strict';\n\nconst AbstractQuery = require('../abstract/query');\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('mssql');\nconst _ = require('lodash');\nconst { logger } = require('../../utils/logger');\n\nconst debug = logger.debugContext('sql:mssql');\n\nconst minSafeIntegerAsBigInt = BigInt(Number.MIN_SAFE_INTEGER);\nconst maxSafeIntegerAsBigInt = BigInt(Number.MAX_SAFE_INTEGER);\n\nfunction getScale(aNum) {\n  if (!Number.isFinite(aNum)) return 0;\n  let e = 1;\n  while (Math.round(aNum * e) / e !== aNum) e *= 10;\n  return Math.log10(e);\n}\n\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return 'id';\n  }\n\n  getSQLTypeFromJsType(value, TYPES) {\n    const paramType = { type: TYPES.NVarChar, typeOptions: {}, value };\n    if (typeof value === 'number') {\n      if (Number.isInteger(value)) {\n        if (value >= -2147483648 && value <= 2147483647) {\n          paramType.type = TYPES.Int;\n        } else {\n          paramType.type = TYPES.BigInt;\n        }\n      } else {\n        paramType.type = TYPES.Numeric;\n        //Default to a reasonable numeric precision/scale pending more sophisticated logic\n        paramType.typeOptions = { precision: 30, scale: getScale(value) };\n      }\n    } else if (typeof value === 'bigint') {\n      if (value < minSafeIntegerAsBigInt || value > maxSafeIntegerAsBigInt) {\n        paramType.type = TYPES.VarChar;\n        paramType.value = value.toString();\n      } else {\n        return this.getSQLTypeFromJsType(Number(value), TYPES);\n      }\n    } else if (typeof value === 'boolean') {\n      paramType.type = TYPES.Bit;\n    }\n    if (Buffer.isBuffer(value)) {\n      paramType.type = TYPES.VarBinary;\n    }\n    return paramType;\n  }\n\n  async _run(connection, sql, parameters, errStack) {\n    this.sql = sql;\n    const { options } = this;\n\n    const complete = this._logQuery(sql, debug, parameters);\n\n    const query = new Promise((resolve, reject) => {\n      // TRANSACTION SUPPORT\n      if (sql.startsWith('BEGIN TRANSACTION')) {\n        return connection.beginTransaction(error => error ? reject(error) : resolve([]), options.transaction.name, connection.lib.ISOLATION_LEVEL[options.isolationLevel]);\n      }\n      if (sql.startsWith('COMMIT TRANSACTION')) {\n        return connection.commitTransaction(error => error ? reject(error) : resolve([]));\n      }\n      if (sql.startsWith('ROLLBACK TRANSACTION')) {\n        return connection.rollbackTransaction(error => error ? reject(error) : resolve([]), options.transaction.name);\n      }\n      if (sql.startsWith('SAVE TRANSACTION')) {\n        return connection.saveTransaction(error => error ? reject(error) : resolve([]), options.transaction.name);\n      }\n\n      const rows = [];\n      const request = new connection.lib.Request(sql, (err, rowCount) => err ? reject(err) : resolve([rows, rowCount]));\n\n      if (parameters) {\n        _.forOwn(parameters, (value, key) => {\n          const paramType = this.getSQLTypeFromJsType(value, connection.lib.TYPES);\n          request.addParameter(key, paramType.type, value, paramType.typeOptions);\n        });\n      }\n\n      request.on('row', columns => {\n        rows.push(columns);\n      });\n\n      connection.execSql(request);\n    });\n\n    let rows, rowCount;\n\n    try {\n      [rows, rowCount] = await query;\n    } catch (err) {\n      err.sql = sql;\n      err.parameters = parameters;\n\n      throw this.formatError(err, errStack);\n    }\n\n    complete();\n\n    if (Array.isArray(rows)) {\n      rows = rows.map(columns => {\n        const row = {};\n        for (const column of columns) {\n          const typeid = column.metadata.type.id;\n          const parse = parserStore.get(typeid);\n          let value = column.value;\n\n          if (value !== null & !!parse) {\n            value = parse(value);\n          }\n          row[column.metadata.colName] = value;\n        }\n        return row;\n      });\n    }\n\n    return this.formatResults(rows, rowCount);\n  }\n\n  run(sql, parameters) {\n    const errForStack = new Error();\n    return this.connection.queue.enqueue(() =>\n      this._run(this.connection, sql, parameters, errForStack.stack)\n    );\n  }\n\n  static formatBindParameters(sql, values, dialect) {\n    const bindParam = {};\n    const replacementFunc = (match, key, values) => {\n      if (values[key] !== undefined) {\n        bindParam[key] = values[key];\n        return `@${key}`;\n      }\n      return undefined;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n\n    return [sql, bindParam];\n  }\n\n  /**\n   * High level function that handles the results of a query execution.\n   *\n   * @param {Array} data - The result of the query execution.\n   * @param {number} rowCount\n   * @private\n   * @example\n   * Example:\n   *  query.formatResults([\n   *    {\n   *      id: 1,              // this is from the main table\n   *      attr2: 'snafu',     // this is from the main table\n   *      Tasks.id: 1,        // this is from the associated table\n   *      Tasks.title: 'task' // this is from the associated table\n   *    }\n   *  ])\n   */\n  formatResults(data, rowCount) {\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n      return [this.instance || data, rowCount];\n    }\n    if (this.isShowTablesQuery()) {\n      return this.handleShowTablesQuery(data);\n    }\n    if (this.isDescribeQuery()) {\n      const result = {};\n      for (const _result of data) {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", '').replace(\"')\", '').replace(/'/g, '');\n        }\n\n        result[_result.Name] = {\n          type: _result.Type.toUpperCase(),\n          allowNull: _result.IsNull === 'YES' ? true : false,\n          defaultValue: _result.Default,\n          primaryKey: _result.Constraint === 'PRIMARY KEY',\n          autoIncrement: _result.IsIdentity === 1,\n          comment: _result.Comment\n        };\n\n        if (\n          result[_result.Name].type.includes('CHAR')\n          && _result.Length\n        ) {\n          if (_result.Length === -1) {\n            result[_result.Name].type += '(MAX)';\n          } else {\n            result[_result.Name].type += `(${_result.Length})`;\n          }\n        }\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      return this.handleSelectQuery(data);\n    }\n    if (this.isShowIndexesQuery()) {\n      return this.handleShowIndexesQuery(data);\n    }\n    if (this.isCallQuery()) {\n      return data[0];\n    }\n    if (this.isBulkUpdateQuery()) {\n      if (this.options.returning) {\n        return this.handleSelectQuery(data);\n      }\n\n      return rowCount;\n    }\n    if (this.isBulkDeleteQuery()) {\n      return data[0] ? data[0].AFFECTEDROWS : 0;\n    }\n    if (this.isVersionQuery()) {\n      return data[0].version;\n    }\n    if (this.isForeignKeysQuery()) {\n      return data;\n    }\n    if (this.isUpsertQuery()) {\n      // if this was an upsert and no data came back, that means the record exists, but the update was a noop.\n      // return the current instance and mark it as an \"not an insert\".\n      if (data && data.length === 0) {\n        return [this.instance || data, false];\n      }\n      this.handleInsertQuery(data);\n      return [this.instance || data, data[0].$action === 'INSERT'];\n    }\n    if (this.isUpdateQuery()) {\n      return [this.instance || data, rowCount];\n    }\n    if (this.isShowConstraintsQuery()) {\n      return this.handleShowConstraintsQuery(data);\n    }\n    if (this.isRawQuery()) {\n      return [data, rowCount];\n    }\n    return data;\n  }\n\n  handleShowTablesQuery(results) {\n    return results.map(resultSet => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n\n  handleShowConstraintsQuery(data) {\n    //Convert snake_case keys to camelCase as it's generated by stored procedure\n    return data.slice(1).map(result => {\n      const constraint = {};\n      for (const key in result) {\n        constraint[_.camelCase(key)] = result[key];\n      }\n      return constraint;\n    });\n  }\n\n  formatError(err, errStack) {\n    let match;\n\n    match = err.message.match(/Violation of (?:UNIQUE|PRIMARY) KEY constraint '([^']*)'. Cannot insert duplicate key in object '.*'.(:? The duplicate key value is \\((.*)\\).)?/);\n    match = match || err.message.match(/Cannot insert duplicate key row in object .* with unique index '(.*)'/);\n    if (match && match.length > 1) {\n      let fields = {};\n      const uniqueKey = this.model && this.model.uniqueKeys[match[1]];\n      let message = 'Validation error';\n\n      if (uniqueKey && !!uniqueKey.msg) {\n        message = uniqueKey.msg;\n      }\n      if (match[3]) {\n        const values = match[3].split(',').map(part => part.trim());\n        if (uniqueKey) {\n          fields = _.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[match[1]] = match[3];\n        }\n      }\n\n      const errors = [];\n      _.forOwn(fields, (value, field) => {\n        errors.push(new sequelizeErrors.ValidationErrorItem(\n          this.getUniqueConstraintErrorMessage(field),\n          'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n          field,\n          value,\n          this.instance,\n          'not_unique'\n        ));\n      });\n\n      return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n    }\n\n    match = err.message.match(/Failed on step '(.*)'.Could not create constraint. See previous errors./) ||\n      err.message.match(/The DELETE statement conflicted with the REFERENCE constraint \"(.*)\". The conflict occurred in database \"(.*)\", table \"(.*)\", column '(.*)'./) ||\n      err.message.match(/The (?:INSERT|MERGE|UPDATE) statement conflicted with the FOREIGN KEY constraint \"(.*)\". The conflict occurred in database \"(.*)\", table \"(.*)\", column '(.*)'./);\n    if (match && match.length > 0) {\n      return new sequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err,\n        stack: errStack\n      });\n    }\n\n    match = err.message.match(/Could not drop constraint. See previous errors./);\n    if (match && match.length > 0) {\n      let constraint = err.sql.match(/(?:constraint|index) \\[(.+?)\\]/i);\n      constraint = constraint ? constraint[1] : undefined;\n      let table = err.sql.match(/table \\[(.+?)\\]/i);\n      table = table ? table[1] : undefined;\n\n      return new sequelizeErrors.UnknownConstraintError({\n        message: match[1],\n        constraint,\n        table,\n        parent: err,\n        stack: errStack\n      });\n    }\n\n    return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n  }\n\n  isShowOrDescribeQuery() {\n    let result = false;\n\n    result = result || this.sql.toLowerCase().startsWith(\"select c.column_name as 'name', c.data_type as 'type', c.is_nullable as 'isnull'\");\n    result = result || this.sql.toLowerCase().startsWith('select tablename = t.name, name = ind.name,');\n    result = result || this.sql.toLowerCase().startsWith('exec sys.sp_helpindex @objname');\n\n    return result;\n  }\n\n  isShowIndexesQuery() {\n    return this.sql.toLowerCase().startsWith('exec sys.sp_helpindex @objname');\n  }\n\n  handleShowIndexesQuery(data) {\n    // Group by index name, and collect all fields\n    data = data.reduce((acc, item) => {\n      if (!(item.index_name in acc)) {\n        acc[item.index_name] = item;\n        item.fields = [];\n      }\n\n      item.index_keys.split(',').forEach(column => {\n        let columnName = column.trim();\n        if (columnName.includes('(-)')) {\n          columnName = columnName.replace('(-)', '');\n        }\n\n        acc[item.index_name].fields.push({\n          attribute: columnName,\n          length: undefined,\n          order: column.includes('(-)') ? 'DESC' : 'ASC',\n          collate: undefined\n        });\n      });\n      delete item.index_keys;\n      return acc;\n    }, {});\n\n    return _.map(data, item => ({\n      primary: item.index_name.toLowerCase().startsWith('pk'),\n      fields: item.fields,\n      name: item.index_name,\n      tableName: undefined,\n      unique: item.index_description.toLowerCase().includes('unique'),\n      type: undefined\n    }));\n  }\n\n  handleInsertQuery(results, metaData) {\n    if (this.instance) {\n      // add the inserted row id to the instance\n      const autoIncrementAttribute = this.model.autoIncrementAttribute;\n      let id = null;\n      let autoIncrementAttributeAlias = null;\n\n      if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementAttribute) &&\n        this.model.rawAttributes[autoIncrementAttribute].field !== undefined)\n        autoIncrementAttributeAlias = this.model.rawAttributes[autoIncrementAttribute].field;\n\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementAttribute];\n      id = id || autoIncrementAttributeAlias && results && results[0][autoIncrementAttributeAlias];\n\n      this.instance[autoIncrementAttribute] = id;\n\n      if (this.instance.dataValues) {\n        for (const key in results[0]) {\n          if (Object.prototype.hasOwnProperty.call(results[0], key)) {\n            const record = results[0][key];\n\n            const attr = _.find(this.model.rawAttributes, attribute => attribute.fieldName === key || attribute.field === key);\n\n            this.instance.dataValues[attr && attr.fieldName || key] = record;\n          }\n        }\n      }\n\n    }\n  }\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}