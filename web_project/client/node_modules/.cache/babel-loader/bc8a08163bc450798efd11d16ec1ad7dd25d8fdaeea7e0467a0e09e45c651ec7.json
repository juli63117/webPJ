{"ast":null,"code":"\"use strict\";\n\nconst AbstractConnectionManager = require(\"../abstract/connection-manager\");\nconst sequelizeErrors = require(\"../../errors\");\nconst {\n  logger\n} = require(\"../../utils/logger\");\nconst DataTypes = require(\"../../data-types\").db2;\nconst debug = logger.debugContext(\"connection:db2\");\nconst parserStore = require(\"../parserStore\")(\"db2\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"ibm_db\");\n    this.refreshTypeParser(DataTypes);\n  }\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  async connect(config) {\n    const connectionConfig = {\n      database: config.database,\n      hostname: config.host,\n      port: config.port,\n      uid: config.username,\n      pwd: config.password\n    };\n    if (config.ssl) {\n      connectionConfig[\"security\"] = config.ssl;\n    }\n    if (config.sslcertificate) {\n      connectionConfig[\"SSLServerCertificate\"] = config.sslcertificate;\n    }\n    if (config.dialectOptions) {\n      for (const key of Object.keys(config.dialectOptions)) {\n        connectionConfig[key] = config.dialectOptions[key];\n      }\n    }\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        const connection2 = new this.lib.Database();\n        connection2.lib = this.lib;\n        connection2.open(connectionConfig, error => {\n          if (error) {\n            if (error.message && error.message.includes(\"SQL30081N\")) {\n              return reject(new sequelizeErrors.ConnectionRefusedError(error));\n            }\n            return reject(new sequelizeErrors.ConnectionError(error));\n          }\n          return resolve(connection2);\n        });\n      });\n      return connection;\n    } catch (err) {\n      throw new sequelizeErrors.ConnectionError(err);\n    }\n  }\n  disconnect(connection) {\n    if (connection.connected) {\n      connection.close(error => {\n        if (error) {\n          debug(error);\n        } else {\n          debug(\"connection closed\");\n        }\n      });\n    }\n    return Promise.resolve();\n  }\n  validate(connection) {\n    return connection && connection.connected;\n  }\n  _disconnect(connection) {\n    return this.dialect.connectionManager.disconnect(connection);\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"names":["AbstractConnectionManager","require","sequelizeErrors","logger","DataTypes","db2","debug","debugContext","parserStore","ConnectionManager","constructor","dialect","sequelize","config","port","lib","_loadDialectModule","refreshTypeParser","_typecast","field","next","get","type","options","_refreshTypeParser","dataType","refresh","_clearTypeParser","clear","connect","connectionConfig","database","hostname","host","uid","username","pwd","password","ssl","sslcertificate","dialectOptions","key","Object","keys","connection","Promise","resolve","reject","connection2","Database","open","error","message","includes","ConnectionRefusedError","ConnectionError","err","disconnect","connected","close","validate","_disconnect","connectionManager","module","exports","default"],"sources":["C:\\Users\\teply\\OneDrive\\Рабочий стол\\web_project\\client\\node_modules\\sequelize\\src\\dialects\\db2\\connection-manager.js"],"sourcesContent":["'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst sequelizeErrors = require('../../errors');\nconst { logger } = require('../../utils/logger');\nconst DataTypes = require('../../data-types').db2;\nconst debug = logger.debugContext('connection:db2');\nconst parserStore = require('../parserStore')('db2');\n\n/**\n * DB2 Connection Manager\n *\n * Get connections, validate and disconnect them.\n * AbstractConnectionManager pooling use it to handle DB2 specific connections\n * Use https://github.com/ibmdb/node-ibm_db to connect with DB2 server\n *\n * @private\n */\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('ibm_db');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  /**\n   * Connect with DB2 database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once connection is connected.\n   *\n   * @param {object} config\n   * @returns {Promise<Connection>}\n   * @private\n   */\n  async connect(config) {\n    const connectionConfig = {\n      database: config.database,\n      hostname: config.host,\n      port: config.port,\n      uid: config.username,\n      pwd: config.password\n    };\n\n    if (config.ssl) {\n      connectionConfig['security'] = config.ssl;\n    }\n    if (config.sslcertificate) {\n      connectionConfig['SSLServerCertificate'] = config.sslcertificate;\n    }\n    if (config.dialectOptions) {\n      for (const key of Object.keys(config.dialectOptions)) {\n        connectionConfig[key] = config.dialectOptions[key];\n      }\n    }\n\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        const connection = new this.lib.Database();\n        connection.lib = this.lib;\n        connection.open(connectionConfig, error => {\n          if (error) {\n            if (error.message && error.message.includes('SQL30081N')) {\n              return reject(new sequelizeErrors.ConnectionRefusedError(error));\n            }\n            return reject(new sequelizeErrors.ConnectionError(error));\n          }\n          return resolve(connection);\n        });\n      });\n      return connection;\n    } catch (err) {\n      throw new sequelizeErrors.ConnectionError(err);\n    }\n  }\n\n  disconnect(connection) {\n    // Don't disconnect a connection that is already disconnected\n    if (connection.connected) {\n      connection.close(error => {\n        if (error) { debug(error); }\n        else { debug('connection closed'); }\n      });\n    }\n    return Promise.resolve();\n  }\n\n  validate(connection) {\n    return connection && connection.connected;\n  }\n\n  /**\n   * Call dialect library to disconnect a connection\n   *\n   * @param {Connection} connection\n   * @private\n   * @returns {Promise}\n   */\n  _disconnect(connection) {\n    return this.dialect.connectionManager.disconnect(connection);\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}