{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __markAsModule = target => __defProp(target, \"__esModule\", {\n  value: true\n});\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n__export(exports, {\n  OracleQuery: () => OracleQuery\n});\nconst AbstractQuery = require(\"../abstract/query\");\nconst SequelizeErrors = require(\"../../errors\");\nconst parserStore = require(\"../parserStore\")(\"oracle\");\nconst _ = require(\"lodash\");\nconst Utils = require(\"../../utils\");\nconst {\n  logger\n} = require(\"../../utils/logger\");\nconst debug = logger.debugContext(\"sql:oracle\");\nclass OracleQuery extends AbstractQuery {\n  constructor(connection, sequelize, options) {\n    super(connection, sequelize, options);\n    this.options = _.extend({\n      logging: console.log,\n      plain: false,\n      raw: false\n    }, options || {});\n    this.checkLoggingOption();\n    this.outFormat = options.outFormat || this.sequelize.connectionManager.lib.OBJECT;\n  }\n  getInsertIdField() {\n    return \"id\";\n  }\n  getExecOptions() {\n    const execOpts = {\n      outFormat: this.outFormat,\n      autoCommit: this.autoCommit\n    };\n    const oracledb = this.sequelize.connectionManager.lib;\n    if (this.model && this.isSelectQuery()) {\n      const fInfo = {};\n      const keys = Object.keys(this.model.tableAttributes);\n      for (const key of keys) {\n        const keyValue = this.model.tableAttributes[key];\n        if (keyValue.type.key === \"DECIMAL\") {\n          fInfo[key] = {\n            type: oracledb.STRING\n          };\n        }\n        if (keyValue.type.key === \"BIGINT\") {\n          fInfo[key] = {\n            type: oracledb.STRING\n          };\n        }\n      }\n      if (fInfo) {\n        execOpts.fetchInfo = fInfo;\n      }\n    }\n    return execOpts;\n  }\n  _convertBindAttributes(bindingDictionary, oracledb) {\n    if (this.model && this.options[bindingDictionary]) {\n      const keys = Object.keys(this.model.tableAttributes);\n      for (const key of keys) {\n        const keyValue = this.model.tableAttributes[key];\n        if (keyValue.type.key === \"BIGINT\") {\n          const oldBinding = this.options[bindingDictionary][key];\n          if (oldBinding) {\n            this.options[bindingDictionary][key] = __spreadProps(__spreadValues({}, oldBinding), {\n              type: oracledb.STRING,\n              maxSize: 1e7\n            });\n          }\n        }\n      }\n    }\n  }\n  async run(sql, parameters) {\n    const oracledb = this.sequelize.connectionManager.lib;\n    const complete = this._logQuery(sql, debug, parameters);\n    const outParameters = [];\n    const bindParameters = [];\n    const bindDef = [];\n    if (!sql.match(/END;$/)) {\n      this.sql = sql.replace(/; *$/, \"\");\n    } else {\n      this.sql = sql;\n    }\n    if (this.options.outBindAttributes && (Array.isArray(parameters) || _.isPlainObject(parameters))) {\n      this._convertBindAttributes(\"outBindAttributes\", oracledb);\n      outParameters.push(...Object.values(this.options.outBindAttributes));\n      if (this.isUpsertQuery()) {\n        outParameters.push({\n          dir: oracledb.BIND_OUT\n        });\n      }\n    }\n    this.bindParameters = outParameters;\n    if (Array.isArray(parameters) || _.isPlainObject(parameters)) {\n      if (this.options.executeMany) {\n        this._convertBindAttributes(\"inbindAttributes\", oracledb);\n        bindDef.push(...Object.values(this.options.inbindAttributes));\n        bindDef.push(...outParameters);\n        this.bindParameters = parameters;\n      } else if (this.isRawQuery()) {\n        this.bindParameters = parameters;\n      } else {\n        Object.values(parameters).forEach(value => {\n          bindParameters.push(value);\n        });\n        bindParameters.push(...outParameters);\n        Object.assign(this.bindParameters, bindParameters);\n      }\n    }\n    if (this.sql.startsWith(\"BEGIN TRANSACTION\")) {\n      this.autocommit = false;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith(\"SET AUTOCOMMIT ON\")) {\n      this.autocommit = true;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith(\"SET AUTOCOMMIT OFF\")) {\n      this.autocommit = false;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith(\"DECLARE x NUMBER\")) {\n      if (this.autoCommit === void 0) {\n        if (this.connection.uuid) {\n          this.autoCommit = false;\n        } else {\n          this.autoCommit = true;\n        }\n      }\n      try {\n        await this.connection.execute(this.sql, this.bindParameters, {\n          autoCommit: this.autoCommit\n        });\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith(\"BEGIN\")) {\n      if (this.autoCommit === void 0) {\n        if (this.connection.uuid) {\n          this.autoCommit = false;\n        } else {\n          this.autoCommit = true;\n        }\n      }\n      try {\n        const result = await this.connection.execute(this.sql, this.bindParameters, {\n          outFormat: this.outFormat,\n          autoCommit: this.autoCommit\n        });\n        if (!Array.isArray(result.outBinds)) {\n          return [result.outBinds];\n        }\n        return result.outBinds;\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith(\"COMMIT TRANSACTION\")) {\n      try {\n        await this.connection.commit();\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith(\"ROLLBACK TRANSACTION\")) {\n      try {\n        await this.connection.rollback();\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith(\"SET TRANSACTION\")) {\n      try {\n        await this.connection.execute(this.sql, [], {\n          autoCommit: false\n        });\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.autoCommit === void 0) {\n      if (this.connection.uuid) {\n        this.autoCommit = false;\n      } else {\n        this.autoCommit = true;\n      }\n    }\n    if (\"inputParameters\" in this.options && this.options.inputParameters !== null) {\n      Object.assign(this.bindParameters, this.options.inputParameters);\n    }\n    const execOpts = this.getExecOptions();\n    if (this.options.executeMany && bindDef.length > 0) {\n      execOpts.bindDefs = bindDef;\n    }\n    const executePromise = this.options.executeMany ? this.connection.executeMany(this.sql, this.bindParameters, execOpts) : this.connection.execute(this.sql, this.bindParameters, execOpts);\n    try {\n      const result = await executePromise;\n      return this.formatResults(result);\n    } catch (error) {\n      throw this.formatError(error);\n    } finally {\n      complete();\n    }\n  }\n  static formatBindParameters(sql, values, dialect) {\n    const replacementFunc = (match, key, values2) => {\n      if (values2[key] !== void 0) {\n        return `:${key}`;\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, values];\n  }\n  _getAttributeMap(attrsMap, rawAttributes) {\n    attrsMap = Object.assign(attrsMap, _.reduce(rawAttributes, (mp, _2, key) => {\n      const catalogKey = this.sequelize.queryInterface.queryGenerator.getCatalogName(key);\n      mp[catalogKey] = key;\n      return mp;\n    }, {}));\n  }\n  _processRows(rows) {\n    let result = rows;\n    let attrsMap = {};\n    if (this.sequelize.options.quoteIdentifiers === false) {\n      attrsMap = _.reduce(this.options.attributes, (mp, v) => {\n        if (typeof v === \"object\") {\n          v = v[1];\n        }\n        const catalogv = this.sequelize.queryInterface.queryGenerator.getCatalogName(v);\n        mp[catalogv] = v;\n        return mp;\n      }, {});\n      if (this.model) {\n        this._getAttributeMap(attrsMap, this.model.rawAttributes);\n      }\n      if (this.options.aliasesMapping) {\n        const obj = Object.fromEntries(this.options.aliasesMapping);\n        rows = rows.map(row => _.toPairs(row).reduce((acc, [key, value]) => {\n          const mapping = Object.values(obj).find(element => {\n            const catalogElement = this.sequelize.queryInterface.queryGenerator.getCatalogName(element);\n            return catalogElement === key;\n          });\n          if (mapping) acc[mapping || key] = value;\n          return acc;\n        }, {}));\n      }\n      result = rows.map(row => {\n        return _.mapKeys(row, (value, key) => {\n          const targetAttr = attrsMap[key];\n          if (typeof targetAttr === \"string\" && targetAttr !== key) {\n            return targetAttr;\n          }\n          return key;\n        });\n      });\n    }\n    if (this.model) {\n      result = result.map(row => {\n        return _.mapValues(row, (value, key) => {\n          if (this.model.rawAttributes[key] && this.model.rawAttributes[key].type) {\n            let typeid = this.model.rawAttributes[key].type.toLocaleString();\n            if (this.model.rawAttributes[key].type.key === \"JSON\") {\n              value = JSON.parse(value);\n            }\n            if (typeid.indexOf(\"(\") > -1 && this.model.rawAttributes[key].type.key !== \"BOOLEAN\") {\n              typeid = typeid.substr(0, typeid.indexOf(\"(\"));\n            }\n            const parse = parserStore.get(typeid);\n            if (value !== null & !!parse) {\n              value = parse(value);\n            }\n          }\n          return value;\n        });\n      });\n    }\n    return result;\n  }\n  formatResults(data) {\n    let result = this.instance;\n    if (this.isInsertQuery(data)) {\n      let insertData;\n      if (data.outBinds) {\n        const keys = Object.keys(this.options.outBindAttributes);\n        insertData = data.outBinds;\n        if (this.instance) {\n          insertData = [insertData];\n        }\n        const res = insertData.map(row => {\n          const obj = {};\n          row.forEach((element, index) => {\n            obj[keys[index]] = element[0];\n          });\n          return obj;\n        });\n        insertData = res;\n        if (!this.instance) {\n          result = res;\n        }\n      }\n      this.handleInsertQuery(insertData);\n      return [result, data.rowsAffected];\n    }\n    if (this.isShowTablesQuery()) {\n      result = this.handleShowTablesQuery(data.rows);\n    } else if (this.isDescribeQuery()) {\n      result = {};\n      const table = Object.keys(this.sequelize.models);\n      const modelAttributes = {};\n      if (this.sequelize.models && table.length > 0) {\n        this._getAttributeMap(modelAttributes, this.sequelize.models[table[0]].rawAttributes);\n      }\n      data.rows.forEach(_result => {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", \"\").replace(\"')\", \"\").replace(/'/g, \"\");\n        }\n        if (!(modelAttributes[_result.COLUMN_NAME] in result)) {\n          let key = modelAttributes[_result.COLUMN_NAME];\n          if (!key) {\n            key = _result.COLUMN_NAME;\n          }\n          result[key] = {\n            type: _result.DATA_TYPE.toUpperCase(),\n            allowNull: _result.NULLABLE === \"N\" ? false : true,\n            defaultValue: void 0,\n            primaryKey: _result.CONSTRAINT_TYPE === \"P\"\n          };\n        }\n      });\n    } else if (this.isShowIndexesQuery()) {\n      result = this.handleShowIndexesQuery(data.rows);\n    } else if (this.isSelectQuery()) {\n      const rows = data.rows;\n      const result2 = this._processRows(rows);\n      return this.handleSelectQuery(result2);\n    } else if (this.isCallQuery()) {\n      result = data.rows[0];\n    } else if (this.isUpdateQuery()) {\n      result = [result, data.rowsAffected];\n    } else if (this.isBulkUpdateQuery()) {\n      result = data.rowsAffected;\n    } else if (this.isBulkDeleteQuery()) {\n      result = data.rowsAffected;\n    } else if (this.isVersionQuery()) {\n      const version = data.rows[0].VERSION_FULL;\n      if (version) {\n        const versions = version.split(\".\");\n        result = `${versions[0]}.${versions[1]}.${versions[2]}`;\n      } else {\n        result = \"0.0.0\";\n      }\n    } else if (this.isForeignKeysQuery()) {\n      result = data.rows;\n    } else if (this.isUpsertQuery()) {\n      data = data.outBinds;\n      const keys = Object.keys(this.options.outBindAttributes);\n      const obj = {};\n      for (const k in keys) {\n        obj[keys[k]] = data[k];\n      }\n      obj.isUpdate = data[data.length - 1];\n      data = obj;\n      result = [{\n        isNewRecord: data.isUpdate,\n        value: data\n      }, data.isUpdate == 0];\n    } else if (this.isShowConstraintsQuery()) {\n      result = this.handleShowConstraintsQuery(data);\n    } else if (this.isRawQuery()) {\n      if (data && data.rows) {\n        return [data.rows, data.metaData];\n      }\n      return [data, data];\n    }\n    return result;\n  }\n  handleShowConstraintsQuery(data) {\n    return data.rows.map(result => {\n      const constraint = {};\n      for (const key in result) {\n        constraint[_.camelCase(key)] = result[key].toLowerCase();\n      }\n      return constraint;\n    });\n  }\n  handleShowTablesQuery(results) {\n    return results.map(resultSet => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n  formatError(err) {\n    let match;\n    match = err.message.match(/unique constraint ([\\s\\S]*) violated/);\n    if (match && match.length > 1) {\n      match[1] = match[1].replace(\"(\", \"\").replace(\")\", \"\").split(\".\")[1];\n      const errors = [];\n      let fields = [],\n        message = \"Validation error\",\n        uniqueKey = null;\n      if (this.model) {\n        const uniqueKeys = Object.keys(this.model.uniqueKeys);\n        const currKey = uniqueKeys.find(key => {\n          return key.toUpperCase() === match[1].toUpperCase() || key.toUpperCase() === `\"${match[1].toUpperCase()}\"`;\n        });\n        if (currKey) {\n          uniqueKey = this.model.uniqueKeys[currKey];\n          fields = uniqueKey.fields;\n        }\n        if (uniqueKey && !!uniqueKey.msg) {\n          message = uniqueKey.msg;\n        }\n        fields.forEach(field => {\n          errors.push(new SequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, null));\n        });\n      }\n      return new SequelizeErrors.UniqueConstraintError({\n        message,\n        errors,\n        err,\n        fields\n      });\n    }\n    match = err.message.match(/ORA-02291/) || err.message.match(/ORA-02292/);\n    if (match && match.length > 0) {\n      return new SequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err\n      });\n    }\n    match = err.message.match(/ORA-02443/);\n    if (match && match.length > 0) {\n      return new SequelizeErrors.UnknownConstraintError(match[1]);\n    }\n    return new SequelizeErrors.DatabaseError(err);\n  }\n  isShowIndexesQuery() {\n    return this.sql.indexOf(\"SELECT i.index_name,i.table_name, i.column_name, u.uniqueness\") > -1;\n  }\n  isSelectCountQuery() {\n    return this.sql.toUpperCase().indexOf(\"SELECT COUNT(\") > -1;\n  }\n  handleShowIndexesQuery(data) {\n    const acc = [];\n    data.forEach(indexRecord => {\n      if (!acc[indexRecord.INDEX_NAME]) {\n        acc[indexRecord.INDEX_NAME] = {\n          unique: indexRecord.UNIQUENESS === \"UNIQUE\" ? true : false,\n          primary: indexRecord.CONSTRAINT_TYPE === \"P\",\n          name: indexRecord.INDEX_NAME.toLowerCase(),\n          tableName: indexRecord.TABLE_NAME.toLowerCase(),\n          type: void 0\n        };\n        acc[indexRecord.INDEX_NAME].fields = [];\n      }\n      acc[indexRecord.INDEX_NAME].fields.push({\n        attribute: indexRecord.COLUMN_NAME,\n        length: void 0,\n        order: indexRecord.DESCEND,\n        collate: void 0\n      });\n    });\n    const returnIndexes = [];\n    const accKeys = Object.keys(acc);\n    for (const accKey of accKeys) {\n      const columns = {};\n      columns.fields = acc[accKey].fields;\n      if (acc[accKey].name.match(/sys_c[0-9]*/)) {\n        acc[accKey].name = Utils.nameIndex(columns, acc[accKey].tableName).name;\n      }\n      returnIndexes.push(acc[accKey]);\n    }\n    return returnIndexes;\n  }\n  handleInsertQuery(results, metaData) {\n    if (this.instance && results.length > 0) {\n      if (\"pkReturnVal\" in results[0]) {\n        results[0][this.model.primaryKeyAttribute] = results[0].pkReturnVal;\n        delete results[0].pkReturnVal;\n      }\n      const autoIncrementField = this.model.autoIncrementAttribute;\n      let autoIncrementFieldAlias = null,\n        id = null;\n      if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementField) && this.model.rawAttributes[autoIncrementField].field !== void 0) autoIncrementFieldAlias = this.model.rawAttributes[autoIncrementField].field;\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementField];\n      id = id || autoIncrementFieldAlias && results && results[0][autoIncrementFieldAlias];\n      this.instance[autoIncrementField] = id;\n    }\n  }\n}","map":{"version":3,"names":["__export","exports","OracleQuery","AbstractQuery","require","SequelizeErrors","parserStore","_","Utils","logger","debug","debugContext","constructor","connection","sequelize","options","extend","logging","console","log","plain","raw","checkLoggingOption","outFormat","connectionManager","lib","OBJECT","getInsertIdField","getExecOptions","execOpts","autoCommit","oracledb","model","isSelectQuery","fInfo","keys","Object","tableAttributes","key","keyValue","type","STRING","fetchInfo","_convertBindAttributes","bindingDictionary","oldBinding","__spreadProps","__spreadValues","maxSize","run","sql","parameters","complete","_logQuery","outParameters","bindParameters","bindDef","match","replace","outBindAttributes","Array","isArray","isPlainObject","push","values","isUpsertQuery","dir","BIND_OUT","executeMany","inbindAttributes","isRawQuery","forEach","value","assign","startsWith","autocommit","Promise","resolve","uuid","execute","create","error","formatError","result","outBinds","commit","rollback","inputParameters","length","bindDefs","executePromise","formatResults","formatBindParameters","dialect","replacementFunc","values2","_getAttributeMap","attrsMap","rawAttributes","reduce","mp","_2","catalogKey","queryInterface","queryGenerator","getCatalogName","_processRows","rows","quoteIdentifiers","attributes","v","catalogv","aliasesMapping","obj","fromEntries","map","row","toPairs","acc","mapping","find","element","catalogElement","mapKeys","targetAttr","mapValues","typeid","toLocaleString","JSON","parse","indexOf","substr","get","data","instance","isInsertQuery","insertData","res","index","handleInsertQuery","rowsAffected","isShowTablesQuery","handleShowTablesQuery","isDescribeQuery","table","models","modelAttributes","_result","Default","COLUMN_NAME","DATA_TYPE","toUpperCase","allowNull","NULLABLE","defaultValue","primaryKey","CONSTRAINT_TYPE","isShowIndexesQuery","handleShowIndexesQuery","result2","handleSelectQuery","isCallQuery","isUpdateQuery","isBulkUpdateQuery","isBulkDeleteQuery","isVersionQuery","version","VERSION_FULL","versions","split","isForeignKeysQuery","k","isUpdate","isNewRecord","isShowConstraintsQuery","handleShowConstraintsQuery","metaData","constraint","camelCase","toLowerCase","results","resultSet","tableName","TABLE_NAME","schema","TABLE_SCHEMA","err","message","errors","fields","uniqueKey","uniqueKeys","currKey","msg","field","ValidationErrorItem","getUniqueConstraintErrorMessage","UniqueConstraintError","ForeignKeyConstraintError","parent","UnknownConstraintError","DatabaseError","isSelectCountQuery","indexRecord","INDEX_NAME","unique","UNIQUENESS","primary","name","attribute","order","DESCEND","collate","returnIndexes","accKeys","accKey","columns","nameIndex","primaryKeyAttribute","pkReturnVal","autoIncrementField","autoIncrementAttribute","autoIncrementFieldAlias","id","prototype","hasOwnProperty","call"],"sources":["C:\\Users\\teply\\OneDrive\\Рабочий стол\\web_project\\client\\node_modules\\sequelize\\src\\dialects\\oracle\\query.js"],"sourcesContent":["// Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved\n\n'use strict';\n\nconst AbstractQuery = require('../abstract/query');\nconst SequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('oracle');\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst { logger } = require('../../utils/logger');\n\nconst debug = logger.debugContext('sql:oracle');\n\nexport class OracleQuery extends AbstractQuery {\n  constructor(connection, sequelize, options) {\n    super(connection, sequelize, options);\n    this.options = _.extend(\n      {\n        logging: console.log,\n        plain: false,\n        raw: false\n      },\n      options || {}\n    );\n\n    this.checkLoggingOption();\n    this.outFormat = options.outFormat || this.sequelize.connectionManager.lib.OBJECT;\n  }\n\n  getInsertIdField() {\n    return 'id';\n  }\n\n  getExecOptions() {\n    const execOpts = { outFormat: this.outFormat, autoCommit: this.autoCommit };\n\n    // We set the oracledb\n    const oracledb = this.sequelize.connectionManager.lib;\n\n    if (this.model && this.isSelectQuery()) {\n      const fInfo = {};\n      const keys = Object.keys(this.model.tableAttributes);\n      for (const key of keys) {\n        const keyValue = this.model.tableAttributes[key];\n        if (keyValue.type.key === 'DECIMAL') {\n          fInfo[key] = { type: oracledb.STRING };\n        }\n        // Fetching BIGINT as string since, node-oracledb doesn't support JS BIGINT yet\n        if (keyValue.type.key === 'BIGINT') {\n          fInfo[key] = { type: oracledb.STRING };\n        }\n      }\n      if ( fInfo ) {\n        execOpts.fetchInfo = fInfo;\n      }\n    }\n    return execOpts;\n  }\n\n  /**\n   * convert binding values for unsupported\n   * types in connector library\n   *\n   * @param {string} bindingDictionary a string representing the key to scan\n   * @param {object} oracledb native oracle library\n   * @private\n   */\n  _convertBindAttributes(bindingDictionary, oracledb) {\n    if (this.model && this.options[bindingDictionary]) {\n      // check against model if we have some BIGINT\n      const keys = Object.keys(this.model.tableAttributes);\n      for (const key of keys) {\n        const keyValue = this.model.tableAttributes[key];\n        if (keyValue.type.key === 'BIGINT') {\n          const oldBinding = this.options[bindingDictionary][key];\n          if (oldBinding) {\n            this.options[bindingDictionary][key] = {\n              ...oldBinding,\n              type: oracledb.STRING,\n              maxSize: 10000000 //TOTALLY ARBITRARY Number to prevent query failure\n            };\n          }\n        }\n      }\n    }\n  }\n\n  async run(sql, parameters) {\n    // We set the oracledb\n    const oracledb = this.sequelize.connectionManager.lib;\n    const complete = this._logQuery(sql, debug, parameters);\n    const outParameters = [];\n    const bindParameters = [];\n    const bindDef = [];\n\n    if (!sql.match(/END;$/)) {\n      this.sql = sql.replace(/; *$/, '');\n    } else {\n      this.sql = sql;\n    }\n\n    // When this.options.bindAttributes exists then it is an insertQuery/upsertQuery\n    // So we insert the return bind direction and type\n    if (this.options.outBindAttributes && (Array.isArray(parameters) || _.isPlainObject(parameters))) {\n      this._convertBindAttributes('outBindAttributes', oracledb);\n      outParameters.push(...Object.values(this.options.outBindAttributes));\n      // For upsertQuery we need to push the bindDef for isUpdate\n      if (this.isUpsertQuery()) {\n        outParameters.push({ dir: oracledb.BIND_OUT });\n      }\n    }\n\n    this.bindParameters = outParameters;\n    // construct input binds from parameters for single row insert execute call\n    // ex: [3, 4,...]\n    if (Array.isArray(parameters) || _.isPlainObject(parameters)) {\n      if (this.options.executeMany) {\n        // Constructing BindDefs for ExecuteMany call\n        // Building the bindDef for in and out binds\n        this._convertBindAttributes('inbindAttributes', oracledb);\n        bindDef.push(...Object.values(this.options.inbindAttributes));\n        bindDef.push(...outParameters);\n        this.bindParameters = parameters;\n      } else if (this.isRawQuery()) {\n        this.bindParameters = parameters;\n      } else {\n        Object.values(parameters).forEach(value => {\n          bindParameters.push(value);\n        });\n        bindParameters.push(...outParameters);\n        Object.assign(this.bindParameters, bindParameters);\n      }\n    }\n\n    // TRANSACTION SUPPORT\n    if (this.sql.startsWith('BEGIN TRANSACTION')) {\n      this.autocommit = false;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith('SET AUTOCOMMIT ON')) {\n      this.autocommit = true;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith('SET AUTOCOMMIT OFF')) {\n      this.autocommit = false;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith('DECLARE x NUMBER')) {\n      // Calling a stored procedure for bulkInsert with NO attributes, returns nothing\n      if (this.autoCommit === undefined) {\n        if (this.connection.uuid) {\n          this.autoCommit = false;\n        } else {\n          this.autoCommit = true;\n        }\n      }\n\n      try {\n        await this.connection.execute(this.sql, this.bindParameters, { autoCommit: this.autoCommit });\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith('BEGIN')) {\n      // Call to stored procedures - BEGIN TRANSACTION has been treated before\n      if (this.autoCommit === undefined) {\n        if (this.connection.uuid) {\n          this.autoCommit = false;\n        } else {\n          this.autoCommit = true;\n        }\n      }\n\n      try {\n        const result = await this.connection.execute(this.sql, this.bindParameters, {\n          outFormat: this.outFormat,\n          autoCommit: this.autoCommit\n        });\n        if (!Array.isArray(result.outBinds)) {\n          return [result.outBinds];\n        }\n        return result.outBinds;\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith('COMMIT TRANSACTION')) {\n      try {\n        await this.connection.commit();\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith('ROLLBACK TRANSACTION')) {\n      try {\n        await this.connection.rollback();\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith('SET TRANSACTION')) {\n      try {\n        await this.connection.execute(this.sql, [], { autoCommit: false });\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    // QUERY SUPPORT\n    // As Oracle does everything in transaction, if autoCommit is not defined, we set it to true\n    if (this.autoCommit === undefined) {\n      if (this.connection.uuid) {\n        this.autoCommit = false;\n      } else {\n        this.autoCommit = true;\n      }\n    }\n\n    // inbind parameters added byname. merge them\n    if ('inputParameters' in this.options && this.options.inputParameters !== null) {\n      Object.assign(this.bindParameters, this.options.inputParameters);\n    }\n    const execOpts = this.getExecOptions();\n    if (this.options.executeMany && bindDef.length > 0) {\n      execOpts.bindDefs = bindDef;\n    }\n    const executePromise = this.options.executeMany ? this.connection.executeMany(this.sql, this.bindParameters, execOpts) : this.connection.execute(this.sql, this.bindParameters, execOpts);\n    try {\n      const result = await executePromise;\n      return this.formatResults(result);\n    } catch (error) {\n      throw this.formatError(error);\n    } finally {\n      complete();\n    }\n  }\n\n  /**\n * The parameters to query.run function are built here\n *\n * @param {string} sql\n * @param {Array} values\n * @param {string} dialect\n */\n  static formatBindParameters(sql, values, dialect) {\n\n    const replacementFunc = (match, key, values) => {\n      if (values[key] !== undefined) {\n        return `:${key}`;\n      }\n      return undefined;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n\n    return [sql, values];\n  }\n\n  /**\n   * Building the attribute map by matching the column names received\n   * from DB and the one in rawAttributes\n   * to sequelize format\n   *\n   * @param {object} attrsMap\n   * @param {object} rawAttributes\n   * @private\n   */\n  _getAttributeMap(attrsMap, rawAttributes) {\n    attrsMap = Object.assign(attrsMap, _.reduce(rawAttributes, (mp, _, key) => {\n      const catalogKey = this.sequelize.queryInterface.queryGenerator.getCatalogName(key);\n      mp[catalogKey] = key;\n      return mp;\n    }, {}));\n  }\n\n  /**\n   * Process rows received from the DB.\n   * Use parse function to parse the returned value\n   * to sequelize format\n   *\n   * @param {Array} rows\n   * @private\n   */\n  _processRows(rows) {\n    let result = rows;\n    let attrsMap = {};\n\n    // When quoteIdentifiers is false we need to map the DB column names\n    // To the one in attribute list\n    if (this.sequelize.options.quoteIdentifiers === false) {\n      // Building the attribute map from this.options.attributes\n      // Needed in case of an aggregate function\n      attrsMap = _.reduce(this.options.attributes, (mp, v) => {\n        // Aggregate function is of form\n        // Fn {fn: 'min', min}, so we have the name in index one of the object\n        if (typeof v === 'object') {\n          v = v[1];\n        }\n        const catalogv = this.sequelize.queryInterface.queryGenerator.getCatalogName(v);\n        mp[catalogv] = v;\n        return mp;\n      }, {});\n\n\n      // Building the attribute map by matching the column names received\n      // from DB and the one in model.rawAttributes\n      if (this.model) {\n        this._getAttributeMap(attrsMap, this.model.rawAttributes);\n      }\n\n      // If aliasesmapping exists we update the attribute map\n      if (this.options.aliasesMapping) {\n        const obj = Object.fromEntries(this.options.aliasesMapping);\n        rows = rows\n          .map(row => _.toPairs(row)\n            .reduce((acc, [key, value]) => {\n              const mapping = Object.values(obj).find(element => {\n                const catalogElement = this.sequelize.queryInterface.queryGenerator.getCatalogName(element);\n                return catalogElement === key;\n              });\n              if (mapping)\n                acc[mapping || key] = value;\n              return acc;\n            }, {})\n          );\n      }\n\n      // Modify the keys into the format that sequelize expects\n      result = rows.map(row => {\n        return _.mapKeys(row, (value, key) => {\n          const targetAttr = attrsMap[key];\n          if (typeof targetAttr === 'string' && targetAttr !== key) {\n            return targetAttr;\n          }\n          return key;\n        });\n      });\n    }\n\n    // We parse the value received from the DB based on its datatype\n    if (this.model) {\n      result = result.map(row => {\n        return _.mapValues(row, (value, key) => {\n          if (this.model.rawAttributes[key] && this.model.rawAttributes[key].type) {\n            let typeid = this.model.rawAttributes[key].type.toLocaleString();\n            if (this.model.rawAttributes[key].type.key === 'JSON') {\n              value = JSON.parse(value);\n            }\n            // For some types, the \"name\" of the type is returned with the length, we remove it\n            // For Boolean we skip this because BOOLEAN is mapped to CHAR(1) and we dont' want to\n            // remove the (1) for BOOLEAN\n            if (typeid.indexOf('(') > -1 && this.model.rawAttributes[key].type.key !== 'BOOLEAN') {\n              typeid = typeid.substr(0, typeid.indexOf('('));\n            }\n            const parse = parserStore.get(typeid);\n            if (value !== null & !!parse) {\n              value = parse(value);\n            }\n          }\n          return value;\n        });\n      });\n    }\n\n    return result;\n  }\n\n  /**\n   * High level function that handles the results of a query execution.\n   * Example:\n   * Oracle format :\n   * { rows: //All rows\n     [ [ 'Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production' ],\n       [ 'PL/SQL Release 11.2.0.1.0 - Production' ],\n       [ 'CORE\\t11.2.0.1.0\\tProduction' ],\n       [ 'TNS for 64-bit Windows: Version 11.2.0.1.0 - Production' ],\n       [ 'NLSRTL Version 11.2.0.1.0 - Production' ] ],\n    resultSet: undefined,\n    outBinds: undefined, //Used for dbms_put.line\n    rowsAffected: undefined, //Number of rows affected\n    metaData: [ { name: 'BANNER' } ] }\n  *\n  * @param {Array} data - The result of the query execution.\n  */\n  formatResults(data) {\n    let result = this.instance;\n    if (this.isInsertQuery(data)) {\n      let insertData;\n      if (data.outBinds) {\n        const keys = Object.keys(this.options.outBindAttributes);\n        insertData = data.outBinds;\n        // For one row insert out bind array is 1D array\n        // we convert it to 2D array for uniformity\n        if (this.instance) {\n          insertData = [insertData];\n        }\n        // Mapping the bind parameter to their values\n        const res = insertData.map(row =>{\n          const obj = {};\n          row.forEach((element, index) =>{\n            obj[keys[index]] = element[0];\n          });\n          return obj;\n        });\n        insertData = res;\n        // For bulk insert this.insert is undefined\n        // we map result to res, for one row insert\n        // result needs to be this.instance\n        if (!this.instance) {\n          result = res;\n        }\n      }\n      this.handleInsertQuery(insertData);\n      return [result, data.rowsAffected];\n    }\n    if (this.isShowTablesQuery()) {\n      result = this.handleShowTablesQuery(data.rows);\n    } else if (this.isDescribeQuery()) {\n      result = {};\n      // Getting the table name on which we are doing describe query\n      const table = Object.keys(this.sequelize.models);\n      const modelAttributes = {};\n      // Get the model raw attributes\n      if (this.sequelize.models && table.length > 0) {\n        this._getAttributeMap(modelAttributes, this.sequelize.models[table[0]].rawAttributes);\n      }\n      data.rows.forEach(_result => {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", '')\n            .replace(\"')\", '')\n            .replace(/'/g, ''); /* jshint ignore: line */\n        }\n\n        if (!(modelAttributes[_result.COLUMN_NAME] in result)) {\n          let key = modelAttributes[_result.COLUMN_NAME];\n          if (!key) {\n            key = _result.COLUMN_NAME;\n          }\n\n          result[key] = {\n            type: _result.DATA_TYPE.toUpperCase(),\n            allowNull: _result.NULLABLE === 'N' ? false : true,\n            defaultValue: undefined,\n            primaryKey: _result.CONSTRAINT_TYPE === 'P'\n          };\n        }\n      });\n    } else if (this.isShowIndexesQuery()) {\n      result = this.handleShowIndexesQuery(data.rows);\n    } else if (this.isSelectQuery()) {\n      const rows = data.rows;\n      const result = this._processRows(rows);\n      return this.handleSelectQuery(result);\n    } else if (this.isCallQuery()) {\n      result = data.rows[0];\n    } else if (this.isUpdateQuery()) {\n      result = [result, data.rowsAffected];\n    } else if (this.isBulkUpdateQuery()) {\n      result = data.rowsAffected;\n    } else if (this.isBulkDeleteQuery()) {\n      result = data.rowsAffected;\n    } else if (this.isVersionQuery()) {\n      const version = data.rows[0].VERSION_FULL;\n      if (version) {\n        const versions = version.split('.');\n        result = `${versions[0]}.${versions[1]}.${versions[2]}`;\n      } else {\n        result = '0.0.0';\n      }\n    } else if (this.isForeignKeysQuery()) {\n      result = data.rows;\n    } else if (this.isUpsertQuery()) {\n      // Upsert Query, will return nothing\n      data = data.outBinds;\n      const keys = Object.keys(this.options.outBindAttributes);\n      const obj = {};\n      for (const k in keys) {\n        obj[keys[k]] = data[k];\n      }\n      obj.isUpdate = data[data.length - 1];\n      data = obj;\n      result = [{ isNewRecord: data.isUpdate, value: data }, data.isUpdate == 0];\n    } else if (this.isShowConstraintsQuery()) {\n      result = this.handleShowConstraintsQuery(data);\n    } else if (this.isRawQuery()) {\n      // If data.rows exists then it is a select query\n      // Hence we would have two components\n      // metaData and rows and we return them\n      // as [data.rows, data.metaData]\n      // Else it is result of update/upsert/insert query\n      // and it has no rows so we return [data, data]\n      if (data && data.rows) {\n        return [data.rows, data.metaData];\n      }\n      return [data, data];\n    }\n\n    return result;\n  }\n\n  handleShowConstraintsQuery(data) {\n    // Convert snake_case keys to camelCase as its generated by stored procedure\n    return data.rows.map(result => {\n      const constraint = {};\n      for (const key in result) {\n        constraint[_.camelCase(key)] = result[key].toLowerCase();\n      }\n      return constraint;\n    });\n  }\n\n  handleShowTablesQuery(results) {\n    return results.map(resultSet => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n\n  formatError(err) {\n    let match;\n    // ORA-00001: unique constraint (USER.XXXXXXX) violated\n    match = err.message.match(/unique constraint ([\\s\\S]*) violated/);\n    if (match && match.length > 1) {\n      match[1] = match[1].replace('(', '').replace(')', '').split('.')[1]; // As we get (SEQUELIZE.UNIQNAME), we replace to have UNIQNAME\n      const errors = [];\n      let fields = [],\n        message = 'Validation error',\n        uniqueKey = null;\n\n      if (this.model) {\n        const uniqueKeys = Object.keys(this.model.uniqueKeys);\n\n        const currKey = uniqueKeys.find(key => {\n          // We check directly AND with quotes -> \"a\"\" === a || \"a\" === \"a\"\n          return key.toUpperCase() === match[1].toUpperCase() || key.toUpperCase() === `\"${match[1].toUpperCase()}\"`;\n        });\n\n        if (currKey) {\n          uniqueKey = this.model.uniqueKeys[currKey];\n          fields = uniqueKey.fields;\n        }\n\n        if (uniqueKey && !!uniqueKey.msg) {\n          message = uniqueKey.msg;\n        }\n\n        fields.forEach(field => {\n          errors.push(\n            new SequelizeErrors.ValidationErrorItem(\n              this.getUniqueConstraintErrorMessage(field),\n              'unique violation',\n              field,\n              null\n            )\n          );\n        });\n      }\n\n      return new SequelizeErrors.UniqueConstraintError({\n        message,\n        errors,\n        err,\n        fields\n      });\n    }\n\n    // ORA-02291: integrity constraint (string.string) violated - parent key not found / ORA-02292: integrity constraint (string.string) violated - child record found\n    match = err.message.match(/ORA-02291/) || err.message.match(/ORA-02292/);\n    if (match && match.length > 0) {\n      return new SequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err\n      });\n    }\n\n    // ORA-02443: Cannot drop constraint  - nonexistent constraint\n    match = err.message.match(/ORA-02443/);\n    if (match && match.length > 0) {\n      return new SequelizeErrors.UnknownConstraintError(match[1]);\n    }\n\n    return new SequelizeErrors.DatabaseError(err);\n  }\n\n  isShowIndexesQuery() {\n    return this.sql.indexOf('SELECT i.index_name,i.table_name, i.column_name, u.uniqueness') > -1;\n  }\n\n  isSelectCountQuery() {\n    return this.sql.toUpperCase().indexOf('SELECT COUNT(') > -1;\n  }\n\n  handleShowIndexesQuery(data) {\n    const acc = [];\n\n    // We first treat the datas\n    data.forEach(indexRecord => {\n      // We create the object\n      if (!acc[indexRecord.INDEX_NAME]) {\n        acc[indexRecord.INDEX_NAME] = {\n          unique: indexRecord.UNIQUENESS === 'UNIQUE' ? true : false,\n          primary: indexRecord.CONSTRAINT_TYPE === 'P',\n          name: indexRecord.INDEX_NAME.toLowerCase(),\n          tableName: indexRecord.TABLE_NAME.toLowerCase(),\n          type: undefined\n        };\n        acc[indexRecord.INDEX_NAME].fields = [];\n      }\n\n      // We create the fields\n      acc[indexRecord.INDEX_NAME].fields.push({\n        attribute: indexRecord.COLUMN_NAME,\n        length: undefined,\n        order: indexRecord.DESCEND,\n        collate: undefined\n      });\n    });\n\n    const returnIndexes = [];\n    const accKeys = Object.keys(acc);\n    for (const accKey of accKeys) {\n      const columns = {};\n      columns.fields = acc[accKey].fields;\n      // We are generating index field name in the format sequelize expects\n      // to avoid creating a unique index on auto-generated index name\n      if (acc[accKey].name.match(/sys_c[0-9]*/)) {\n        acc[accKey].name = Utils.nameIndex(columns, acc[accKey].tableName).name;\n      }\n      returnIndexes.push(acc[accKey]);\n    }\n    return returnIndexes;\n  }\n\n  handleInsertQuery(results, metaData) {\n    if (this.instance && results.length > 0) {\n      if ('pkReturnVal' in results[0]) {\n        // The PK of the table is a reserved word (ex : uuid), we have to change the name in the result for the model to find the value correctly\n        results[0][this.model.primaryKeyAttribute] = results[0].pkReturnVal;\n        delete results[0].pkReturnVal;\n      }\n      // add the inserted row id to the instance\n      const autoIncrementField = this.model.autoIncrementAttribute;\n      let autoIncrementFieldAlias = null,\n        id = null;\n\n      if (\n        Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementField) &&\n        this.model.rawAttributes[autoIncrementField].field !== undefined\n      )\n        autoIncrementFieldAlias = this.model.rawAttributes[autoIncrementField].field;\n\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementField];\n      id = id || autoIncrementFieldAlias && results && results[0][autoIncrementFieldAlias];\n\n      this.instance[autoIncrementField] = id;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}