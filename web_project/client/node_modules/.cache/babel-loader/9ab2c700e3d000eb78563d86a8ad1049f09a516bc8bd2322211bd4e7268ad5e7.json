{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst Utils = require(\"../../utils\");\nconst Transaction = require(\"../../transaction\");\nconst _ = require(\"lodash\");\nconst MySqlQueryGenerator = require(\"../mysql/query-generator\");\nconst AbstractQueryGenerator = require(\"../abstract/query-generator\");\nclass SQLiteQueryGenerator extends MySqlQueryGenerator {\n  createSchema() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n  showSchemasQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n  versionQuery() {\n    return \"SELECT sqlite_version() as `version`\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    options = options || {};\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = Object.values(attributes).filter(definition => definition.includes(\"PRIMARY KEY\")).length > 1;\n    const attrArray = [];\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        const dataType = attributes[attr];\n        const containsAutoIncrement = dataType.includes(\"AUTOINCREMENT\");\n        let dataTypeString = dataType;\n        if (dataType.includes(\"PRIMARY KEY\")) {\n          if (dataType.includes(\"INT\")) {\n            dataTypeString = containsAutoIncrement ? \"INTEGER PRIMARY KEY AUTOINCREMENT\" : \"INTEGER PRIMARY KEY\";\n            if (dataType.includes(\" REFERENCES\")) {\n              dataTypeString += dataType.substr(dataType.indexOf(\" REFERENCES\"));\n            }\n          }\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n            if (dataType.includes(\"NOT NULL\")) {\n              dataTypeString = dataType.replace(\" PRIMARY KEY\", \"\");\n            } else {\n              dataTypeString = dataType.replace(\"PRIMARY KEY\", \"NOT NULL\");\n            }\n          }\n        }\n        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);\n      }\n    }\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(\", \");\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(\", \");\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attrStr += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      attrStr += `, PRIMARY KEY (${pkString})`;\n    }\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\n    return this.replaceBooleanDefaults(sql);\n  }\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n      break;\n    }\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n    return hasJsonFunction;\n  }\n  _toJSONValue(value) {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n    if (Array.isArray(value) && value[0] instanceof Date) {\n      return value.map(val => val.toISOString());\n    }\n    return value;\n  }\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n    if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = \"datetime\";\n      }\n    }\n    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n  addColumnQuery(table, key, dataType) {\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, {\n      context: \"addColumn\"\n    });\n    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\n    return this.replaceBooleanDefaults(sql);\n  }\n  showTablesQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, {\n          context: \"UPDATE\"\n        })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, {\n          context: \"UPDATE\"\n        }, bindParam)}`);\n      }\n    }\n    let query;\n    const whereOptions = __spreadProps(__spreadValues({}, options), {\n      bindParam\n    });\n    if (options.limit) {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(\",\")} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit)})`;\n    } else {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(\",\")} ${this.whereQuery(where, whereOptions)}`;\n    }\n    return {\n      query,\n      bind\n    };\n  }\n  truncateTableQuery(tableName, options = {}) {\n    return [`DELETE FROM ${this.quoteTable(tableName)}`, options.restartIdentity ? `; DELETE FROM ${this.quoteTable(\"sqlite_sequence\")} WHERE ${this.quoteIdentifier(\"name\")} = ${Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), \"`\"), \"'\")};` : \"\"].join(\"\");\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    _.defaults(options, this.options);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n    if (options.limit) {\n      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;\n    }\n    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;\n  }\n  attributesToSQL(attributes) {\n    const result = {};\n    for (const name in attributes) {\n      const dataType = attributes[name];\n      const fieldName = dataType.field || name;\n      if (_.isObject(dataType)) {\n        let sql = dataType.type.toString();\n        if (Object.prototype.hasOwnProperty.call(dataType, \"allowNull\") && !dataType.allowNull) {\n          sql += \" NOT NULL\";\n        }\n        if (Utils.defaultValueSchemable(dataType.defaultValue)) {\n          sql += ` DEFAULT ${this.escape(dataType.defaultValue, dataType)}`;\n        }\n        if (dataType.unique === true) {\n          sql += \" UNIQUE\";\n        }\n        if (dataType.primaryKey) {\n          sql += \" PRIMARY KEY\";\n          if (dataType.autoIncrement) {\n            sql += \" AUTOINCREMENT\";\n          }\n        }\n        if (dataType.references) {\n          const referencesTable = this.quoteTable(dataType.references.model);\n          let referencesKey;\n          if (dataType.references.key) {\n            referencesKey = this.quoteIdentifier(dataType.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier(\"id\");\n          }\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n          if (dataType.onDelete) {\n            sql += ` ON DELETE ${dataType.onDelete.toUpperCase()}`;\n          }\n          if (dataType.onUpdate) {\n            sql += ` ON UPDATE ${dataType.onUpdate.toUpperCase()}`;\n          }\n        }\n        result[fieldName] = sql;\n      } else {\n        result[fieldName] = dataType;\n      }\n    }\n    return result;\n  }\n  showIndexesQuery(tableName) {\n    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;\n  }\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;\n    if (constraintName) {\n      sql += ` AND sql LIKE '%${constraintName}%'`;\n    }\n    return `${sql};`;\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;\n  }\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = {\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter,\n      tableName\n    };\n    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;\n  }\n  describeCreateTableQuery(tableName) {\n    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;\n  }\n  removeColumnQuery(tableName, attributes) {\n    attributes = this.attributesToSQL(attributes);\n    let backupTableName;\n    if (typeof tableName === \"object\") {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(\", \");\n    return `${this.createTableQuery(backupTableName, attributes)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};DROP TABLE ${quotedTableName};${this.createTableQuery(tableName, attributes)}INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};DROP TABLE ${quotedBackupTableName};`;\n  }\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\n    let backupTableName;\n    attributes = this.attributesToSQL(attributes);\n    if (typeof tableName === \"object\") {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(\", \");\n    return `${createTableSql.replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`).replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '\"')}`, `CREATE TABLE ${quotedBackupTableName}`)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};DROP TABLE ${quotedTableName};ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\n  }\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n    let backupTableName;\n    attributes = this.attributesToSQL(attributes);\n    if (typeof tableName === \"object\") {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map(attr => attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr)).join(\", \");\n    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(\", \");\n    return `${this.createTableQuery(backupTableName, attributes)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};DROP TABLE ${quotedTableName};${this.createTableQuery(tableName, attributes)}INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};DROP TABLE ${quotedBackupTableName};`;\n  }\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return `BEGIN ${transaction.options.type} TRANSACTION;`;\n  }\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return \"-- SQLite is not able to choose the isolation level REPEATABLE READ.\";\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return \"PRAGMA read_uncommitted = ON;\";\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return \"PRAGMA read_uncommitted = OFF;\";\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return \"-- SQLite's default isolation level is SERIALIZABLE. Nothing to do.\";\n      default:\n        throw new Error(`Unknown isolation level: ${value}`);\n    }\n  }\n  replaceBooleanDefaults(sql) {\n    return sql.replace(/DEFAULT '?false'?/g, \"DEFAULT 0\").replace(/DEFAULT '?true'?/g, \"DEFAULT 1\");\n  }\n  getForeignKeysQuery(tableName) {\n    return `PRAGMA foreign_key_list(${this.quoteTable(this.addSchema(tableName))})`;\n  }\n  tableExistsQuery(tableName) {\n    return `SELECT name FROM sqlite_master WHERE type='table' AND name=${this.escape(this.addSchema(tableName))};`;\n  }\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, \"`\"), \"`\");\n  }\n}\nmodule.exports = SQLiteQueryGenerator;","map":{"version":3,"names":["Utils","require","Transaction","_","MySqlQueryGenerator","AbstractQueryGenerator","SQLiteQueryGenerator","createSchema","showSchemasQuery","versionQuery","createTableQuery","tableName","attributes","options","primaryKeys","needsMultiplePrimaryKeys","Object","values","filter","definition","includes","length","attrArray","attr","prototype","hasOwnProperty","call","dataType","containsAutoIncrement","dataTypeString","substr","indexOf","push","replace","quoteIdentifier","table","quoteTable","attrStr","join","pkString","map","pk","uniqueKeys","each","columns","customIndex","fields","field","sql","replaceBooleanDefaults","booleanValue","value","_checkValidJsonStatement","stmt","jsonFunctionRegex","tokenCaptureRegex","currentIndex","openingBrackets","closingBrackets","hasJsonFunction","hasInvalidToken","string","functionMatches","exec","tokenMatches","capturedToken","Error","_toJSONValue","Date","toISOString","Array","isArray","val","handleSequelizeMethod","smth","factory","prepend","Json","Cast","test","type","addColumnQuery","key","attributesToSQL","context","attribute","showTablesQuery","updateQuery","attrValueHash","where","defaults","removeNullValuesFromHash","omitNull","modelAttributeMap","bind","bindParam","SequelizeMethod","escape","format","query","whereOptions","__spreadProps","__spreadValues","limit","whereQuery","truncateTableQuery","restartIdentity","addTicks","removeTicks","deleteQuery","model","whereClause","getWhereConditions","result","name","fieldName","isObject","toString","allowNull","defaultValueSchemable","defaultValue","unique","primaryKey","autoIncrement","references","referencesTable","referencesKey","onDelete","toUpperCase","onUpdate","showIndexesQuery","showConstraintsQuery","constraintName","removeIndexQuery","indexNameOrAttributes","indexName","underscore","describeTableQuery","schema","schemaDelimiter","_schema","_schemaDelimiter","addSchema","describeCreateTableQuery","removeColumnQuery","backupTableName","quotedTableName","quotedBackupTableName","attributeNames","keys","_alterConstraintQuery","createTableSql","renameColumnQuery","attrNameBefore","attrNameAfter","attributeNamesImport","attributeNamesExport","startTransactionQuery","transaction","parent","setIsolationLevelQuery","ISOLATION_LEVELS","REPEATABLE_READ","READ_UNCOMMITTED","READ_COMMITTED","SERIALIZABLE","getForeignKeysQuery","tableExistsQuery","identifier","force","module","exports"],"sources":["C:\\Users\\teply\\OneDrive\\Рабочий стол\\web_project\\client\\node_modules\\sequelize\\src\\dialects\\sqlite\\query-generator.js"],"sourcesContent":["'use strict';\n\nconst Utils = require('../../utils');\nconst Transaction = require('../../transaction');\nconst _ = require('lodash');\nconst MySqlQueryGenerator = require('../mysql/query-generator');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nclass SQLiteQueryGenerator extends MySqlQueryGenerator {\n  createSchema() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  showSchemasQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  versionQuery() {\n    return 'SELECT sqlite_version() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = options || {};\n\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = Object.values(attributes).filter(definition => definition.includes('PRIMARY KEY')).length > 1;\n    const attrArray = [];\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        const dataType = attributes[attr];\n        const containsAutoIncrement = dataType.includes('AUTOINCREMENT');\n\n        let dataTypeString = dataType;\n        if (dataType.includes('PRIMARY KEY')) {\n          if (dataType.includes('INT')) {\n            // Only INTEGER is allowed for primary key, see https://github.com/sequelize/sequelize/issues/969 (no lenght, unsigned etc)\n            dataTypeString = containsAutoIncrement ? 'INTEGER PRIMARY KEY AUTOINCREMENT' : 'INTEGER PRIMARY KEY';\n\n            if (dataType.includes(' REFERENCES')) {\n              dataTypeString += dataType.substr(dataType.indexOf(' REFERENCES'));\n            }\n          }\n\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n            if (dataType.includes('NOT NULL')) {\n              dataTypeString = dataType.replace(' PRIMARY KEY', '');\n            } else {\n              dataTypeString = dataType.replace('PRIMARY KEY', 'NOT NULL');\n            }\n          }\n        }\n        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attrStr += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attrStr += `, PRIMARY KEY (${pkString})`;\n    }\n\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    // https://sqlite.org/json1.html\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  //sqlite can't cast to datetime so we need to convert date values to their ISO strings\n  _toJSONValue(value) {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n    if (Array.isArray(value) && value[0] instanceof Date) {\n      return value.map(val => val.toISOString());\n    }\n    return value;\n  }\n\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n\n    if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      }\n    }\n\n    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, { context: 'addColumn' });\n    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;\n\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\n\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  showTablesQuery() {\n    return 'SELECT name FROM `sqlite_master` WHERE type=\\'table\\' and name!=\\'sqlite_sequence\\';';\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);\n      }\n    }\n\n    let query;\n    const whereOptions = { ...options, bindParam };\n\n    if (options.limit) {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit)})`;\n    } else {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} ${this.whereQuery(where, whereOptions)}`;\n    }\n\n    return { query, bind };\n  }\n\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `DELETE FROM ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? `; DELETE FROM ${this.quoteTable('sqlite_sequence')} WHERE ${this.quoteIdentifier('name')} = ${Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), '`'), \"'\")};` : ''\n    ].join('');\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    _.defaults(options, this.options);\n\n    let whereClause = this.getWhereConditions(where, null, model, options);\n\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n\n    if (options.limit) {\n      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;\n    }\n\n    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;\n  }\n\n  attributesToSQL(attributes) {\n    const result = {};\n    for (const name in attributes) {\n      const dataType = attributes[name];\n      const fieldName = dataType.field || name;\n\n      if (_.isObject(dataType)) {\n        let sql = dataType.type.toString();\n\n        if (Object.prototype.hasOwnProperty.call(dataType, 'allowNull') && !dataType.allowNull) {\n          sql += ' NOT NULL';\n        }\n\n        if (Utils.defaultValueSchemable(dataType.defaultValue)) {\n          // TODO thoroughly check that DataTypes.NOW will properly\n          // get populated on all databases as DEFAULT value\n          // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP\n          sql += ` DEFAULT ${this.escape(dataType.defaultValue, dataType)}`;\n        }\n\n        if (dataType.unique === true) {\n          sql += ' UNIQUE';\n        }\n\n        if (dataType.primaryKey) {\n          sql += ' PRIMARY KEY';\n\n          if (dataType.autoIncrement) {\n            sql += ' AUTOINCREMENT';\n          }\n        }\n\n        if (dataType.references) {\n          const referencesTable = this.quoteTable(dataType.references.model);\n\n          let referencesKey;\n          if (dataType.references.key) {\n            referencesKey = this.quoteIdentifier(dataType.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier('id');\n          }\n\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n          if (dataType.onDelete) {\n            sql += ` ON DELETE ${dataType.onDelete.toUpperCase()}`;\n          }\n\n          if (dataType.onUpdate) {\n            sql += ` ON UPDATE ${dataType.onUpdate.toUpperCase()}`;\n          }\n\n        }\n\n        result[fieldName] = sql;\n      } else {\n        result[fieldName] = dataType;\n      }\n    }\n\n    return result;\n  }\n\n  showIndexesQuery(tableName) {\n    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;\n  }\n\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;\n\n    if (constraintName) {\n      sql += ` AND sql LIKE '%${constraintName}%'`;\n    }\n\n    return `${sql};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = {\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter,\n      tableName\n    };\n    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;\n  }\n\n  describeCreateTableQuery(tableName) {\n    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;\n  }\n\n  removeColumnQuery(tableName, attributes) {\n\n    attributes = this.attributesToSQL(attributes);\n\n    let backupTableName;\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    // Temporary table cannot work for foreign keys.\n    return `${this.createTableQuery(backupTableName, attributes)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};${\n        this.createTableQuery(tableName, attributes)\n      }INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    return `${createTableSql\n      .replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`)\n      .replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '\"')}`, `CREATE TABLE ${quotedBackupTableName}`)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};`\n      + `ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\n  }\n\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map(attr =>\n      attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr)\n    ).join(', ');\n    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    // Temporary tables don't support foreign keys, so creating a temporary table will not allow foreign keys to be preserved\n    return `${this.createTableQuery(backupTableName, attributes)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};${\n        this.createTableQuery(tableName, attributes)\n      }INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return `BEGIN ${transaction.options.type} TRANSACTION;`;\n  }\n\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return '-- SQLite is not able to choose the isolation level REPEATABLE READ.';\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return 'PRAGMA read_uncommitted = ON;';\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return 'PRAGMA read_uncommitted = OFF;';\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return '-- SQLite\\'s default isolation level is SERIALIZABLE. Nothing to do.';\n      default:\n        throw new Error(`Unknown isolation level: ${value}`);\n    }\n  }\n\n  replaceBooleanDefaults(sql) {\n    return sql.replace(/DEFAULT '?false'?/g, 'DEFAULT 0').replace(/DEFAULT '?true'?/g, 'DEFAULT 1');\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {TableName} tableName  The name of the table.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(tableName) {\n    return `PRAGMA foreign_key_list(${this.quoteTable(this.addSchema(tableName))})`;\n  }\n\n  tableExistsQuery(tableName) {\n    return `SELECT name FROM sqlite_master WHERE type='table' AND name=${this.escape(this.addSchema(tableName))};`;\n  }\n\n  /**\n   * Quote identifier in sql clause\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, '`'), '`');\n  }\n\n}\n\nmodule.exports = SQLiteQueryGenerator;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}