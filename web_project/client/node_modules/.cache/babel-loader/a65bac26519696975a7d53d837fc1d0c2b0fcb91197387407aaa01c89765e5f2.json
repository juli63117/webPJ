{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nconst _ = require(\"lodash\");\nconst Utils = require(\"./utils\");\nconst sequelizeError = require(\"./errors\");\nconst DataTypes = require(\"./data-types\");\nconst BelongsTo = require(\"./associations/belongs-to\");\nconst validator = require(\"./utils/validator-extras\").validator;\nconst {\n  promisify\n} = require(\"util\");\nclass InstanceValidator {\n  constructor(modelInstance, options) {\n    options = __spreadValues({\n      hooks: true\n    }, options);\n    if (options.fields && !options.skip) {\n      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);\n    } else {\n      options.skip = options.skip || [];\n    }\n    this.options = options;\n    this.modelInstance = modelInstance;\n    this.validator = validator;\n    this.errors = [];\n    this.inProgress = false;\n  }\n  async _validate() {\n    if (this.inProgress) throw new Error(\"Validations already in progress.\");\n    this.inProgress = true;\n    await Promise.all([this._perAttributeValidators(), this._customValidators()]);\n    if (this.errors.length) {\n      throw new sequelizeError.ValidationError(null, this.errors);\n    }\n  }\n  async validate() {\n    return await (this.options.hooks ? this._validateAndRunHooks() : this._validate());\n  }\n  async _validateAndRunHooks() {\n    const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);\n    await runHooks(\"beforeValidate\", this.modelInstance, this.options);\n    try {\n      await this._validate();\n    } catch (error) {\n      const newError = await runHooks(\"validationFailed\", this.modelInstance, this.options, error);\n      throw newError || error;\n    }\n    await runHooks(\"afterValidate\", this.modelInstance, this.options);\n    return this.modelInstance;\n  }\n  async _perAttributeValidators() {\n    const validators = [];\n    _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {\n      if (this.options.skip.includes(field)) {\n        return;\n      }\n      const value = this.modelInstance.dataValues[field];\n      if (value instanceof Utils.SequelizeMethod) {\n        return;\n      }\n      if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {\n        this._validateSchema(rawAttribute, field, value);\n      }\n      if (Object.prototype.hasOwnProperty.call(this.modelInstance.validators, field)) {\n        validators.push(this._singleAttrValidate(value, field, rawAttribute.allowNull));\n      }\n    });\n    return await Promise.all(validators);\n  }\n  async _customValidators() {\n    const validators = [];\n    _.each(this.modelInstance.constructor.options.validate, (validator2, validatorType) => {\n      if (this.options.skip.includes(validatorType)) {\n        return;\n      }\n      const valprom = this._invokeCustomValidator(validator2, validatorType).catch(() => {});\n      validators.push(valprom);\n    });\n    return await Promise.all(validators);\n  }\n  async _singleAttrValidate(value, field, allowNull) {\n    if ((value === null || value === void 0) && !allowNull) {\n      return;\n    }\n    const validators = [];\n    _.forIn(this.modelInstance.validators[field], (test, validatorType) => {\n      if ([\"isUrl\", \"isURL\", \"isEmail\"].includes(validatorType)) {\n        if (typeof test === \"object\" && test !== null && test.msg) {\n          test = {\n            msg: test.msg\n          };\n        } else if (test === true) {\n          test = {};\n        }\n      }\n      if (typeof test === \"function\") {\n        validators.push(this._invokeCustomValidator(test, validatorType, true, value, field));\n        return;\n      }\n      if (value === null || value === void 0) {\n        return;\n      }\n      const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field);\n      validatorPromise.catch(() => {});\n      validators.push(validatorPromise);\n    });\n    return Promise.all(validators.map(validator2 => validator2.catch(rejection => {\n      const isBuiltIn = !!rejection.validatorName;\n      this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);\n    })));\n  }\n  async _invokeCustomValidator(validator2, validatorType, optAttrDefined, optValue, optField) {\n    let isAsync = false;\n    const validatorArity = validator2.length;\n    let asyncArity = 1;\n    let errorKey = validatorType;\n    let invokeArgs;\n    if (optAttrDefined) {\n      asyncArity = 2;\n      invokeArgs = optValue;\n      errorKey = optField;\n    }\n    if (validatorArity === asyncArity) {\n      isAsync = true;\n    }\n    if (isAsync) {\n      try {\n        if (optAttrDefined) {\n          return await promisify(validator2.bind(this.modelInstance, invokeArgs))();\n        }\n        return await promisify(validator2.bind(this.modelInstance))();\n      } catch (e) {\n        return this._pushError(false, errorKey, e, optValue, validatorType);\n      }\n    }\n    try {\n      return await validator2.call(this.modelInstance, invokeArgs);\n    } catch (e) {\n      return this._pushError(false, errorKey, e, optValue, validatorType);\n    }\n  }\n  async _invokeBuiltinValidator(value, test, validatorType, field) {\n    const valueString = String(value);\n    if (typeof validator[validatorType] !== \"function\") {\n      throw new Error(`Invalid validator function: ${validatorType}`);\n    }\n    const validatorArgs = this._extractValidatorArgs(test, validatorType, field);\n    if (!validator[validatorType](valueString, ...validatorArgs)) {\n      throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), {\n        validatorName: validatorType,\n        validatorArgs\n      });\n    }\n  }\n  _extractValidatorArgs(test, validatorType, field) {\n    let validatorArgs = test.args || test;\n    const isLocalizedValidator = typeof validatorArgs !== \"string\" && [\"isAlpha\", \"isAlphanumeric\", \"isMobilePhone\"].includes(validatorType);\n    if (!Array.isArray(validatorArgs)) {\n      if (validatorType === \"isImmutable\") {\n        validatorArgs = [validatorArgs, field, this.modelInstance];\n      } else if (isLocalizedValidator || validatorType === \"isIP\") {\n        validatorArgs = [];\n      } else {\n        validatorArgs = [validatorArgs];\n      }\n    } else {\n      validatorArgs = validatorArgs.slice(0);\n    }\n    return validatorArgs;\n  }\n  _validateSchema(rawAttribute, field, value) {\n    if (rawAttribute.allowNull === false && (value === null || value === void 0)) {\n      const association = Object.values(this.modelInstance.constructor.associations).find(association2 => association2 instanceof BelongsTo && association2.foreignKey === rawAttribute.fieldName);\n      if (!association || !this.modelInstance.get(association.associationAccessor)) {\n        const validators = this.modelInstance.validators[field];\n        const errMsg = _.get(validators, \"notNull.msg\", `${this.modelInstance.constructor.name}.${field} cannot be null`);\n        this.errors.push(new sequelizeError.ValidationErrorItem(errMsg, \"notNull Violation\", field, value, this.modelInstance, \"is_null\"));\n      }\n    }\n    if (rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT) {\n      if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {\n        this.errors.push(new sequelizeError.ValidationErrorItem(`${field} cannot be an array or an object`, \"string violation\", field, value, this.modelInstance, \"not_a_string\"));\n      }\n    }\n  }\n  _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {\n    const message = rawError.message || rawError || \"Validation error\";\n    const error = new sequelizeError.ValidationErrorItem(message, \"Validation error\", errorKey, value, this.modelInstance, fnName, isBuiltin ? fnName : void 0, isBuiltin ? fnArgs : void 0);\n    error[InstanceValidator.RAW_KEY_NAME] = rawError;\n    this.errors.push(error);\n  }\n}\nInstanceValidator.RAW_KEY_NAME = \"original\";\nmodule.exports = InstanceValidator;\nmodule.exports.InstanceValidator = InstanceValidator;\nmodule.exports.default = InstanceValidator;","map":{"version":3,"names":["_","require","Utils","sequelizeError","DataTypes","BelongsTo","validator","promisify","InstanceValidator","constructor","modelInstance","options","__spreadValues","hooks","fields","skip","difference","Object","keys","rawAttributes","errors","inProgress","_validate","Error","Promise","all","_perAttributeValidators","_customValidators","length","ValidationError","validate","_validateAndRunHooks","runHooks","bind","error","newError","validators","forIn","rawAttribute","field","includes","value","dataValues","SequelizeMethod","_autoGenerated","autoIncrement","_validateSchema","prototype","hasOwnProperty","call","push","_singleAttrValidate","allowNull","each","validator2","validatorType","valprom","_invokeCustomValidator","catch","test","msg","validatorPromise","_invokeBuiltinValidator","map","rejection","isBuiltIn","validatorName","_pushError","validatorArgs","optAttrDefined","optValue","optField","isAsync","validatorArity","asyncArity","errorKey","invokeArgs","e","valueString","String","_extractValidatorArgs","assign","args","isLocalizedValidator","Array","isArray","slice","association","values","associations","find","association2","foreignKey","fieldName","get","associationAccessor","errMsg","name","ValidationErrorItem","type","STRING","TEXT","CITEXT","isObject","Buffer","isBuffer","isBuiltin","rawError","fnName","fnArgs","message","RAW_KEY_NAME","module","exports","default"],"sources":["C:\\Users\\teply\\OneDrive\\Рабочий стол\\web_project\\client\\node_modules\\sequelize\\src\\instance-validator.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('./utils');\nconst sequelizeError = require('./errors');\nconst DataTypes = require('./data-types');\nconst BelongsTo = require('./associations/belongs-to');\nconst validator = require('./utils/validator-extras').validator;\nconst { promisify } = require('util');\n\n/**\n * Instance Validator.\n *\n * @param {Instance} modelInstance The model instance.\n * @param {object} options A dictionary with options.\n *\n * @private\n */\nclass InstanceValidator {\n  constructor(modelInstance, options) {\n    options = {\n      // assign defined and default options\n      hooks: true,\n      ...options\n    };\n\n    if (options.fields && !options.skip) {\n      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);\n    } else {\n      options.skip = options.skip || [];\n    }\n\n    this.options = options;\n\n    this.modelInstance = modelInstance;\n\n    /**\n     * Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`\n     *\n     * @name validator\n     * @private\n     */\n    this.validator = validator;\n\n    /**\n     *  All errors will be stored here from the validations.\n     *\n     * @type {Array} Will contain keys that correspond to attributes which will\n     *   be Arrays of Errors.\n     * @private\n     */\n    this.errors = [];\n\n    /**\n     * @type {boolean} Indicates if validations are in progress\n     * @private\n     */\n    this.inProgress = false;\n  }\n\n  /**\n   * The main entry point for the Validation module, invoke to start the dance.\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async _validate() {\n    if (this.inProgress) throw new Error('Validations already in progress.');\n\n    this.inProgress = true;\n\n    await Promise.all([\n      this._perAttributeValidators(),\n      this._customValidators()\n    ]);\n\n    if (this.errors.length) {\n      throw new sequelizeError.ValidationError(null, this.errors);\n    }\n  }\n\n  /**\n   * Invoke the Validation sequence and run validation hooks if defined\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async validate() {\n    return await (this.options.hooks ? this._validateAndRunHooks() : this._validate());\n  }\n\n  /**\n   * Invoke the Validation sequence and run hooks\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async _validateAndRunHooks() {\n    const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);\n    await runHooks('beforeValidate', this.modelInstance, this.options);\n\n    try {\n      await this._validate();\n    } catch (error) {\n      const newError = await runHooks('validationFailed', this.modelInstance, this.options, error);\n      throw newError || error;\n    }\n\n    await runHooks('afterValidate', this.modelInstance, this.options);\n    return this.modelInstance;\n  }\n\n  /**\n   * Will run all the validators defined per attribute (built-in validators and custom validators)\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async _perAttributeValidators() {\n    // promisify all attribute invocations\n    const validators = [];\n\n    _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {\n      if (this.options.skip.includes(field)) {\n        return;\n      }\n\n      const value = this.modelInstance.dataValues[field];\n\n      if (value instanceof Utils.SequelizeMethod) {\n        return;\n      }\n\n      if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {\n        // perform validations based on schema\n        this._validateSchema(rawAttribute, field, value);\n      }\n\n      if (Object.prototype.hasOwnProperty.call(this.modelInstance.validators, field)) {\n        validators.push(this._singleAttrValidate(value, field, rawAttribute.allowNull));\n      }\n    });\n\n    return await Promise.all(validators);\n  }\n\n  /**\n   * Will run all the custom validators defined in the model's options.\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async _customValidators() {\n    const validators = [];\n    _.each(this.modelInstance.constructor.options.validate, (validator, validatorType) => {\n      if (this.options.skip.includes(validatorType)) {\n        return;\n      }\n\n      const valprom = this._invokeCustomValidator(validator, validatorType)\n        // errors are handled in settling, stub this\n        .catch(() => {});\n\n      validators.push(valprom);\n    });\n\n    return await Promise.all(validators);\n  }\n\n  /**\n   * Validate a single attribute with all the defined built-in validators and custom validators.\n   *\n   * @private\n   *\n   * @param {*} value Anything.\n   * @param {string} field The field name.\n   * @param {boolean} allowNull Whether or not the schema allows null values\n   *\n   * @returns {Promise} A promise, will always resolve, auto populates error on this.error local object.\n   */\n  async _singleAttrValidate(value, field, allowNull) {\n    // If value is null and allowNull is false, no validators should run (see #9143)\n    if ((value === null || value === undefined) && !allowNull) {\n      // The schema validator (_validateSchema) has already generated the validation error. Nothing to do here.\n      return;\n    }\n\n    // Promisify each validator\n    const validators = [];\n    _.forIn(this.modelInstance.validators[field], (test, validatorType) => {\n\n      if (['isUrl', 'isURL', 'isEmail'].includes(validatorType)) {\n        // Preserve backwards compat. Validator.js now expects the second param to isURL and isEmail to be an object\n        if (typeof test === 'object' && test !== null && test.msg) {\n          test = {\n            msg: test.msg\n          };\n        } else if (test === true) {\n          test = {};\n        }\n      }\n\n      // Custom validators should always run, except if value is null and allowNull is false (see #9143)\n      if (typeof test === 'function') {\n        validators.push(this._invokeCustomValidator(test, validatorType, true, value, field));\n        return;\n      }\n\n      // If value is null, built-in validators should not run (only custom validators have to run) (see #9134).\n      if (value === null || value === undefined) {\n        return;\n      }\n\n      const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field);\n      // errors are handled in settling, stub this\n      validatorPromise.catch(() => {});\n      validators.push(validatorPromise);\n    });\n\n    return Promise\n      .all(validators.map(validator => validator.catch(rejection => {\n        const isBuiltIn = !!rejection.validatorName;\n        this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);\n      })));\n  }\n\n  /**\n   * Prepare and invoke a custom validator.\n   *\n   * @private\n   *\n   * @param {Function} validator The custom validator.\n   * @param {string} validatorType the custom validator type (name).\n   * @param {boolean} optAttrDefined Set to true if custom validator was defined from the attribute\n   * @param {*} optValue value for attribute\n   * @param {string} optField field for attribute\n   *\n   * @returns {Promise} A promise.\n   */\n  async _invokeCustomValidator(validator, validatorType, optAttrDefined, optValue, optField) {\n    let isAsync = false;\n\n    const validatorArity = validator.length;\n    // check if validator is async and requires a callback\n    let asyncArity = 1;\n    let errorKey = validatorType;\n    let invokeArgs;\n    if (optAttrDefined) {\n      asyncArity = 2;\n      invokeArgs = optValue;\n      errorKey = optField;\n    }\n    if (validatorArity === asyncArity) {\n      isAsync = true;\n    }\n\n    if (isAsync) {\n      try {\n        if (optAttrDefined) {\n          return await promisify(validator.bind(this.modelInstance, invokeArgs))();\n        }\n        return await promisify(validator.bind(this.modelInstance))();\n      } catch (e) {\n        return this._pushError(false, errorKey, e, optValue, validatorType);\n      }\n    }\n\n    try {\n      return await validator.call(this.modelInstance, invokeArgs);\n    } catch (e) {\n      return this._pushError(false, errorKey, e, optValue, validatorType);\n    }\n  }\n\n  /**\n   * Prepare and invoke a build-in validator.\n   *\n   * @private\n   *\n   * @param {*} value Anything.\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated\n   *\n   * @returns {object} An object with specific keys to invoke the validator.\n   */\n  async _invokeBuiltinValidator(value, test, validatorType, field) {\n    // Cast value as string to pass new Validator.js string requirement\n    const valueString = String(value);\n    // check if Validator knows that kind of validation test\n    if (typeof validator[validatorType] !== 'function') {\n      throw new Error(`Invalid validator function: ${validatorType}`);\n    }\n\n    const validatorArgs = this._extractValidatorArgs(test, validatorType, field);\n\n    if (!validator[validatorType](valueString, ...validatorArgs)) {\n      throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), { validatorName: validatorType, validatorArgs });\n    }\n  }\n\n  /**\n   * Will extract arguments for the validator.\n   *\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated.\n   *\n   * @private\n   */\n  _extractValidatorArgs(test, validatorType, field) {\n    let validatorArgs = test.args || test;\n    const isLocalizedValidator = typeof validatorArgs !== 'string' && ['isAlpha', 'isAlphanumeric', 'isMobilePhone'].includes(validatorType);\n\n    if (!Array.isArray(validatorArgs)) {\n      if (validatorType === 'isImmutable') {\n        validatorArgs = [validatorArgs, field, this.modelInstance];\n      } else if (isLocalizedValidator || validatorType === 'isIP') {\n        validatorArgs = [];\n      } else {\n        validatorArgs = [validatorArgs];\n      }\n    } else {\n      validatorArgs = validatorArgs.slice(0);\n    }\n    return validatorArgs;\n  }\n\n  /**\n   * Will validate a single field against its schema definition (isnull).\n   *\n   * @param {object} rawAttribute As defined in the Schema.\n   * @param {string} field The field name.\n   * @param {*} value anything.\n   *\n   * @private\n   */\n  _validateSchema(rawAttribute, field, value) {\n    if (rawAttribute.allowNull === false && (value === null || value === undefined)) {\n      const association = Object.values(this.modelInstance.constructor.associations).find(association => association instanceof BelongsTo && association.foreignKey === rawAttribute.fieldName);\n      if (!association || !this.modelInstance.get(association.associationAccessor)) {\n        const validators = this.modelInstance.validators[field];\n        const errMsg = _.get(validators, 'notNull.msg', `${this.modelInstance.constructor.name}.${field} cannot be null`);\n\n        this.errors.push(new sequelizeError.ValidationErrorItem(\n          errMsg,\n          'notNull Violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n          field,\n          value,\n          this.modelInstance,\n          'is_null'\n        ));\n      }\n    }\n\n    if (rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT) {\n      if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {\n        this.errors.push(new sequelizeError.ValidationErrorItem(\n          `${field} cannot be an array or an object`,\n          'string violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n          field,\n          value,\n          this.modelInstance,\n          'not_a_string'\n        ));\n      }\n    }\n  }\n\n  /**\n   * Signs all errors retaining the original.\n   *\n   * @param {boolean}       isBuiltin   - Determines if error is from builtin validator.\n   * @param {string}        errorKey    - name of invalid attribute.\n   * @param {Error|string}  rawError    - The original error.\n   * @param {string|number} value       - The data that triggered the error.\n   * @param {string}        fnName      - Name of the validator, if any\n   * @param {Array}         fnArgs      - Arguments for the validator [function], if any\n   *\n   * @private\n   */\n  _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {\n    const message = rawError.message || rawError || 'Validation error';\n    const error = new sequelizeError.ValidationErrorItem(\n      message,\n      'Validation error', // sequelizeError.ValidationErrorItem.Origins.FUNCTION,\n      errorKey,\n      value,\n      this.modelInstance,\n      fnName,\n      isBuiltin ? fnName : undefined,\n      isBuiltin ? fnArgs : undefined\n    );\n\n    error[InstanceValidator.RAW_KEY_NAME] = rawError;\n\n    this.errors.push(error);\n  }\n}\n/**\n * The error key for arguments as passed by custom validators\n *\n * @type {string}\n * @private\n */\nInstanceValidator.RAW_KEY_NAME = 'original';\n\nmodule.exports = InstanceValidator;\nmodule.exports.InstanceValidator = InstanceValidator;\nmodule.exports.default = InstanceValidator;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}