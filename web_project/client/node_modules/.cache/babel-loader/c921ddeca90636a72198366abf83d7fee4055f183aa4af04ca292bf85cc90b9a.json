{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\nconst Utils = require(\"../../utils\");\nconst AbstractQuery = require(\"../abstract/query\");\nconst QueryTypes = require(\"../../query-types\");\nconst sequelizeErrors = require(\"../../errors\");\nconst parserStore = require(\"../parserStore\")(\"sqlite\");\nconst {\n  logger\n} = require(\"../../utils/logger\");\nconst debug = logger.debugContext(\"sql:sqlite\");\nfunction stringifyIfBigint(value) {\n  if (typeof value === \"bigint\") {\n    return value.toString();\n  }\n  return value;\n}\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return \"lastID\";\n  }\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam[`$${i + 1}`] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, {\n        skipValueReplace: true\n      })[0];\n    } else {\n      bindParam = {};\n      if (typeof values === \"object\") {\n        for (const k of Object.keys(values)) {\n          bindParam[`$${k}`] = values[k];\n        }\n      }\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, {\n        skipValueReplace: true\n      })[0];\n    }\n    return [sql, bindParam];\n  }\n  _collectModels(include, prefix) {\n    const ret = {};\n    if (include) {\n      for (const _include of include) {\n        let key;\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n        ret[key] = _include.model;\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n    return ret;\n  }\n  _handleQueryResponse(metaData, columnTypes, err, results, errStack) {\n    if (err) {\n      err.sql = this.sql;\n      throw this.formatError(err, errStack);\n    }\n    let result = this.instance;\n    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {\n      this.handleInsertQuery(results, metaData);\n      if (!this.instance) {\n        if (metaData.constructor.name === \"Statement\" && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({\n              [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i\n            });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n    if (this.isShowTablesQuery()) {\n      return results.map(row => row.name);\n    }\n    if (this.isShowConstraintsQuery()) {\n      result = results;\n      if (results && results[0] && results[0].sql) {\n        result = this.parseConstraintsFromSql(results[0].sql);\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      if (this.options.raw) {\n        return this.handleSelectQuery(results);\n      }\n      const prefixes = this._collectModels(this.options.include);\n      results = results.map(result2 => {\n        return _.mapValues(result2, (value, name) => {\n          let model;\n          if (name.includes(\".\")) {\n            const lastind = name.lastIndexOf(\".\");\n            model = prefixes[name.substr(0, lastind)];\n            name = name.substr(lastind + 1);\n          } else {\n            model = this.options.model;\n          }\n          const tableName = model.getTableName().toString().replace(/`/g, \"\");\n          const tableTypes = columnTypes[tableName] || {};\n          if (tableTypes && !(name in tableTypes)) {\n            _.forOwn(model.rawAttributes, (attribute, key) => {\n              if (name === key && attribute.field) {\n                name = attribute.field;\n                return false;\n              }\n            });\n          }\n          return Object.prototype.hasOwnProperty.call(tableTypes, name) ? this.applyParsers(tableTypes[name], value) : value;\n        });\n      });\n      return this.handleSelectQuery(results);\n    }\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n    if (this.sql.includes(\"PRAGMA INDEX_LIST\")) {\n      return this.handleShowIndexesQuery(results);\n    }\n    if (this.sql.includes(\"PRAGMA INDEX_INFO\")) {\n      return results;\n    }\n    if (this.sql.includes(\"PRAGMA TABLE_INFO\")) {\n      result = {};\n      let defaultValue;\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          defaultValue = void 0;\n        } else if (_result.dflt_value === \"NULL\") {\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0\n        };\n        if (result[_result.name].type === \"TINYINT(1)\") {\n          result[_result.name].defaultValue = {\n            \"0\": false,\n            \"1\": true\n          }[result[_result.name].defaultValue];\n        }\n        if (typeof result[_result.name].defaultValue === \"string\") {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, \"\");\n        }\n      }\n      return result;\n    }\n    if (this.sql.includes(\"PRAGMA foreign_keys;\")) {\n      return results[0];\n    }\n    if (this.sql.includes(\"PRAGMA foreign_keys\")) {\n      return results;\n    }\n    if (this.sql.includes(\"PRAGMA foreign_key_list\")) {\n      return results;\n    }\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n    if (this.options.type === QueryTypes.VERSION) {\n      return results[0].version;\n    }\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n    if (this.isUpsertQuery()) {\n      return [result, null];\n    }\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n    return result;\n  }\n  async run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n    const complete = this._logQuery(sql, debug, parameters);\n    return new Promise((resolve, reject) => conn.serialize(async () => {\n      const columnTypes = {};\n      const errForStack = new Error();\n      const executeSql = () => {\n        if (sql.startsWith(\"-- \")) {\n          return resolve();\n        }\n        const query = this;\n        function afterExecute(executionError, results) {\n          try {\n            complete();\n            resolve(query._handleQueryResponse(this, columnTypes, executionError, results, errForStack.stack));\n            return;\n          } catch (error) {\n            reject(error);\n          }\n        }\n        if (!parameters) parameters = [];\n        if (_.isPlainObject(parameters)) {\n          const newParameters = Object.create(null);\n          for (const key of Object.keys(parameters)) {\n            newParameters[`${key}`] = stringifyIfBigint(parameters[key]);\n          }\n          parameters = newParameters;\n        } else {\n          parameters = parameters.map(stringifyIfBigint);\n        }\n        conn[method](sql, parameters, afterExecute);\n        return null;\n      };\n      if (this.getDatabaseMethod() === \"all\") {\n        let tableNames = [];\n        if (this.options && this.options.tableNames) {\n          tableNames = this.options.tableNames;\n        } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n          tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n        }\n        tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== \"sqlite_master\");\n        if (!tableNames.length) {\n          return executeSql();\n        }\n        await Promise.all(tableNames.map(tableName => new Promise(resolve2 => {\n          tableName = tableName.replace(/`/g, \"\");\n          columnTypes[tableName] = {};\n          conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\n            if (!err) {\n              for (const result of results) {\n                columnTypes[tableName][result.name] = result.type;\n              }\n            }\n            resolve2();\n          });\n        })));\n      }\n      return executeSql();\n    }));\n  }\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split(\"CONSTRAINT \");\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map(constraintSql => {\n      if (constraintSql.includes(\"REFERENCES\")) {\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(\" \");\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, \"\").split(\", \");\n        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));\n      }\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, \"\");\n      const constraint = constraintSql.split(\" \");\n      if ([\"PRIMARY\", \"FOREIGN\"].includes(constraint[1])) {\n        constraint[1] += \" KEY\";\n      }\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\"/g, \"`\"),\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n    return constraints;\n  }\n  applyParsers(type, value) {\n    if (type.includes(\"(\")) {\n      type = type.substr(0, type.indexOf(\"(\"));\n    }\n    type = type.replace(\"UNSIGNED\", \"\").replace(\"ZEROFILL\", \"\");\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n    if (value !== null && parse) {\n      return parse(value, {\n        timezone: this.sequelize.options.timezone\n      });\n    }\n    return value;\n  }\n  formatError(err, errStack) {\n    switch (err.code) {\n      case \"SQLITE_CONSTRAINT_UNIQUE\":\n      case \"SQLITE_CONSTRAINT_PRIMARYKEY\":\n      case \"SQLITE_CONSTRAINT_TRIGGER\":\n      case \"SQLITE_CONSTRAINT_FOREIGNKEY\":\n      case \"SQLITE_CONSTRAINT\":\n        {\n          if (err.message.includes(\"FOREIGN KEY constraint failed\")) {\n            return new sequelizeErrors.ForeignKeyConstraintError({\n              parent: err,\n              stack: errStack\n            });\n          }\n          let fields = [];\n          let match = err.message.match(/columns (.*?) are/);\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(\", \");\n          } else {\n            match = err.message.match(/UNIQUE constraint failed: (.*)/);\n            if (match !== null && match.length >= 2) {\n              fields = match[1].split(\", \").map(columnWithTable => columnWithTable.split(\".\")[1]);\n            }\n          }\n          const errors = [];\n          let message = \"Validation error\";\n          for (const field of fields) {\n            errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, this.instance && this.instance[field], this.instance, \"not_unique\"));\n          }\n          if (this.model) {\n            _.forOwn(this.model.uniqueKeys, constraint => {\n              if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n                message = constraint.msg;\n                return false;\n              }\n            });\n          }\n          return new sequelizeErrors.UniqueConstraintError({\n            message,\n            errors,\n            parent: err,\n            fields,\n            stack: errStack\n          });\n        }\n      case \"SQLITE_BUSY\":\n        return new sequelizeErrors.TimeoutError(err, {\n          stack: errStack\n        });\n      default:\n        return new sequelizeErrors.DatabaseError(err, {\n          stack: errStack\n        });\n    }\n  }\n  async handleShowIndexesQuery(data) {\n    return Promise.all(data.reverse().map(async item => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      const columns = await this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`);\n      for (const column of columns) {\n        item.fields[column.seqno] = {\n          attribute: column.name,\n          length: void 0,\n          order: void 0\n        };\n      }\n      return item;\n    }));\n  }\n  getDatabaseMethod() {\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes(\"CREATE TEMPORARY TABLE\".toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return \"run\";\n    }\n    return \"all\";\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;","map":{"version":3,"names":["_","require","Utils","AbstractQuery","QueryTypes","sequelizeErrors","parserStore","logger","debug","debugContext","stringifyIfBigint","value","toString","Query","getInsertIdField","formatBindParameters","sql","values","dialect","bindParam","Array","isArray","forEach","v","i","skipValueReplace","k","Object","keys","_collectModels","include","prefix","ret","_include","key","as","model","merge","_handleQueryResponse","metaData","columnTypes","err","results","errStack","formatError","result","instance","isInsertQuery","isUpsertQuery","handleInsertQuery","constructor","name","autoIncrementAttribute","primaryKeyAttribute","rawAttributes","startId","changes","push","field","isShowTablesQuery","map","row","isShowConstraintsQuery","parseConstraintsFromSql","isSelectQuery","options","raw","handleSelectQuery","prefixes","result2","mapValues","includes","lastind","lastIndexOf","substr","tableName","getTableName","replace","tableTypes","forOwn","attribute","prototype","hasOwnProperty","call","applyParsers","isShowOrDescribeQuery","handleShowIndexesQuery","defaultValue","_result","dflt_value","type","allowNull","notnull","primaryKey","pk","BULKUPDATE","BULKDELETE","VERSION","version","RAW","isUpdateQuery","run","parameters","conn","connection","method","getDatabaseMethod","complete","_logQuery","Promise","resolve","reject","serialize","errForStack","Error","executeSql","startsWith","query","afterExecute","executionError","stack","error","isPlainObject","newParameters","create","tableNames","exec","filter","length","all","resolve2","constraints","split","referenceTableName","referenceTableKeys","updateAction","deleteAction","splice","constraintSql","match","referencesRegex","referenceConditions","removeTicks","columnNames","column","constraintCondition","constraint","constraintName","constraintType","indexOf","trim","toUpperCase","parse","get","timezone","sequelize","code","message","ForeignKeyConstraintError","parent","fields","columnWithTable","errors","ValidationErrorItem","getUniqueConstraintErrorMessage","uniqueKeys","isEqual","msg","UniqueConstraintError","TimeoutError","DatabaseError","data","reverse","item","primary","unique","columns","seqno","order","isBulkUpdateQuery","toLowerCase","module","exports","default"],"sources":["C:\\Users\\teply\\OneDrive\\Рабочий стол\\web_project\\client\\node_modules\\sequelize\\src\\dialects\\sqlite\\query.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst AbstractQuery = require('../abstract/query');\nconst QueryTypes = require('../../query-types');\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('sqlite');\nconst { logger } = require('../../utils/logger');\n\nconst debug = logger.debugContext('sql:sqlite');\n\n// sqlite3 currently ignores bigint values, so we have to translate to string for now\n// There's a WIP here: https://github.com/TryGhost/node-sqlite3/pull/1501\nfunction stringifyIfBigint(value) {\n  if (typeof value === 'bigint') {\n    return value.toString();\n  }\n\n  return value;\n}\n\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return 'lastID';\n  }\n\n  /**\n   * rewrite query with parameters.\n   *\n   * @param {string} sql\n   * @param {Array|object} values\n   * @param {string} dialect\n   * @private\n   */\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam[`$${i + 1}`] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    } else {\n      bindParam = {};\n      if (typeof values === 'object') {\n        for (const k of Object.keys(values)) {\n          bindParam[`$${k}`] = values[k];\n        }\n      }\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    }\n    return [sql, bindParam];\n  }\n\n  _collectModels(include, prefix) {\n    const ret = {};\n\n    if (include) {\n      for (const _include of include) {\n        let key;\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n        ret[key] = _include.model;\n\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  _handleQueryResponse(metaData, columnTypes, err, results, errStack) {\n    if (err) {\n      err.sql = this.sql;\n      throw this.formatError(err, errStack);\n    }\n    let result = this.instance;\n\n    // add the inserted row id to the instance\n    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {\n      this.handleInsertQuery(results, metaData);\n      if (!this.instance) {\n        // handle bulkCreate AI primary key\n        if (\n          metaData.constructor.name === 'Statement'\n          && this.model\n          && this.model.autoIncrementAttribute\n          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute\n          && this.model.rawAttributes[this.model.primaryKeyAttribute]\n        ) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n\n    if (this.isShowTablesQuery()) {\n      return results.map(row => row.name);\n    }\n    if (this.isShowConstraintsQuery()) {\n      result = results;\n      if (results && results[0] && results[0].sql) {\n        result = this.parseConstraintsFromSql(results[0].sql);\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      if (this.options.raw) {\n        return this.handleSelectQuery(results);\n      }\n      // This is a map of prefix strings to models, e.g. user.projects -> Project model\n      const prefixes = this._collectModels(this.options.include);\n\n      results = results.map(result => {\n        return _.mapValues(result, (value, name) => {\n          let model;\n          if (name.includes('.')) {\n            const lastind = name.lastIndexOf('.');\n\n            model = prefixes[name.substr(0, lastind)];\n\n            name = name.substr(lastind + 1);\n          } else {\n            model = this.options.model;\n          }\n\n          const tableName = model.getTableName().toString().replace(/`/g, '');\n          const tableTypes = columnTypes[tableName] || {};\n\n          if (tableTypes && !(name in tableTypes)) {\n            // The column is aliased\n            _.forOwn(model.rawAttributes, (attribute, key) => {\n              if (name === key && attribute.field) {\n                name = attribute.field;\n                return false;\n              }\n            });\n          }\n\n          return Object.prototype.hasOwnProperty.call(tableTypes, name)\n            ? this.applyParsers(tableTypes[name], value)\n            : value;\n        });\n      });\n\n      return this.handleSelectQuery(results);\n    }\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA INDEX_LIST')) {\n      return this.handleShowIndexesQuery(results);\n    }\n    if (this.sql.includes('PRAGMA INDEX_INFO')) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA TABLE_INFO')) {\n      // this is the sqlite way of getting the metadata of a table\n      result = {};\n\n      let defaultValue;\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          // Column schema omits any \"DEFAULT ...\"\n          defaultValue = undefined;\n        } else if (_result.dflt_value === 'NULL') {\n          // Column schema is a \"DEFAULT NULL\"\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0\n        };\n\n        if (result[_result.name].type === 'TINYINT(1)') {\n          result[_result.name].defaultValue = { '0': false, '1': true }[result[_result.name].defaultValue];\n        }\n\n        if (typeof result[_result.name].defaultValue === 'string') {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, '');\n        }\n      }\n      return result;\n    }\n    if (this.sql.includes('PRAGMA foreign_keys;')) {\n      return results[0];\n    }\n    if (this.sql.includes('PRAGMA foreign_keys')) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA foreign_key_list')) {\n      return results;\n    }\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n    if (this.options.type === QueryTypes.VERSION) {\n      return results[0].version;\n    }\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n    if (this.isUpsertQuery()) {\n      return [result, null];\n    }\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n    return result;\n  }\n\n  async run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n    const complete = this._logQuery(sql, debug, parameters);\n\n    return new Promise((resolve, reject) => conn.serialize(async () => {\n      const columnTypes = {};\n      const errForStack = new Error();\n      const executeSql = () => {\n        if (sql.startsWith('-- ')) {\n          return resolve();\n        }\n        const query = this;\n        // cannot use arrow function here because the function is bound to the statement\n        function afterExecute(executionError, results) {\n          try {\n            complete();\n            // `this` is passed from sqlite, we have no control over this.\n            // eslint-disable-next-line no-invalid-this\n            resolve(query._handleQueryResponse(this, columnTypes, executionError, results, errForStack.stack));\n            return;\n          } catch (error) {\n            reject(error);\n          }\n        }\n\n        if (!parameters) parameters = [];\n\n        if (_.isPlainObject(parameters)) {\n          const newParameters = Object.create(null);\n          for (const key of Object.keys(parameters)) {\n            newParameters[`${key}`] = stringifyIfBigint(parameters[key]);\n          }\n          parameters = newParameters;\n        } else {\n          parameters = parameters.map(stringifyIfBigint);\n        }\n\n        conn[method](sql, parameters, afterExecute);\n\n        return null;\n      };\n\n      if (this.getDatabaseMethod() === 'all') {\n        let tableNames = [];\n        if (this.options && this.options.tableNames) {\n          tableNames = this.options.tableNames;\n        } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n          tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n        }\n\n        // If we already have the metadata for the table, there's no need to ask for it again\n        tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== 'sqlite_master');\n\n        if (!tableNames.length) {\n          return executeSql();\n        }\n        await Promise.all(tableNames.map(tableName =>\n          new Promise(resolve => {\n            tableName = tableName.replace(/`/g, '');\n            columnTypes[tableName] = {};\n\n            conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\n              if (!err) {\n                for (const result of results) {\n                  columnTypes[tableName][result.name] = result.type;\n                }\n              }\n              resolve();\n            });\n          })));\n      }\n      return executeSql();\n    }));\n  }\n\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split('CONSTRAINT ');\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map(constraintSql => {\n      //Parse foreign key snippets\n      if (constraintSql.includes('REFERENCES')) {\n        //Parse out the constraint condition form sql string\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(' ');\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, '').split(', ');\n        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));\n      }\n\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, '');\n      const constraint = constraintSql.split(' ');\n\n      if (['PRIMARY', 'FOREIGN'].includes(constraint[1])) {\n        constraint[1] += ' KEY';\n      }\n\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\"/g, '`'), //Sqlite returns double quotes for table name\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n\n    return constraints;\n  }\n\n  applyParsers(type, value) {\n    if (type.includes('(')) {\n      // Remove the length part\n      type = type.substr(0, type.indexOf('('));\n    }\n    type = type.replace('UNSIGNED', '').replace('ZEROFILL', '');\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n\n    if (value !== null && parse) {\n      return parse(value, { timezone: this.sequelize.options.timezone });\n    }\n    return value;\n  }\n\n  formatError(err, errStack) {\n\n    switch (err.code) {\n      case 'SQLITE_CONSTRAINT_UNIQUE':\n      case 'SQLITE_CONSTRAINT_PRIMARYKEY':\n      case 'SQLITE_CONSTRAINT_TRIGGER':\n      case 'SQLITE_CONSTRAINT_FOREIGNKEY':\n      case 'SQLITE_CONSTRAINT': {\n        if (err.message.includes('FOREIGN KEY constraint failed')) {\n          return new sequelizeErrors.ForeignKeyConstraintError({\n            parent: err,\n            stack: errStack\n          });\n        }\n\n        let fields = [];\n\n        // Sqlite pre 2.2 behavior - Error: SQLITE_CONSTRAINT: columns x, y are not unique\n        let match = err.message.match(/columns (.*?) are/);\n        if (match !== null && match.length >= 2) {\n          fields = match[1].split(', ');\n        } else {\n\n          // Sqlite post 2.2 behavior - Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: table.x, table.y\n          match = err.message.match(/UNIQUE constraint failed: (.*)/);\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(', ').map(columnWithTable => columnWithTable.split('.')[1]);\n          }\n        }\n\n        const errors = [];\n        let message = 'Validation error';\n\n        for (const field of fields) {\n          errors.push(new sequelizeErrors.ValidationErrorItem(\n            this.getUniqueConstraintErrorMessage(field),\n            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n            field,\n            this.instance && this.instance[field],\n            this.instance,\n            'not_unique'\n          ));\n        }\n\n        if (this.model) {\n          _.forOwn(this.model.uniqueKeys, constraint => {\n            if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n              message = constraint.msg;\n              return false;\n            }\n          });\n        }\n\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n      }\n      case 'SQLITE_BUSY':\n        return new sequelizeErrors.TimeoutError(err, { stack: errStack });\n\n      default:\n        return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n    }\n  }\n\n  async handleShowIndexesQuery(data) {\n    // Sqlite returns indexes so the one that was defined last is returned first. Lets reverse that!\n    return Promise.all(data.reverse().map(async item => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      const columns = await this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`);\n      for (const column of columns) {\n        item.fields[column.seqno] = {\n          attribute: column.name,\n          length: undefined,\n          order: undefined\n        };\n      }\n\n      return item;\n    }));\n  }\n\n  getDatabaseMethod() {\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes('CREATE TEMPORARY TABLE'.toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return 'run';\n    }\n    return 'all';\n  }\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}