{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __markAsModule = target => __defProp(target, \"__esModule\", {\n  value: true\n});\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n__export(exports, {\n  OracleQueryInterface: () => OracleQueryInterface\n});\nconst {\n  QueryInterface\n} = require(\"../abstract/query-interface\");\nconst QueryTypes = require(\"../../query-types\");\nconst _ = require(\"lodash\");\nclass OracleQueryInterface extends QueryInterface {\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    const primaryKeys = Object.values(model.primaryKeys).map(item => item.field);\n    const uniqueKeys = Object.values(model.uniqueKeys).filter(c => c.fields.length > 0).map(c => c.fields);\n    const indexKeys = Object.values(model._indexes).filter(c => c.unique && c.fields.length > 0).map(c => c.fields);\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = [];\n    for (const field of options.updateOnDuplicate) {\n      const uniqueKey = uniqueKeys.find(fields => fields.includes(field));\n      if (uniqueKey) {\n        options.upsertKeys = uniqueKey;\n        break;\n      }\n      const indexKey = indexKeys.find(fields => fields.includes(field));\n      if (indexKey) {\n        options.upsertKeys = indexKey;\n        break;\n      }\n    }\n    if (options.upsertKeys.length === 0 || _.intersection(options.updateOnDuplicate, primaryKeys).length) {\n      options.upsertKeys = primaryKeys;\n    }\n    options.upsertKeys = _.uniq(options.upsertKeys);\n    let whereHasNull = false;\n    primaryKeys.forEach(element => {\n      if (where[element] === null) {\n        whereHasNull = true;\n      }\n    });\n    if (whereHasNull === true) {\n      where = options.upsertKeys.reduce((result, attribute) => {\n        result[attribute] = insertValues[attribute];\n        return result;\n      }, {});\n    }\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    if (sql.bind) {\n      options.bind = void 0;\n    }\n    return await this.sequelize.query(sql, options);\n  }\n}","map":{"version":3,"names":["__export","exports","OracleQueryInterface","QueryInterface","require","QueryTypes","_","upsert","tableName","insertValues","updateValues","where","options","__spreadValues","model","primaryKeys","Object","values","map","item","field","uniqueKeys","filter","c","fields","length","indexKeys","_indexes","unique","type","UPSERT","updateOnDuplicate","keys","upsertKeys","uniqueKey","find","includes","indexKey","intersection","uniq","whereHasNull","forEach","element","reduce","result","attribute","sql","queryGenerator","upsertQuery","bind","sequelize","query"],"sources":["C:\\Users\\teply\\OneDrive\\Рабочий стол\\web_project\\client\\node_modules\\sequelize\\src\\dialects\\oracle\\query-interface.js"],"sourcesContent":["// Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved\n\n'use strict';\nconst { QueryInterface } = require('../abstract/query-interface');\nconst QueryTypes = require('../../query-types');\n\nconst _ = require('lodash');\n/**\n * The interface that Sequelize uses to talk with Oracle database\n */\nexport class OracleQueryInterface extends QueryInterface {\n\n  /**\n   * Upsert\n   *\n   * @param {string} tableName    table to upsert on\n   * @param {object} insertValues values to be inserted, mapped to field name\n   * @param {object} updateValues values to be updated, mapped to field name\n   * @param {object} where        where conditions, which can be used for UPDATE part when INSERT fails\n   * @param {object} options      query options\n   *\n   * @returns {Promise<boolean,?number>} Resolves an array with <created, primaryKey>\n   */\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = { ...options };\n\n    const model = options.model;\n    const primaryKeys = Object.values(model.primaryKeys).map(item => item.field);\n    const uniqueKeys = Object.values(model.uniqueKeys).filter(c => c.fields.length > 0).map(c => c.fields);\n    const indexKeys = Object.values(model._indexes).filter(c => c.unique && c.fields.length > 0).map(c => c.fields);\n\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = [];\n\n    // For fields in updateValues, try to find a constraint or unique index\n    // that includes given field. Only first matching upsert key is used.\n    for (const field of options.updateOnDuplicate) {\n      const uniqueKey = uniqueKeys.find(fields => fields.includes(field));\n      if (uniqueKey) {\n        options.upsertKeys = uniqueKey;\n        break;\n      }\n\n      const indexKey = indexKeys.find(fields => fields.includes(field));\n      if (indexKey) {\n        options.upsertKeys = indexKey;\n        break;\n      }\n    }\n\n    // Always use PK, if no constraint available OR update data contains PK\n    if (\n      options.upsertKeys.length === 0\n      || _.intersection(options.updateOnDuplicate, primaryKeys).length\n    ) {\n      options.upsertKeys = primaryKeys;\n    }\n\n    options.upsertKeys = _.uniq(options.upsertKeys);\n\n    let whereHasNull = false;\n\n    primaryKeys.forEach(element => {\n      if (where[element] === null) {\n        whereHasNull = true;\n      }\n    });\n\n    if (whereHasNull === true) {\n      where = options.upsertKeys.reduce((result, attribute) => {\n        result[attribute] = insertValues[attribute];\n        return result;\n      }, {}); \n    }\n\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    // we need set this to undefined otherwise sequelize would raise an error\n    // Error: Both `sql.bind` and `options.bind` cannot be set at the same time\n    if (sql.bind) {\n      options.bind = undefined;\n    }\n    return await this.sequelize.query(sql, options);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}