{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __markAsModule = target => __defProp(target, \"__esModule\", {\n  value: true\n});\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n__export(exports, {\n  OracleQueryGenerator: () => OracleQueryGenerator\n});\nconst Utils = require(\"../../utils\");\nconst DataTypes = require(\"../../data-types\");\nconst AbstractQueryGenerator = require(\"../abstract/query-generator\");\nconst _ = require(\"lodash\");\nconst util = require(\"util\");\nconst Transaction = require(\"../../transaction\");\nconst ORACLE_RESERVED_WORDS = [\"ACCESS\", \"ADD\", \"ALL\", \"ALTER\", \"AND\", \"ANY\", \"ARRAYLEN\", \"AS\", \"ASC\", \"AUDIT\", \"BETWEEN\", \"BY\", \"CHAR\", \"CHECK\", \"CLUSTER\", \"COLUMN\", \"COMMENT\", \"COMPRESS\", \"CONNECT\", \"CREATE\", \"CURRENT\", \"DATE\", \"DECIMAL\", \"DEFAULT\", \"DELETE\", \"DESC\", \"DISTINCT\", \"DROP\", \"ELSE\", \"EXCLUSIVE\", \"EXISTS\", \"FILE\", \"FLOAT\", \"FOR\", \"FROM\", \"GRANT\", \"GROUP\", \"HAVING\", \"IDENTIFIED\", \"IMMEDIATE\", \"IN\", \"INCREMENT\", \"INDEX\", \"INITIAL\", \"INSERT\", \"INTEGER\", \"INTERSECT\", \"INTO\", \"IS\", \"LEVEL\", \"LIKE\", \"LOCK\", \"LONG\", \"MAXEXTENTS\", \"MINUS\", \"MODE\", \"MODIFY\", \"NOAUDIT\", \"NOCOMPRESS\", \"NOT\", \"NOTFOUND\", \"NOWAIT\", \"NULL\", \"NUMBER\", \"OF\", \"OFFLINE\", \"ON\", \"ONLINE\", \"OPTION\", \"OR\", \"ORDER\", \"PCTFREE\", \"PRIOR\", \"PRIVILEGES\", \"PUBLIC\", \"RAW\", \"RENAME\", \"RESOURCE\", \"REVOKE\", \"ROW\", \"ROWID\", \"ROWLABEL\", \"ROWNUM\", \"ROWS\", \"SELECT\", \"SESSION\", \"SET\", \"SHARE\", \"SIZE\", \"SMALLINT\", \"SQLBUF\", \"START\", \"SUCCESSFUL\", \"SYNONYM\", \"SYSDATE\", \"TABLE\", \"THEN\", \"TO\", \"TRIGGER\", \"UID\", \"UNION\", \"UNIQUE\", \"UPDATE\", \"USER\", \"VALIDATE\", \"VALUES\", \"VARCHAR\", \"VARCHAR2\", \"VIEW\", \"WHENEVER\", \"WHERE\", \"WITH\"];\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nclass OracleQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n  }\n  getCatalogName(value) {\n    if (value) {\n      if (this.options.quoteIdentifiers === false) {\n        const quotedValue = this.quoteIdentifier(value);\n        if (quotedValue === value) {\n          value = value.toUpperCase();\n        }\n      }\n    }\n    return value;\n  }\n  getSchemaNameAndTableName(table) {\n    const tableName = this.getCatalogName(table.tableName || table);\n    const schemaName = this.getCatalogName(table.schema);\n    return [tableName, schemaName];\n  }\n  createSchema(schema) {\n    const quotedSchema = this.quoteIdentifier(schema);\n    return [\"DECLARE\", \"USER_FOUND BOOLEAN := FALSE;\", \"BEGIN\", \" BEGIN\", \"   EXECUTE IMMEDIATE \", this.escape(`CREATE USER ${quotedSchema} IDENTIFIED BY 12345 DEFAULT TABLESPACE USERS`), \";\", \"   EXCEPTION WHEN OTHERS THEN\", \"     IF SQLCODE != -1920 THEN\", \"       RAISE;\", \"     ELSE\", \"       USER_FOUND := TRUE;\", \"     END IF;\", \" END;\", \" IF NOT USER_FOUND THEN\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT \"CONNECT\" TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT CREATE TABLE TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT CREATE VIEW TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT CREATE ANY TRIGGER TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT CREATE ANY PROCEDURE TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT CREATE SEQUENCE TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT CREATE SYNONYM TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`ALTER USER ${quotedSchema} QUOTA UNLIMITED ON USERS`), \";\", \" END IF;\", \"END;\"].join(\" \");\n  }\n  showSchemasQuery() {\n    return `SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE COMMON = ('NO') AND USERNAME != user`;\n  }\n  dropSchema(schema) {\n    return [\"BEGIN\", \"EXECUTE IMMEDIATE \", this.escape(`DROP USER ${this.quoteTable(schema)} CASCADE`), \";\", \"EXCEPTION WHEN OTHERS THEN\", \"  IF SQLCODE != -1918 THEN\", \"    RAISE;\", \"  END IF;\", \"END;\"].join(\" \");\n  }\n  versionQuery() {\n    return \"SELECT VERSION_FULL FROM PRODUCT_COMPONENT_VERSION WHERE PRODUCT LIKE 'Oracle%'\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [],\n      foreignKeys = Object.create(null),\n      attrStr = [],\n      checkStr = [];\n    const values = {\n      table: this.quoteTable(tableName)\n    };\n    for (let attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      attr = this.quoteIdentifier(attr);\n      if (dataType.includes(\"PRIMARY KEY\")) {\n        primaryKeys.push(attr);\n        if (dataType.includes(\"REFERENCES\")) {\n          const match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${attr} ${match[1].replace(/PRIMARY KEY/, \"\")}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${attr} ${dataType.replace(/PRIMARY KEY/, \"\").trim()}`);\n        }\n      } else if (dataType.includes(\"REFERENCES\")) {\n        const match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${attr} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${attr} ${dataType}`);\n      }\n    }\n    values[\"attributes\"] = attrStr.join(\", \");\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(\", \");\n    if (pkString.length > 0) {\n      values.attributes += `,PRIMARY KEY (${pkString})`;\n    }\n    for (const fkey in foreignKeys) {\n      if (!Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) continue;\n      if (foreignKeys[fkey].indexOf(\"ON DELETE NO ACTION\") > -1) {\n        foreignKeys[fkey] = foreignKeys[fkey].replace(\"ON DELETE NO ACTION\", \"\");\n      }\n      values.attributes += `,FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n    }\n    if (checkStr.length > 0) {\n      values.attributes += `, ${checkStr.join(\", \")}`;\n    }\n    if (options && options.indexes && options.indexes.length > 0) {\n      const idxToDelete = [];\n      options.indexes.forEach((index, idx) => {\n        if (\"unique\" in index && (index.unique === true || index.unique.length > 0 && index.unique !== false)) {\n          const fields = index.fields.map(field => {\n            if (typeof field === \"string\") {\n              return field;\n            }\n            return field.attribute;\n          });\n          let canContinue = true;\n          if (options.uniqueKeys) {\n            const keys = Object.keys(options.uniqueKeys);\n            for (let fieldIdx = 0; fieldIdx < keys.length; fieldIdx++) {\n              const currUnique = options.uniqueKeys[keys[fieldIdx]];\n              if (currUnique.fields.length === fields.length) {\n                for (let i = 0; i < currUnique.fields.length; i++) {\n                  const field = currUnique.fields[i];\n                  if (_.includes(fields, field)) {\n                    canContinue = false;\n                  } else {\n                    canContinue = true;\n                    break;\n                  }\n                }\n              }\n            }\n            if (canContinue) {\n              const indexName = \"name\" in index ? index.name : \"\";\n              const constraintToAdd = {\n                name: indexName,\n                fields\n              };\n              if (!(\"uniqueKeys\" in options)) {\n                options.uniqueKeys = {};\n              }\n              options.uniqueKeys[indexName] = constraintToAdd;\n              idxToDelete.push(idx);\n            } else {\n              idxToDelete.push(idx);\n            }\n          }\n        }\n      });\n      idxToDelete.forEach(idx => {\n        options.indexes.splice(idx, 1);\n      });\n    }\n    if (options && !!options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        let canBeUniq = false;\n        primaryKeys.forEach(primaryKey => {\n          primaryKey = primaryKey.replace(/\"/g, \"\");\n          if (!_.includes(columns.fields, primaryKey)) {\n            canBeUniq = true;\n          }\n        });\n        columns.fields.forEach(field => {\n          let currField = \"\";\n          if (!_.isString(field)) {\n            currField = field.attribute.replace(/[.,\"\\s]/g, \"\");\n          } else {\n            currField = field.replace(/[.,\"\\s]/g, \"\");\n          }\n          if (currField in attributes) {\n            if (attributes[currField].toUpperCase().indexOf(\"UNIQUE\") > -1 && canBeUniq) {\n              const attrToReplace = attributes[currField].replace(\"UNIQUE\", \"\");\n              values.attributes = values.attributes.replace(attributes[currField], attrToReplace);\n            }\n          }\n        });\n        if (canBeUniq) {\n          const index = options.uniqueKeys[columns.name];\n          delete options.uniqueKeys[columns.name];\n          indexName = indexName.replace(/[.,\\s]/g, \"\");\n          columns.name = indexName;\n          options.uniqueKeys[indexName] = index;\n          if (indexName.length === 0) {\n            values.attributes += `,UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(\", \")})`;\n          } else {\n            values.attributes += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(\", \")})`;\n          }\n        }\n      });\n    }\n    const query = Utils.joinSQLFragments([\"CREATE TABLE\", values.table, `(${values.attributes})`]);\n    return Utils.joinSQLFragments([\"BEGIN\", \"EXECUTE IMMEDIATE\", `${this.escape(query)};`, \"EXCEPTION WHEN OTHERS THEN\", \"IF SQLCODE != -955 THEN\", \"RAISE;\", \"END IF;\", \"END;\"]);\n  }\n  tableExistsQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    return `SELECT TABLE_NAME FROM ALL_TABLES WHERE TABLE_NAME = ${this.escape(tableName)} AND OWNER = ${table.schema ? this.escape(schemaName) : \"USER\"}`;\n  }\n  describeTableQuery(tableName, schema) {\n    const currTableName = this.getCatalogName(tableName.tableName || tableName);\n    schema = this.getCatalogName(schema);\n    return [\"SELECT atc.COLUMN_NAME, atc.DATA_TYPE, atc.DATA_LENGTH, atc.CHAR_LENGTH, atc.DEFAULT_LENGTH, atc.NULLABLE, ucc.constraint_type \", \"FROM all_tab_columns atc \", \"LEFT OUTER JOIN \", \"(SELECT acc.column_name, acc.table_name, ac.constraint_type FROM all_cons_columns acc INNER JOIN all_constraints ac ON acc.constraint_name = ac.constraint_name) ucc \", \"ON (atc.table_name = ucc.table_name AND atc.COLUMN_NAME = ucc.COLUMN_NAME) \", schema ? `WHERE (atc.OWNER = ${this.escape(schema)}) ` : \"WHERE atc.OWNER = USER \", `AND (atc.TABLE_NAME = ${this.escape(currTableName)})`, \"ORDER BY atc.COLUMN_NAME, CONSTRAINT_TYPE DESC\"].join(\"\");\n  }\n  renameTableQuery(before, after) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(before), \"RENAME TO\", this.quoteTable(after)]);\n  }\n  showConstraintsQuery(table) {\n    const tableName = this.getCatalogName(table.tableName || table);\n    return `SELECT CONSTRAINT_NAME constraint_name FROM user_cons_columns WHERE table_name = ${this.escape(tableName)}`;\n  }\n  showTablesQuery() {\n    return `SELECT owner as table_schema, table_name, 0 as lvl FROM all_tables where OWNER IN(SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE ORACLE_MAINTAINED = 'N')`;\n  }\n  dropTableQuery(tableName) {\n    return Utils.joinSQLFragments([\"BEGIN \", \"EXECUTE IMMEDIATE 'DROP TABLE\", this.quoteTable(tableName), \"CASCADE CONSTRAINTS PURGE';\", \"EXCEPTION WHEN OTHERS THEN\", \" IF SQLCODE != -942 THEN\", \"   RAISE;\", \" END IF;\", \"END;\"]);\n  }\n  addIndexQuery(tableName, attributes, options, rawTablename) {\n    if (typeof tableName !== \"string\" && attributes.name) {\n      attributes.name = `${tableName.schema}.${attributes.name}`;\n    }\n    return super.addIndexQuery(tableName, attributes, options, rawTablename);\n  }\n  addConstraintQuery(tableName, options) {\n    options = options || {};\n    if (options.onUpdate) {\n      delete options.onUpdate;\n    }\n    if (options.onDelete && options.onDelete.toUpperCase() === \"NO ACTION\") {\n      delete options.onDelete;\n    }\n    const constraintSnippet = this.getConstraintSnippet(tableName, options);\n    tableName = this.quoteTable(tableName);\n    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;\n  }\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n    const attribute = Utils.joinSQLFragments([this.quoteIdentifier(key), this.attributeToSQL(dataType, {\n      attributeName: key,\n      context: \"addColumn\"\n    })]);\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(table), \"ADD\", attribute]);\n  }\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP COLUMN\", this.quoteIdentifier(attributeName), \";\"]);\n  }\n  _alterForeignKeyConstraint(definition, table, attributeName) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const attributeNameConstant = this.escape(this.getCatalogName(attributeName));\n    const schemaNameConstant = table.schema ? this.escape(this.getCatalogName(schemaName)) : \"USER\";\n    const tableNameConstant = this.escape(this.getCatalogName(tableName));\n    const getConsNameQuery = [\"SELECT constraint_name INTO cons_name\", \"FROM (\", \"  SELECT DISTINCT cc.owner, cc.table_name, cc.constraint_name, cc.column_name AS cons_columns\", \"  FROM all_cons_columns cc, all_constraints c\", \"  WHERE cc.owner = c.owner\", \"  AND cc.table_name = c.table_name\", \"  AND cc.constraint_name = c.constraint_name\", \"  AND c.constraint_type = 'R'\", \"  GROUP BY cc.owner, cc.table_name, cc.constraint_name, cc.column_name\", \")\", \"WHERE owner =\", schemaNameConstant, \"AND table_name =\", tableNameConstant, \"AND cons_columns =\", attributeNameConstant, \";\"].join(\" \");\n    const secondQuery = Utils.joinSQLFragments([`ALTER TABLE ${this.quoteIdentifier(tableName)}`, \"ADD FOREIGN KEY\", `(${this.quoteIdentifier(attributeName)})`, definition.replace(/.+?(?=REFERENCES)/, \"\")]);\n    return [\"BEGIN\", getConsNameQuery, \"EXCEPTION\", \"WHEN NO_DATA_FOUND THEN\", \" CONS_NAME := NULL;\", \"END;\", \"IF CONS_NAME IS NOT NULL THEN\", ` EXECUTE IMMEDIATE 'ALTER TABLE ${this.quoteTable(table)} DROP CONSTRAINT \"'||CONS_NAME||'\"';`, \"END IF;\", `EXECUTE IMMEDIATE ${this.escape(secondQuery)};`].join(\" \");\n  }\n  _modifyQuery(definition, table, attributeName) {\n    const query = Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(table), \"MODIFY\", this.quoteIdentifier(attributeName), definition]);\n    const secondQuery = query.replace(\"NOT NULL\", \"\").replace(\"NULL\", \"\");\n    return [\"BEGIN\", `EXECUTE IMMEDIATE ${this.escape(query)};`, \"EXCEPTION\", \"WHEN OTHERS THEN\", \" IF SQLCODE = -1442 OR SQLCODE = -1451 THEN\", `   EXECUTE IMMEDIATE ${this.escape(secondQuery)};`, \" ELSE\", \"   RAISE;\", \" END IF;\", \"END;\"].join(\" \");\n  }\n  changeColumnQuery(table, attributes) {\n    const sql = [\"DECLARE\", \"CONS_NAME VARCHAR2(200);\", \"BEGIN\"];\n    for (const attributeName in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attributeName)) continue;\n      const definition = attributes[attributeName];\n      if (definition.match(/REFERENCES/)) {\n        sql.push(this._alterForeignKeyConstraint(definition, table, attributeName));\n      } else {\n        sql.push(this._modifyQuery(definition, table, attributeName));\n      }\n    }\n    sql.push(\"END;\");\n    return sql.join(\" \");\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(newName)}`;\n  }\n  populateInsertQueryReturnIntoBinds(returningModelAttributes, returnTypes, inbindLength, returnAttributes, options) {\n    const oracledb = this.sequelize.connectionManager.lib;\n    const outBindAttributes = Object.create(null);\n    const outbind = [];\n    const outbindParam = this.bindParam(outbind, inbindLength);\n    returningModelAttributes.forEach((element, index) => {\n      if (element.startsWith('\"')) {\n        element = element.substring(1, element.length - 1);\n      }\n      outBindAttributes[element] = Object.assign(returnTypes[index]._getBindDef(oracledb), {\n        dir: oracledb.BIND_OUT\n      });\n      const returnAttribute = `${this.format(void 0, void 0, {\n        context: \"INSERT\"\n      }, outbindParam)}`;\n      returnAttributes.push(returnAttribute);\n    });\n    options.outBindAttributes = outBindAttributes;\n  }\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    const rawAttributes = model.rawAttributes;\n    const updateQuery = this.updateQuery(tableName, updateValues, where, options, rawAttributes);\n    options.bind = updateQuery.bind;\n    const insertQuery = this.insertQuery(tableName, insertValues, rawAttributes, options);\n    const sql = [\"DECLARE \", \"BEGIN \", updateQuery.query ? [updateQuery.query, \"; \", \" IF ( SQL%ROWCOUNT = 0 ) THEN \", insertQuery.query, \" :isUpdate := 0; \", \"ELSE \", \" :isUpdate := 1; \", \" END IF; \"].join(\"\") : [insertQuery.query, \" :isUpdate := 0; \", \"EXCEPTION WHEN OTHERS THEN\", \" IF SQLCODE != -1 THEN\", \"   RAISE;\", \" END IF;\"].join(\"\"), \"END;\"];\n    const query = sql.join(\"\");\n    const result = {\n      query\n    };\n    if (options.bindParam !== false) {\n      result.bind = updateQuery.bind || insertQuery.bind;\n    }\n    return result;\n  }\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n    options = options || {};\n    options.executeMany = true;\n    fieldMappedAttributes = fieldMappedAttributes || {};\n    const tuples = [];\n    const allColumns = {};\n    const inBindBindDefMap = {};\n    const outBindBindDefMap = {};\n    const oracledb = this.sequelize.connectionManager.lib;\n    for (const fieldValueHash of fieldValueHashes) {\n      _.forOwn(fieldValueHash, (value, key) => {\n        allColumns[key] = fieldMappedAttributes[key] && fieldMappedAttributes[key].autoIncrement === true && value === null;\n      });\n    }\n    let inBindPosition;\n    for (const fieldValueHash of fieldValueHashes) {\n      const tuple = [];\n      const inbindParam = options.bindParam === void 0 ? this.bindParam(tuple) : options.bindParam;\n      const tempBindPositions = Object.keys(allColumns).map(key => {\n        if (allColumns[key] === true) {\n          if (fieldValueHash[key] !== null) {\n            throw Error(\"For an auto-increment column either all row must be null or non-null, a mix of null and non-null is not allowed!\");\n          }\n          return \"DEFAULT\";\n        }\n        return this.format(fieldValueHash[key], fieldMappedAttributes[key], {\n          context: \"INSERT\"\n        }, inbindParam);\n      });\n      if (!inBindPosition) {\n        inBindPosition = tempBindPositions;\n      }\n      tuples.push(tuple);\n    }\n    const returnColumn = [];\n    const returnColumnBindPositions = [];\n    const insertColumns = [];\n    for (const key of Object.keys(allColumns)) {\n      if (fieldMappedAttributes[key]) {\n        const bindDef = fieldMappedAttributes[key].type._getBindDef(oracledb);\n        if (allColumns[key]) {\n          bindDef.dir = oracledb.BIND_OUT;\n          outBindBindDefMap[key] = bindDef;\n          returnColumn.push(this.quoteIdentifier(key));\n          returnColumnBindPositions.push(`:${tuples[0].length + returnColumn.length}`);\n        } else {\n          bindDef.dir = oracledb.BIND_IN;\n          inBindBindDefMap[key] = bindDef;\n        }\n      }\n      insertColumns.push(this.quoteIdentifier(key));\n    }\n    let query = Utils.joinSQLFragments([\"INSERT\", \"INTO\", this.quoteTable(tableName), `(${insertColumns.join(\",\")})`, \"VALUES\", `(${inBindPosition})`]);\n    if (returnColumn.length > 0) {\n      options.outBindAttributes = outBindBindDefMap;\n      query = Utils.joinSQLFragments([query, \"RETURNING\", `${returnColumn.join(\",\")}`, \"INTO\", `${returnColumnBindPositions}`]);\n    }\n    const result = {\n      query\n    };\n    result.bind = tuples;\n    options.inbindAttributes = inBindBindDefMap;\n    return result;\n  }\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n  deleteQuery(tableName, where, options, model) {\n    options = options || {};\n    const table = tableName;\n    where = this.getWhereConditions(where, null, model, options);\n    let queryTmpl;\n    if (options.limit) {\n      const whereTmpl = where ? ` AND ${where}` : \"\";\n      queryTmpl = `DELETE FROM ${this.quoteTable(table)} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(table)} WHERE rownum <= ${this.escape(options.limit)}${whereTmpl})`;\n    } else {\n      const whereTmpl = where ? ` WHERE ${where}` : \"\";\n      queryTmpl = `DELETE FROM ${this.quoteTable(table)}${whereTmpl}`;\n    }\n    return queryTmpl;\n  }\n  showIndexesQuery(table) {\n    const [tableName, owner] = this.getSchemaNameAndTableName(table);\n    const sql = [\"SELECT i.index_name,i.table_name, i.column_name, u.uniqueness, i.descend, c.constraint_type \", \"FROM all_ind_columns i \", \"INNER JOIN all_indexes u \", \"ON (u.table_name = i.table_name AND u.index_name = i.index_name) \", \"LEFT OUTER JOIN all_constraints c \", \"ON (c.table_name = i.table_name AND c.index_name = i.index_name) \", `WHERE i.table_name = ${this.escape(tableName)}`, \" AND u.table_owner = \", owner ? this.escape(owner) : \"USER\", \" ORDER BY index_name, column_position\"];\n    return sql.join(\"\");\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return `DROP INDEX ${this.quoteIdentifier(indexName)}`;\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    attribute.onUpdate = \"\";\n    if (attribute.references) {\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log(\"Oracle does not support self referencial constraints, we will remove it but we recommend restructuring your query\");\n        attribute.onDelete = \"\";\n      }\n    }\n    let template;\n    template = attribute.type.toSql ? attribute.type.toSql() : \"\";\n    if (attribute.type instanceof DataTypes.JSON) {\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IS JSON)`;\n      return template;\n    }\n    if (Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.allowNull === false) {\n      template += \" NOT NULL\";\n    }\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IN(${_.map(attribute.values, value => {\n        return this.escape(value);\n      }).join(\", \")}))`;\n      return template;\n    }\n    if (attribute.type instanceof DataTypes.BOOLEAN) {\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IN('1', '0'))`;\n      return template;\n    }\n    if (attribute.autoIncrement) {\n      template = \" NUMBER(*,0) GENERATED BY DEFAULT ON NULL AS IDENTITY\";\n    } else if (attribute.type && attribute.type.key === DataTypes.DOUBLE.key) {\n      template = attribute.type.toSql();\n    } else if (attribute.type) {\n      let unsignedTemplate = \"\";\n      if (attribute.type._unsigned) {\n        attribute.type._unsigned = false;\n        unsignedTemplate += ` check(${this.quoteIdentifier(options.attributeName)} >= 0)`;\n      }\n      template = attribute.type.toString();\n      if (attribute.type && attribute.type !== \"TEXT\" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n        template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n      }\n      if (!attribute.autoIncrement) {\n        if (attribute.allowNull === false) {\n          template += \" NOT NULL\";\n        } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n          template += \" NULL\";\n        }\n      }\n      template += unsignedTemplate;\n    } else {\n      template = \"\";\n    }\n    if (attribute.unique === true && !attribute.primaryKey) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete && attribute.onDelete.toUpperCase() !== \"NO ACTION\") {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {};\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      const attributeName = attribute.field || key;\n      result[attributeName] = this.attributeToSQL(attribute, __spreadValues({\n        attributeName\n      }, options));\n    }\n    return result;\n  }\n  createTrigger() {\n    throwMethodUndefined(\"createTrigger\");\n  }\n  dropTrigger() {\n    throwMethodUndefined(\"dropTrigger\");\n  }\n  renameTrigger() {\n    throwMethodUndefined(\"renameTrigger\");\n  }\n  createFunction() {\n    throwMethodUndefined(\"createFunction\");\n  }\n  dropFunction() {\n    throwMethodUndefined(\"dropFunction\");\n  }\n  renameFunction() {\n    throwMethodUndefined(\"renameFunction\");\n  }\n  getConstraintsOnColumn(table, column) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    column = this.getCatalogName(column);\n    const sql = [\"SELECT CONSTRAINT_NAME FROM user_cons_columns WHERE TABLE_NAME = \", this.escape(tableName), \" and OWNER = \", table.schema ? this.escape(schemaName) : \"USER\", \" and COLUMN_NAME = \", this.escape(column), \" AND POSITION IS NOT NULL ORDER BY POSITION\"].join(\"\");\n    return sql;\n  }\n  getForeignKeysQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const sql = ['SELECT DISTINCT  a.table_name \"tableName\", a.constraint_name \"constraintName\", a.owner \"owner\",  a.column_name \"columnName\",', ' b.table_name \"referencedTableName\", b.column_name \"referencedColumnName\"', \" FROM all_cons_columns a\", \" JOIN all_constraints c ON a.owner = c.owner AND a.constraint_name = c.constraint_name\", \" JOIN all_cons_columns b ON c.owner = b.owner AND c.r_constraint_name = b.constraint_name\", \" WHERE c.constraint_type  = 'R'\", \" AND a.table_name = \", this.escape(tableName), \" AND a.owner = \", table.schema ? this.escape(schemaName) : \"USER\", \" ORDER BY a.table_name, a.constraint_name\"].join(\"\");\n    return sql;\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return this.dropConstraintQuery(tableName, foreignKey);\n  }\n  getPrimaryKeyConstraintQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const sql = [\"SELECT cols.column_name, atc.identity_column \", \"FROM all_constraints cons, all_cons_columns cols \", \"INNER JOIN all_tab_columns atc ON(atc.table_name = cols.table_name AND atc.COLUMN_NAME = cols.COLUMN_NAME )\", \"WHERE cols.table_name = \", this.escape(tableName), \"AND cols.owner = \", table.schema ? this.escape(schemaName) : \"USER \", \"AND cons.constraint_type = 'P' \", \"AND cons.constraint_name = cols.constraint_name \", \"AND cons.owner = cols.owner \", \"ORDER BY cols.table_name, cols.position\"].join(\"\");\n    return sql;\n  }\n  dropConstraintQuery(tableName, constraintName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${constraintName}`;\n  }\n  setIsolationLevelQuery(value, options) {\n    if (options.parent) {\n      return;\n    }\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return \"SET TRANSACTION ISOLATION LEVEL READ COMMITTED;\";\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return \"SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\";\n      default:\n        throw new Error(`isolation level \"${value}\" is not supported`);\n    }\n  }\n  getAliasToken() {\n    return \"\";\n  }\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;\n    }\n    return \"BEGIN TRANSACTION\";\n  }\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n    return \"COMMIT TRANSACTION\";\n  }\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TO SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;\n    }\n    return \"ROLLBACK TRANSACTION\";\n  }\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    let str;\n    if (smth instanceof Utils.Json) {\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n      if (smth.path) {\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n        if (smth.value) {\n          str += util.format(\" = %s\", this.escape(smth.value));\n        }\n        return str;\n      }\n    }\n    if (smth instanceof Utils.Cast) {\n      if (smth.val instanceof Utils.SequelizeMethod) {\n        str = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n        if (smth.type === \"boolean\") {\n          str = `(CASE WHEN ${str}='true' THEN 1 ELSE 0 END)`;\n          return `CAST(${str} AS NUMBER)`;\n        }\n        if (smth.type === \"timestamptz\" && /json_value\\(/.test(str)) {\n          str = str.slice(0, -1);\n          return `${str} RETURNING TIMESTAMP WITH TIME ZONE)`;\n        }\n      }\n    }\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n      break;\n    }\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n    return hasJsonFunction;\n  }\n  jsonPathExtractionQuery(column, path) {\n    let paths = _.toPath(path);\n    const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n    paths = paths.map(subPath => {\n      return /\\D/.test(subPath) ? Utils.addTicks(subPath, '\"') : subPath;\n    });\n    const pathStr = this.escape([\"$\"].concat(paths).join(\".\").replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (__, digit) => `[${digit}]`));\n    return `json_value(${quotedColumn},${pathStr})`;\n  }\n  addLimitAndOffset(options, model) {\n    let fragment = \"\";\n    const offset = options.offset || 0,\n      isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n    let orders = {};\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n    if (options.limit || options.offset) {\n      if (!orders.mainQueryOrder || !orders.mainQueryOrder.length || isSubQuery && (!orders.subQueryOrder || !orders.subQueryOrder.length)) {\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(model.primaryKeyField)}`;\n        fragment += ` ORDER BY ${tablePkFragment}`;\n      }\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n    return fragment;\n  }\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n  quoteIdentifier(identifier, force = false) {\n    const optForceQuote = force;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n    const regExp = /^(([\\w][\\w\\d_]*))$/g;\n    if (optForceQuote !== true && optQuoteIdentifiers === false && regExp.test(rawIdentifier) && !ORACLE_RESERVED_WORDS.includes(rawIdentifier.toUpperCase())) {\n      return rawIdentifier;\n    }\n    return Utils.addTicks(rawIdentifier, '\"');\n  }\n  bindParam(bind, posOffset = 0) {\n    return value => {\n      bind.push(value);\n      return `:${bind.length + posOffset}`;\n    };\n  }\n  authTestQuery() {\n    return \"SELECT 1+1 AS result FROM DUAL\";\n  }\n}\nfunction throwMethodUndefined(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n}","map":{"version":3,"names":["__export","exports","OracleQueryGenerator","Utils","require","DataTypes","AbstractQueryGenerator","_","util","Transaction","ORACLE_RESERVED_WORDS","JSON_FUNCTION_REGEX","JSON_OPERATOR_REGEX","TOKEN_CAPTURE_REGEX","constructor","options","getCatalogName","value","quoteIdentifiers","quotedValue","quoteIdentifier","toUpperCase","getSchemaNameAndTableName","table","tableName","schemaName","schema","createSchema","quotedSchema","escape","join","showSchemasQuery","dropSchema","quoteTable","versionQuery","createTableQuery","attributes","primaryKeys","foreignKeys","Object","create","attrStr","checkStr","values","attr","prototype","hasOwnProperty","call","dataType","includes","push","match","replace","trim","pkString","map","pk","length","fkey","indexOf","indexes","idxToDelete","forEach","index","idx","unique","fields","field","attribute","canContinue","uniqueKeys","keys","fieldIdx","currUnique","i","indexName","name","constraintToAdd","splice","each","columns","canBeUniq","primaryKey","currField","isString","attrToReplace","query","joinSQLFragments","tableExistsQuery","describeTableQuery","currTableName","renameTableQuery","before","after","showConstraintsQuery","showTablesQuery","dropTableQuery","addIndexQuery","rawTablename","addConstraintQuery","onUpdate","onDelete","constraintSnippet","getConstraintSnippet","addColumnQuery","key","attributeToSQL","attributeName","context","removeColumnQuery","_alterForeignKeyConstraint","definition","attributeNameConstant","schemaNameConstant","tableNameConstant","getConsNameQuery","secondQuery","_modifyQuery","changeColumnQuery","sql","renameColumnQuery","attrBefore","newName","populateInsertQueryReturnIntoBinds","returningModelAttributes","returnTypes","inbindLength","returnAttributes","oracledb","sequelize","connectionManager","lib","outBindAttributes","outbind","outbindParam","bindParam","element","startsWith","substring","assign","_getBindDef","dir","BIND_OUT","returnAttribute","format","upsertQuery","insertValues","updateValues","where","model","rawAttributes","updateQuery","bind","insertQuery","result","bulkInsertQuery","fieldValueHashes","fieldMappedAttributes","executeMany","tuples","allColumns","inBindBindDefMap","outBindBindDefMap","fieldValueHash","forOwn","autoIncrement","inBindPosition","tuple","inbindParam","tempBindPositions","Error","returnColumn","returnColumnBindPositions","insertColumns","bindDef","type","BIND_IN","inbindAttributes","truncateTableQuery","deleteQuery","getWhereConditions","queryTmpl","limit","whereTmpl","showIndexesQuery","owner","removeIndexQuery","indexNameOrAttributes","underscore","isPlainObject","references","Model","log","template","toSql","JSON","defaultValueSchemable","defaultValue","allowNull","ENUM","BOOLEAN","DOUBLE","unsignedTemplate","_unsigned","toString","_binary","withoutForeignKeyConstraints","attributesToSQL","__spreadValues","createTrigger","throwMethodUndefined","dropTrigger","renameTrigger","createFunction","dropFunction","renameFunction","getConstraintsOnColumn","column","getForeignKeysQuery","dropForeignKeyQuery","foreignKey","dropConstraintQuery","getPrimaryKeyConstraintQuery","constraintName","setIsolationLevelQuery","parent","ISOLATION_LEVELS","READ_UNCOMMITTED","READ_COMMITTED","REPEATABLE_READ","getAliasToken","startTransactionQuery","transaction","commitTransactionQuery","rollbackTransactionQuery","handleSequelizeMethod","smth","factory","prepend","str","Json","conditions","parseConditionObject","condition","jsonPathExtractionQuery","path","tail","_checkValidJsonStatement","paths","toPath","shift","Cast","val","SequelizeMethod","test","slice","stmt","currentIndex","openingBrackets","closingBrackets","hasJsonFunction","hasInvalidToken","string","substr","functionMatches","exec","operatorMatches","tokenMatches","capturedToken","quotedColumn","isIdentifierQuoted","subPath","addTicks","pathStr","concat","__","digit","addLimitAndOffset","fragment","offset","isSubQuery","hasIncludeWhere","hasIncludeRequired","hasMultiAssociation","orders","order","getQueryOrders","mainQueryOrder","subQueryOrder","tablePkFragment","tableAs","primaryKeyField","booleanValue","identifier","force","optForceQuote","optQuoteIdentifiers","rawIdentifier","removeTicks","regExp","posOffset","authTestQuery","methodName"],"sources":["C:\\Users\\teply\\OneDrive\\Рабочий стол\\web_project\\client\\node_modules\\sequelize\\src\\dialects\\oracle\\query-generator.js"],"sourcesContent":["// Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved\n\n'use strict';\n\nconst Utils = require('../../utils');\nconst DataTypes = require('../../data-types');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst _ = require('lodash');\nconst util = require('util');\nconst Transaction = require('../../transaction');\n\n/**\n * list of reserved words in Oracle DB 21c\n * source: https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-7B72E154-677A-4342-A1EA-C74C1EA928E6\n *\n * @private\n */\nconst ORACLE_RESERVED_WORDS = ['ACCESS', 'ADD', 'ALL', 'ALTER', 'AND', 'ANY', 'ARRAYLEN', 'AS', 'ASC', 'AUDIT', 'BETWEEN', 'BY', 'CHAR', 'CHECK', 'CLUSTER', 'COLUMN', 'COMMENT', 'COMPRESS', 'CONNECT', 'CREATE', 'CURRENT', 'DATE', 'DECIMAL', 'DEFAULT', 'DELETE', 'DESC', 'DISTINCT', 'DROP', 'ELSE', 'EXCLUSIVE', 'EXISTS', 'FILE', 'FLOAT', 'FOR', 'FROM', 'GRANT', 'GROUP', 'HAVING', 'IDENTIFIED', 'IMMEDIATE', 'IN', 'INCREMENT', 'INDEX', 'INITIAL', 'INSERT', 'INTEGER', 'INTERSECT', 'INTO', 'IS', 'LEVEL', 'LIKE', 'LOCK', 'LONG', 'MAXEXTENTS', 'MINUS', 'MODE', 'MODIFY', 'NOAUDIT', 'NOCOMPRESS', 'NOT', 'NOTFOUND', 'NOWAIT', 'NULL', 'NUMBER', 'OF', 'OFFLINE', 'ON', 'ONLINE', 'OPTION', 'OR', 'ORDER', 'PCTFREE', 'PRIOR', 'PRIVILEGES', 'PUBLIC', 'RAW', 'RENAME', 'RESOURCE', 'REVOKE', 'ROW', 'ROWID', 'ROWLABEL', 'ROWNUM', 'ROWS', 'SELECT', 'SESSION', 'SET', 'SHARE', 'SIZE', 'SMALLINT', 'SQLBUF', 'START', 'SUCCESSFUL', 'SYNONYM', 'SYSDATE', 'TABLE', 'THEN', 'TO', 'TRIGGER', 'UID', 'UNION', 'UNIQUE', 'UPDATE', 'USER', 'VALIDATE', 'VALUES', 'VARCHAR', 'VARCHAR2', 'VIEW', 'WHENEVER', 'WHERE', 'WITH'];\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\nexport class OracleQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n  }\n\n  /**\n   * Returns the value as it is stored in the Oracle DB\n   *\n   * @param {string} value\n   */\n  getCatalogName(value) {\n    if (value) {\n      if (this.options.quoteIdentifiers === false) {\n        const quotedValue = this.quoteIdentifier(value);\n        if (quotedValue === value) {\n          value = value.toUpperCase();\n        }\n      }\n    }\n    return value;\n  }\n\n  /**\n   * Returns the tableName and schemaName as it is stored the Oracle DB\n   *\n   * @param {object|string} table\n   */\n  getSchemaNameAndTableName(table) {\n    const tableName = this.getCatalogName(table.tableName || table);\n    const schemaName = this.getCatalogName(table.schema);\n    return [tableName, schemaName];\n  }\n\n  createSchema(schema) {\n    const quotedSchema = this.quoteIdentifier(schema);\n    return [\n      'DECLARE',\n      'USER_FOUND BOOLEAN := FALSE;',\n      'BEGIN',\n      ' BEGIN',\n      '   EXECUTE IMMEDIATE ',\n      this.escape(`CREATE USER ${quotedSchema} IDENTIFIED BY 12345 DEFAULT TABLESPACE USERS`),\n      ';',\n      '   EXCEPTION WHEN OTHERS THEN',\n      '     IF SQLCODE != -1920 THEN',\n      '       RAISE;',\n      '     ELSE',\n      '       USER_FOUND := TRUE;',\n      '     END IF;',\n      ' END;',\n      ' IF NOT USER_FOUND THEN',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT \"CONNECT\" TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE TABLE TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE VIEW TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE ANY TRIGGER TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE ANY PROCEDURE TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE SEQUENCE TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE SYNONYM TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`ALTER USER ${quotedSchema} QUOTA UNLIMITED ON USERS`),\n      ';',\n      ' END IF;',\n      'END;'\n    ].join(' ');\n  }\n\n  showSchemasQuery() {\n    return 'SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE COMMON = (\\'NO\\') AND USERNAME != user';\n  }\n\n  dropSchema(schema) {\n    return [\n      'BEGIN',\n      'EXECUTE IMMEDIATE ',\n      this.escape(`DROP USER ${this.quoteTable(schema)} CASCADE`),\n      ';',\n      'EXCEPTION WHEN OTHERS THEN',\n      '  IF SQLCODE != -1918 THEN',\n      '    RAISE;',\n      '  END IF;',\n      'END;'\n    ].join(' ');\n  }\n\n  versionQuery() {\n    return \"SELECT VERSION_FULL FROM PRODUCT_COMPONENT_VERSION WHERE PRODUCT LIKE 'Oracle%'\";\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [],\n      foreignKeys = Object.create(null),\n      attrStr = [],\n      checkStr = [];\n\n    const values = {\n      table: this.quoteTable(tableName)\n    };\n\n    // Starting by dealing with all attributes\n    for (let attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      attr = this.quoteIdentifier(attr);\n\n      // ORACLE doesn't support inline REFERENCES declarations: move to the end\n      if (dataType.includes('PRIMARY KEY')) {\n        // Primary key\n        primaryKeys.push(attr);\n        if (dataType.includes('REFERENCES')) {\n          const match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${attr} ${match[1].replace(/PRIMARY KEY/, '')}`);\n\n          // match[2] already has foreignKeys in correct format so we don't need to replace\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${attr} ${dataType.replace(/PRIMARY KEY/, '').trim()}`);\n        }\n      } else if (dataType.includes('REFERENCES')) {\n        // Foreign key\n        const match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${attr} ${match[1]}`);\n\n        // match[2] already has foreignKeys in correct format so we don't need to replace\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${attr} ${dataType}`);\n      }\n    }\n\n    values['attributes'] = attrStr.join(', ');\n\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (pkString.length > 0) {\n      values.attributes += `,PRIMARY KEY (${pkString})`;\n    }\n\n    // Dealing with FKs\n    for (const fkey in foreignKeys) {\n      if (!Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) continue; \n      // Oracle default response for FK, doesn't support if defined\n      if (foreignKeys[fkey].indexOf('ON DELETE NO ACTION') > -1) {\n        foreignKeys[fkey] = foreignKeys[fkey].replace('ON DELETE NO ACTION', '');\n      }\n      values.attributes += `,FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n    }\n\n    if (checkStr.length > 0) {\n      values.attributes += `, ${checkStr.join(', ')}`;\n    }\n\n    // Specific case for unique indexes with Oracle, we have to set the constraint on the column, if not, no FK will be possible (ORA-02270: no matching unique or primary key for this column-list)\n    if (options && options.indexes && options.indexes.length > 0) {\n      const idxToDelete = [];\n      options.indexes.forEach((index, idx) => {\n        if ('unique' in index && (index.unique === true || index.unique.length > 0 && index.unique !== false)) {\n          // If unique index, transform to unique constraint on column\n          const fields = index.fields.map(field => {\n            if (typeof field === 'string') {\n              return field;\n            } \n            return field.attribute;\n            \n          });\n\n          // Now we have to be sure that the constraint isn't already declared in uniqueKeys\n          let canContinue = true;\n          if (options.uniqueKeys) {\n            const keys = Object.keys(options.uniqueKeys);\n\n            for (let fieldIdx = 0; fieldIdx < keys.length; fieldIdx++) {\n              const currUnique = options.uniqueKeys[keys[fieldIdx]];\n\n              if (currUnique.fields.length === fields.length) {\n                // lengths are the same, possible same constraint\n                for (let i = 0; i < currUnique.fields.length; i++) {\n                  const field = currUnique.fields[i];\n\n                  if (_.includes(fields, field)) {\n                    canContinue = false;\n                  } else {\n                    // We have at least one different column, even if we found the same columns previously, we let the constraint be created\n                    canContinue = true;\n                    break;\n                  }\n                }\n              }\n            }\n\n            if (canContinue) {\n              const indexName = 'name' in index ? index.name : '';\n              const constraintToAdd = {\n                name: indexName,\n                fields\n              };\n              if (!('uniqueKeys' in options)) {\n                options.uniqueKeys = {};\n              }\n\n              options.uniqueKeys[indexName] = constraintToAdd;\n              idxToDelete.push(idx);\n            } else {\n              // The constraint already exists, we remove it from the list\n              idxToDelete.push(idx);\n            }\n          }\n        }\n      });\n      idxToDelete.forEach(idx => {\n        options.indexes.splice(idx, 1);\n      });\n    }\n\n    if (options && !!options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        let canBeUniq = false;\n\n        // Check if we can create the unique key\n        primaryKeys.forEach(primaryKey => {\n          // We can create an unique constraint if it's not on the primary key AND if it doesn't have unique in its definition\n          // We replace quotes in primary key with ''\n          // Primary key would be a list with double quotes in it so we remove the double quotes\n          primaryKey = primaryKey.replace(/\"/g, '');\n\n          // We check if the unique indexes are already a part of primary key or not\n          // If it is not then we set canbeuniq to true and add a unique constraint to these fields.\n          // Else we can ignore unique constraint on these\n          if (!_.includes(columns.fields, primaryKey)) {\n            canBeUniq = true;\n          }\n        });\n\n        columns.fields.forEach(field => {\n          let currField = '';\n          if (!_.isString(field)) {\n            currField = field.attribute.replace(/[.,\"\\s]/g, '');\n          } else {\n            currField = field.replace(/[.,\"\\s]/g, '');\n          }\n          if (currField in attributes) {\n            // If canBeUniq is false we need not replace the UNIQUE for the attribute\n            // So we replace UNIQUE with '' only if there exists a primary key\n            if (attributes[currField].toUpperCase().indexOf('UNIQUE') > -1 && canBeUniq) {\n              // We generate the attribute without UNIQUE\n              const attrToReplace = attributes[currField].replace('UNIQUE', '');\n              // We replace in the final string\n              values.attributes = values.attributes.replace(attributes[currField], attrToReplace);\n            }\n          }\n        });\n\n        // Oracle cannot have an unique AND a primary key on the same fields, prior to the primary key\n        if (canBeUniq) {\n          const index = options.uniqueKeys[columns.name];\n          delete options.uniqueKeys[columns.name];\n          indexName = indexName.replace(/[.,\\s]/g, '');\n          columns.name = indexName;\n          options.uniqueKeys[indexName] = index;\n\n          // Autogenerate Constraint name, if no indexName is given\n          if (indexName.length === 0) {\n            values.attributes += `,UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ') })`;\n          } else {\n            values.attributes +=\n              `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ') })`;\n          }\n        }\n      });\n    }\n\n    // we replace single quotes by two quotes in order for the execute statement to work\n    const query = Utils.joinSQLFragments([\n      'CREATE TABLE',\n      values.table,\n      `(${values.attributes})`\n    ]);\n\n    return Utils.joinSQLFragments([\n      'BEGIN',\n      'EXECUTE IMMEDIATE',\n      `${this.escape(query)};`,\n      'EXCEPTION WHEN OTHERS THEN',\n      'IF SQLCODE != -955 THEN',\n      'RAISE;',\n      'END IF;',\n      'END;'\n    ]);\n  }\n\n  tableExistsQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    return `SELECT TABLE_NAME FROM ALL_TABLES WHERE TABLE_NAME = ${this.escape(tableName)} AND OWNER = ${table.schema ? this.escape(schemaName) : 'USER'}`;\n  }\n  \n  describeTableQuery(tableName, schema) {\n    const currTableName = this.getCatalogName(tableName.tableName || tableName);\n    schema = this.getCatalogName(schema);\n    // name, type, datalength (except number / nvarchar), datalength varchar, datalength number, nullable, default value, primary ?\n    return [\n      'SELECT atc.COLUMN_NAME, atc.DATA_TYPE, atc.DATA_LENGTH, atc.CHAR_LENGTH, atc.DEFAULT_LENGTH, atc.NULLABLE, ucc.constraint_type ',\n      'FROM all_tab_columns atc ',\n      'LEFT OUTER JOIN ',\n      '(SELECT acc.column_name, acc.table_name, ac.constraint_type FROM all_cons_columns acc INNER JOIN all_constraints ac ON acc.constraint_name = ac.constraint_name) ucc ',\n      'ON (atc.table_name = ucc.table_name AND atc.COLUMN_NAME = ucc.COLUMN_NAME) ',\n      schema\n        ? `WHERE (atc.OWNER = ${this.escape(schema)}) `\n        : 'WHERE atc.OWNER = USER ',\n      `AND (atc.TABLE_NAME = ${this.escape(currTableName)})`,\n      'ORDER BY atc.COLUMN_NAME, CONSTRAINT_TYPE DESC'\n    ].join('');\n  }\n\n  renameTableQuery(before, after) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(before),\n      'RENAME TO',\n      this.quoteTable(after)\n    ]);\n  }\n\n  showConstraintsQuery(table) {\n    const tableName = this.getCatalogName(table.tableName || table);\n    return `SELECT CONSTRAINT_NAME constraint_name FROM user_cons_columns WHERE table_name = ${this.escape(tableName)}`;\n  }\n\n  showTablesQuery() {\n    return 'SELECT owner as table_schema, table_name, 0 as lvl FROM all_tables where OWNER IN(SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE ORACLE_MAINTAINED = \\'N\\')';\n  }\n\n  dropTableQuery(tableName) {\n    return Utils.joinSQLFragments([\n      'BEGIN ',\n      'EXECUTE IMMEDIATE \\'DROP TABLE',\n      this.quoteTable(tableName),\n      'CASCADE CONSTRAINTS PURGE\\';',\n      'EXCEPTION WHEN OTHERS THEN',\n      ' IF SQLCODE != -942 THEN',\n      '   RAISE;',\n      ' END IF;',\n      'END;'\n    ]);\n  }\n\n  /*\n    Modifying the indexname so that it is prefixed with the schema name\n    otherwise Oracle tries to add the index to the USER schema\n   @overide\n  */\n  addIndexQuery(tableName, attributes, options, rawTablename) {\n    if (typeof tableName !== 'string' && attributes.name) {\n      attributes.name = `${tableName.schema}.${attributes.name}`;\n    }\n    return super.addIndexQuery(tableName, attributes, options, rawTablename);\n  }\n\n  addConstraintQuery(tableName, options) {\n    options = options || {};\n\n    if (options.onUpdate) {\n      // Oracle does not support ON UPDATE, remove it.\n      delete options.onUpdate;\n    }\n\n    if (options.onDelete && options.onDelete.toUpperCase() === 'NO ACTION') {\n      // 'ON DELETE NO ACTION' is the default option in Oracle, but it is not supported if defined\n      delete options.onDelete;\n    }\n\n    const constraintSnippet = this.getConstraintSnippet(tableName, options);\n\n    tableName = this.quoteTable(tableName);\n    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;\n  }\n\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n\n    const attribute = Utils.joinSQLFragments([\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        attributeName: key,\n        context: 'addColumn'\n      })\n    ]);\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'ADD',\n      attribute\n    ]);\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP COLUMN',\n      this.quoteIdentifier(attributeName),\n      ';'\n    ]);\n  }\n\n  /**\n   * Function to add new foreign key to the attribute \n   * Block for add and drop foreign key constraint query\n   * taking the assumption that there is a single column foreign key reference always\n   * i.e. we always do - FOREIGN KEY (a) reference B(a) during createTable queryGenerator\n   * so there would be one and only one match for a constraint name for each column\n   * and every foreign keyed column would have a different constraint name\n   * Since sequelize doesn't support multiple column foreign key, added complexity to\n   * add the feature isn't needed\n   *\n   * @param {string} definition The operation that needs to be performed on the attribute\n   * @param {string|object} table The table that needs to be altered\n   * @param {string} attributeName The name of the attribute which would get altered\n   */\n  _alterForeignKeyConstraint(definition, table, attributeName) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const attributeNameConstant = this.escape(this.getCatalogName(attributeName));\n    const schemaNameConstant = table.schema ? this.escape(this.getCatalogName(schemaName)) : 'USER';\n    const tableNameConstant = this.escape(this.getCatalogName(tableName));\n    const getConsNameQuery = [\n      'SELECT constraint_name INTO cons_name',\n      'FROM (',\n      '  SELECT DISTINCT cc.owner, cc.table_name, cc.constraint_name, cc.column_name AS cons_columns',\n      '  FROM all_cons_columns cc, all_constraints c',\n      '  WHERE cc.owner = c.owner',\n      '  AND cc.table_name = c.table_name',\n      '  AND cc.constraint_name = c.constraint_name',\n      '  AND c.constraint_type = \\'R\\'',\n      '  GROUP BY cc.owner, cc.table_name, cc.constraint_name, cc.column_name',\n      ')',\n      'WHERE owner =',\n      schemaNameConstant,\n      'AND table_name =',\n      tableNameConstant,\n      'AND cons_columns =',\n      attributeNameConstant,\n      ';'\n    ].join(' ');\n    const secondQuery = Utils.joinSQLFragments([\n      `ALTER TABLE ${this.quoteIdentifier(tableName)}`,\n      'ADD FOREIGN KEY',\n      `(${this.quoteIdentifier(attributeName)})`,\n      definition.replace(/.+?(?=REFERENCES)/, '')\n    ]);\n    return [\n      'BEGIN',\n      getConsNameQuery,\n      'EXCEPTION',\n      'WHEN NO_DATA_FOUND THEN',\n      ' CONS_NAME := NULL;',\n      'END;',\n      'IF CONS_NAME IS NOT NULL THEN',\n      ` EXECUTE IMMEDIATE 'ALTER TABLE ${this.quoteTable(table)} DROP CONSTRAINT \"'||CONS_NAME||'\"';`,\n      'END IF;',\n      `EXECUTE IMMEDIATE ${this.escape(secondQuery)};`\n    ].join(' ');\n  }\n\n  /**\n   * Function to alter table modify\n   *\n   * @param {string} definition The operation that needs to be performed on the attribute\n   * @param {object|string} table The table that needs to be altered\n   * @param {string} attributeName The name of the attribute which would get altered\n   */\n  _modifyQuery(definition, table, attributeName) {\n    const query = Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'MODIFY',\n      this.quoteIdentifier(attributeName),\n      definition\n    ]);\n    const secondQuery = query.replace('NOT NULL', '').replace('NULL', '');\n    return [\n      'BEGIN',\n      `EXECUTE IMMEDIATE ${this.escape(query)};`,\n      'EXCEPTION',\n      'WHEN OTHERS THEN',\n      ' IF SQLCODE = -1442 OR SQLCODE = -1451 THEN',\n      // We execute the statement without the NULL / NOT NULL clause if the first statement failed due to this\n      `   EXECUTE IMMEDIATE ${this.escape(secondQuery)};`,\n      ' ELSE',\n      '   RAISE;',\n      ' END IF;',\n      'END;'\n    ].join(' ');\n  }\n\n  changeColumnQuery(table, attributes) {\n    const sql = [\n      'DECLARE',\n      'CONS_NAME VARCHAR2(200);',\n      'BEGIN'\n    ];\n    for (const attributeName in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attributeName)) continue;\n      const definition = attributes[attributeName];\n      if (definition.match(/REFERENCES/)) {\n        sql.push(this._alterForeignKeyConstraint(definition, table, attributeName));\n      } else {\n        // Building the modify query\n        sql.push(this._modifyQuery(definition, table, attributeName));\n      }\n    }\n    sql.push('END;');\n    return sql.join(' ');\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(newName)}`;\n  }\n\n  /**\n   * Populates the returnAttributes array with outbind bindByPosition values\n   * and also the options.outBindAttributes map with bindDef for outbind of InsertQuery\n   *\n   * @param {Array} returningModelAttributes\n   * @param {Array} returnTypes\n   * @param {number} inbindLength\n   * @param {object} returnAttributes\n   * @param {object} options\n   *\n   * @private\n   */\n  populateInsertQueryReturnIntoBinds(returningModelAttributes, returnTypes, inbindLength, returnAttributes, options) {\n    const oracledb = this.sequelize.connectionManager.lib;\n    const outBindAttributes = Object.create(null);\n    const outbind = [];\n    const outbindParam = this.bindParam(outbind, inbindLength);\n    returningModelAttributes.forEach((element, index) => {\n      // generateReturnValues function quotes identifier based on the quoteIdentifier option\n      // If the identifier starts with a quote we remove it else we use it as is\n      if (element.startsWith('\"')) {\n        element = element.substring(1, element.length - 1);\n      }\n      outBindAttributes[element] = Object.assign(returnTypes[index]._getBindDef(oracledb), { dir: oracledb.BIND_OUT });\n      const returnAttribute = `${this.format(undefined, undefined, { context: 'INSERT' }, outbindParam)}`;\n      returnAttributes.push(returnAttribute);\n    });\n    options.outBindAttributes = outBindAttributes;\n  }\n\n  /**\n   * Override of upsertQuery, Oracle specific\n   * Using PL/SQL for finding the row\n   *\n   * @param {object|string} tableName\n   * @param {Array} insertValues\n   * @param {Array} updateValues\n   * @param {Array} where\n   * @param {object} model\n   * @param {object} options\n   */\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    const rawAttributes = model.rawAttributes;\n    const updateQuery = this.updateQuery(tableName, updateValues, where, options, rawAttributes);\n    // This bind is passed so that the insert query starts appending to this same bind array\n    options.bind = updateQuery.bind;\n    const insertQuery = this.insertQuery(tableName, insertValues, rawAttributes, options);\n\n    const sql = [\n      'DECLARE ',\n      'BEGIN ',\n      updateQuery.query ? [ \n        updateQuery.query,\n        '; ',\n        ' IF ( SQL%ROWCOUNT = 0 ) THEN ',\n        insertQuery.query,\n        ' :isUpdate := 0; ',\n        'ELSE ',\n        ' :isUpdate := 1; ',\n        ' END IF; '\n      ].join('') : [\n        insertQuery.query,\n        ' :isUpdate := 0; ',\n        // If there is a conflict on insert we ignore\n        'EXCEPTION WHEN OTHERS THEN',\n        ' IF SQLCODE != -1 THEN',\n        '   RAISE;',\n        ' END IF;'\n      ].join(''),\n      'END;'\n    ];\n\n    const query = sql.join('');\n    const result = { query };\n    \n    if (options.bindParam !== false) {\n      result.bind = updateQuery.bind || insertQuery.bind;\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns an insert into command for multiple values.\n   *\n   * @param {string} tableName\n   * @param {object} fieldValueHashes\n   * @param {object} options\n   * @param {object} fieldMappedAttributes\n   *\n   * @private\n   */\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n    options = options || {};\n    options.executeMany = true;\n    fieldMappedAttributes = fieldMappedAttributes || {};\n\n    const tuples = [];\n    const allColumns = {};\n    const inBindBindDefMap = {};\n    const outBindBindDefMap = {};\n    const oracledb = this.sequelize.connectionManager.lib;\n\n    // Generating the allColumns map\n    // The data is provided as an array of objects. \n    // Each object may contain differing numbers of attributes. \n    // A set of the attribute names that are used in all objects must be determined. \n    // The allColumns map contains the column names and indicates whether the value is generated or not\n    // We set allColumns[key] to true if the field is an\n    // auto-increment field and the value given is null and fieldMappedAttributes[key]\n    // is valid for the specific column else it is set to false\n    for (const fieldValueHash of fieldValueHashes) {\n      _.forOwn(fieldValueHash, (value, key) => {\n        allColumns[key] = fieldMappedAttributes[key] && fieldMappedAttributes[key].autoIncrement === true && value === null;\n      });\n    }\n\n    // Building the inbind parameter\n    // A list that would have inbind positions like [:1, :2, :3...] to be used in generating sql string\n    let inBindPosition;\n    // Iterating over each row of the fieldValueHashes\n    for (const fieldValueHash of fieldValueHashes) {\n      // Has each column for a row after coverting it to appropriate format using this.format function\n      // like ['Mick', 'Broadstone', 2022-02-16T05:24:18.949Z, 2022-02-16T05:24:18.949Z],\n      const tuple = [];\n      // A function expression for this.bindParam/options.bindparam function\n      // This function is passed to this.format function which inserts column values to the tuple list\n      // using _bindParam/_stringify function in data-type.js file\n      const inbindParam = options.bindParam === undefined ? this.bindParam(tuple) : options.bindParam;\n      // We are iterating over each col\n      // and pushing the given values to tuple list using this.format function\n      // and also simultaneously generating the bindPosition\n      // tempBindPostions has the inbind positions\n      const tempBindPositions = Object.keys(allColumns).map(key => {\n        if (allColumns[key] === true) {\n          // We had set allAttributes[key] to true since at least one row for an auto increment column was null\n          // If we get any other row that has this specific column as non-null we must raise an error\n          // Since for an auto-increment column, either all row has to be null or all row has to be a non-null\n          if (fieldValueHash[key] !== null) {\n            throw Error('For an auto-increment column either all row must be null or non-null, a mix of null and non-null is not allowed!');\n          }\n          // Return DEFAULT for auto-increment column and if all values for the column is null in each row\n          return 'DEFAULT';\n        }\n        // Sanitizes the values given by the user and pushes it to the tuple list using inBindParam function and\n        // also generates the inbind position for the sql string for example (:1, :2, :3.....) which is a by product of the push\n        return this.format(fieldValueHash[key], fieldMappedAttributes[key], { context: 'INSERT' }, inbindParam);\n      });\n\n      // Even though the bind variable positions are calculated for each row we only retain the values for the first row \n      // since the values will be identical\n      if (!inBindPosition) {\n        inBindPosition = tempBindPositions;\n      }\n      // Adding the row to the array of rows that will be supplied to executeMany()\n      tuples.push(tuple);\n    }\n\n    // The columns that we are expecting to be returned from the DB like [\"id1\", \"id2\"...]\n    const returnColumn = [];\n    // The outbind positions for the returning columns like [:3, :4, :5....]\n    const returnColumnBindPositions = [];\n    // Has the columns name in which data would be inserted like [\"id\", \"name\".....]\n    const insertColumns = [];\n    // Iterating over the allColumns keys to get the bindDef for inbind and outbinds\n    // and also to get the list of insert and return column after applying this.quoteIdentifier\n    for (const key of Object.keys(allColumns)) {\n      // If fieldMappenAttributes[attr] is defined we generate the bindDef \n      // and return clause else we can skip it\n      if (fieldMappedAttributes[key]) {\n        // BindDef for the specific column\n        const bindDef = fieldMappedAttributes[key].type._getBindDef(oracledb);\n        if (allColumns[key]) {\n          // Binddef for outbinds\n          bindDef.dir = oracledb.BIND_OUT;\n          outBindBindDefMap[key] = bindDef;\n\n          // Building the outbind parameter list\n          // ReturnColumn has the column name for example \"id\", \"usedId\", quoting depends on quoteIdentifier option\n          returnColumn.push(this.quoteIdentifier(key));\n          // Pushing the outbind index to the returnColumnPositions to generate (:3, :4, :5)\n          // The start offset depend on the tuple length (bind array size of a particular row)\n          // the outbind position starts after the position where inbind position ends\n          returnColumnBindPositions.push(`:${tuples[0].length + returnColumn.length}`);\n        } else {\n          // Binddef for inbinds\n          bindDef.dir = oracledb.BIND_IN;\n          inBindBindDefMap[key] = bindDef;\n        }\n      }\n      // Quoting and pushing each insert column based on quoteIdentifier option\n      insertColumns.push(this.quoteIdentifier(key));\n    }\n   \n    // Generating the sql query\n    let query = Utils.joinSQLFragments([\n      'INSERT',\n      'INTO',\n      // Table name for the table in which data needs to inserted\n      this.quoteTable(tableName),\n      // Columns names for the columns of the table (example \"a\", \"b\", \"c\" - quoting depends on the quoteidentifier option)\n      `(${insertColumns.join(',')})`,\n      'VALUES',\n      // InBind position for the insert query (for example :1, :2, :3....)\n      `(${inBindPosition})`\n    ]);\n\n    // If returnColumn.length is > 0\n    // then the returning into clause is needed\n    if (returnColumn.length > 0) {\n      options.outBindAttributes = outBindBindDefMap;\n      query = Utils.joinSQLFragments([\n        query,\n        'RETURNING',\n        // List of return column (for example \"id\", \"userId\"....)\n        `${returnColumn.join(',')}`,\n        'INTO',\n        // List of outbindPosition (for example :4, :5, :6....)\n        // Start offset depends on where inbindPosition end\n        `${returnColumnBindPositions}`\n      ]);\n    }\n\n    // Binding the bind variable to result\n    const result = { query };\n    // Binding the bindParam to result\n    // Tuple has each row for the insert query\n    result.bind = tuples;\n    // Setting options.inbindAttribute\n    options.inbindAttributes = inBindBindDefMap;\n    return result;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options, model) {\n    options = options || {};\n\n    const table = tableName;\n\n    where = this.getWhereConditions(where, null, model, options);\n    let queryTmpl;\n    // delete with limit <l> and optional condition <e> on Oracle: DELETE FROM <t> WHERE rowid in (SELECT rowid FROM <t> WHERE <e> AND rownum <= <l>)\n    // Note that the condition <e> has to be in the subquery; otherwise, the subquery would select <l> arbitrary rows.\n    if (options.limit) {\n      const whereTmpl = where ? ` AND ${where}` : '';\n      queryTmpl =\n        `DELETE FROM ${this.quoteTable(table)} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(table)} WHERE rownum <= ${this.escape(options.limit)}${ \n          whereTmpl \n        })`;\n    } else {\n      const whereTmpl = where ? ` WHERE ${where}` : '';\n      queryTmpl = `DELETE FROM ${this.quoteTable(table)}${whereTmpl}`;\n    }\n    return queryTmpl;\n  }\n\n  showIndexesQuery(table) {\n    const [tableName, owner] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      'SELECT i.index_name,i.table_name, i.column_name, u.uniqueness, i.descend, c.constraint_type ',\n      'FROM all_ind_columns i ',\n      'INNER JOIN all_indexes u ',\n      'ON (u.table_name = i.table_name AND u.index_name = i.index_name) ',\n      'LEFT OUTER JOIN all_constraints c ',\n      'ON (c.table_name = i.table_name AND c.index_name = i.index_name) ',\n      `WHERE i.table_name = ${this.escape(tableName)}`,\n      ' AND u.table_owner = ',\n      owner ? this.escape(owner) : 'USER',\n      ' ORDER BY index_name, column_position'\n    ];\n\n    return sql.join('');\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName }_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX ${this.quoteIdentifier(indexName)}`;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    // TODO: Address on update cascade issue whether to throw error or ignore.\n    // Add this to documentation when merging to sequelize-main\n    // ON UPDATE CASCADE IS NOT SUPPORTED BY ORACLE.\n    attribute.onUpdate = '';\n\n    // handle self referential constraints\n    if (attribute.references) {\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log(\n          'Oracle does not support self referencial constraints, ' +\n            'we will remove it but we recommend restructuring your query'\n        );\n        attribute.onDelete = '';\n      }\n    }\n\n    let template;\n\n    template = attribute.type.toSql ? attribute.type.toSql() : '';\n    if (attribute.type instanceof DataTypes.JSON) {\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IS JSON)`;\n      return template;\n    }\n    if (Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    }\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n      // enums are a special case\n      template +=\n        ` CHECK (${this.quoteIdentifier(options.attributeName)} IN(${ \n          _.map(attribute.values, value => {\n            return this.escape(value);\n          }).join(', ') \n        }))`;\n      return template;\n    } \n    if (attribute.type instanceof DataTypes.BOOLEAN) {\n      template +=\n        ` CHECK (${this.quoteIdentifier(options.attributeName)} IN('1', '0'))`;\n      return template;\n    } \n    if (attribute.autoIncrement) {\n      template = ' NUMBER(*,0) GENERATED BY DEFAULT ON NULL AS IDENTITY';\n    } else if (attribute.type && attribute.type.key === DataTypes.DOUBLE.key) {\n      template = attribute.type.toSql();\n    } else if (attribute.type) {\n      // setting it to false because oracle doesn't support unsigned int so put a check to make it behave like unsigned int\n      let unsignedTemplate = '';\n      if (attribute.type._unsigned) {\n        attribute.type._unsigned = false;\n        unsignedTemplate += ` check(${this.quoteIdentifier(options.attributeName)} >= 0)`;\n      }\n      template = attribute.type.toString();\n\n      // Blobs/texts cannot have a defaultValue\n      if (\n        attribute.type &&\n        attribute.type !== 'TEXT' &&\n        attribute.type._binary !== true &&\n        Utils.defaultValueSchemable(attribute.defaultValue)\n      ) {\n        template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n      }\n\n      if (!attribute.autoIncrement) {\n        // If autoincrement, not null is set automatically\n        if (attribute.allowNull === false) {\n          template += ' NOT NULL';\n        } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n          template += ' NULL';\n        }\n      }\n      template += unsignedTemplate;\n    } else {\n      template = '';\n    }\n\n    if (attribute.unique === true && !attribute.primaryKey) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key) })`;\n      } else {\n        template += ` (${this.quoteIdentifier('id') })`;\n      }\n\n      if (attribute.onDelete && attribute.onDelete.toUpperCase() !== 'NO ACTION') {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      const attributeName = attribute.field || key;\n      result[attributeName] = this.attributeToSQL(attribute, { attributeName, ...options });\n    }\n\n    return result;\n  }\n\n  createTrigger() {\n    throwMethodUndefined('createTrigger');\n  }\n\n  dropTrigger() {\n    throwMethodUndefined('dropTrigger');\n  }\n\n  renameTrigger() {\n    throwMethodUndefined('renameTrigger');\n  }\n\n  createFunction() {\n    throwMethodUndefined('createFunction');\n  }\n\n  dropFunction() {\n    throwMethodUndefined('dropFunction');\n  }\n\n  renameFunction() {\n    throwMethodUndefined('renameFunction');\n  }\n\n  getConstraintsOnColumn(table, column) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    column = this.getCatalogName(column);\n    const sql = [\n      'SELECT CONSTRAINT_NAME FROM user_cons_columns WHERE TABLE_NAME = ',\n      this.escape(tableName),\n      ' and OWNER = ',\n      table.schema ? this.escape(schemaName) : 'USER',\n      ' and COLUMN_NAME = ',\n      this.escape(column),\n      ' AND POSITION IS NOT NULL ORDER BY POSITION'\n    ].join('');\n\n    return sql;\n  }\n\n  getForeignKeysQuery(table) {\n    // We don't call quoteTable as we don't want the schema in the table name, Oracle seperates it on another field\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      'SELECT DISTINCT  a.table_name \"tableName\", a.constraint_name \"constraintName\", a.owner \"owner\",  a.column_name \"columnName\",', \n      ' b.table_name \"referencedTableName\", b.column_name \"referencedColumnName\"',\n      ' FROM all_cons_columns a',\n      ' JOIN all_constraints c ON a.owner = c.owner AND a.constraint_name = c.constraint_name',\n      ' JOIN all_cons_columns b ON c.owner = b.owner AND c.r_constraint_name = b.constraint_name',\n      \" WHERE c.constraint_type  = 'R'\",\n      ' AND a.table_name = ',\n      this.escape(tableName),\n      ' AND a.owner = ',\n      table.schema ? this.escape(schemaName) : 'USER',\n      ' ORDER BY a.table_name, a.constraint_name'\n    ].join('');\n\n    return sql;\n  }\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return this.dropConstraintQuery(tableName, foreignKey);\n  }\n\n  getPrimaryKeyConstraintQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      'SELECT cols.column_name, atc.identity_column ',\n      'FROM all_constraints cons, all_cons_columns cols ',\n      'INNER JOIN all_tab_columns atc ON(atc.table_name = cols.table_name AND atc.COLUMN_NAME = cols.COLUMN_NAME )',\n      'WHERE cols.table_name = ',\n      this.escape(tableName),\n      'AND cols.owner = ',\n      table.schema ? this.escape(schemaName) : 'USER ',\n      \"AND cons.constraint_type = 'P' \",\n      'AND cons.constraint_name = cols.constraint_name ',\n      'AND cons.owner = cols.owner ',\n      'ORDER BY cols.table_name, cols.position'\n    ].join('');\n\n    return sql;\n  }\n\n  dropConstraintQuery(tableName, constraintName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${constraintName}`;\n  }\n\n  setIsolationLevelQuery(value, options) {\n    if (options.parent) {\n      return;\n    }\n\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return 'SET TRANSACTION ISOLATION LEVEL READ COMMITTED;';\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        // Serializable mode is equal to Snapshot Isolation (SI) \n        // defined in ANSI std.\n        return 'SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;';\n      default:\n        throw new Error(`isolation level \"${value}\" is not supported`);\n    }\n  }\n\n  getAliasToken() {\n    return '';\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;\n    }\n\n    return 'BEGIN TRANSACTION';\n  }\n\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return 'COMMIT TRANSACTION';\n  }\n\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TO SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;\n    }\n\n    return 'ROLLBACK TRANSACTION';\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    let str;\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      }\n      if (smth.path) {\n\n        // Allow specifying conditions using the sqlite json functions\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    }\n    if (smth instanceof Utils.Cast) {\n      if (smth.val instanceof Utils.SequelizeMethod) {\n        str = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n        if (smth.type === 'boolean') {\n          str = `(CASE WHEN ${str}='true' THEN 1 ELSE 0 END)`;\n          return `CAST(${str} AS NUMBER)`;\n        } if (smth.type === 'timestamptz' && /json_value\\(/.test(str)) {\n          str = str.slice(0, -1);\n          return `${str} RETURNING TIMESTAMP WITH TIME ZONE)`;\n        }\n      }\n    }\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  jsonPathExtractionQuery(column, path) {\n    let paths = _.toPath(path);\n    const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n\n    paths = paths.map(subPath => {\n      return /\\D/.test(subPath) ? Utils.addTicks(subPath, '\"') : subPath;\n    });\n\n    const pathStr = this.escape(['$'].concat(paths).join('.').replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (__, digit) => `[${digit}]`));\n\n    return `json_value(${quotedColumn},${pathStr})`;\n  }\n\n  addLimitAndOffset(options, model) {\n    let fragment = '';\n    const offset = options.offset || 0,\n      isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n\n    let orders = {};\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n\n    if (options.limit || options.offset) {\n      // Add needed order by clause only when it is not provided\n      if (!orders.mainQueryOrder || !orders.mainQueryOrder.length || isSubQuery && (!orders.subQueryOrder || !orders.subQueryOrder.length)) {\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(model.primaryKeyField)}`;\n        fragment += ` ORDER BY ${tablePkFragment}`;\n      }\n\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n\n    return fragment;\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  quoteIdentifier(identifier, force = false) {\n    const optForceQuote = force;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n    const regExp = /^(([\\w][\\w\\d_]*))$/g;\n\n    if (\n      optForceQuote !== true &&\n      optQuoteIdentifiers === false &&\n      regExp.test(rawIdentifier) &&\n      !ORACLE_RESERVED_WORDS.includes(rawIdentifier.toUpperCase())\n    ) {\n      // In Oracle, if tables, attributes or alias are created double-quoted,\n      // they are always case sensitive. If they contain any lowercase\n      // characters, they must always be double-quoted otherwise it\n      // would get uppercased by the DB.\n      // Here, we strip quotes if we don't want case sensitivity.\n      return rawIdentifier;\n    }\n    return Utils.addTicks(rawIdentifier, '\"');\n  }\n\n  /**\n * It causes bindbyPosition like :1, :2, :3\n * We pass the val parameter so that the outBind indexes\n * starts after the inBind indexes end\n *\n * @param {Array} bind\n * @param {number} posOffset\n */\n  bindParam(bind, posOffset = 0) {\n    return value => {\n      bind.push(value);\n      return `:${bind.length + posOffset}`;\n    };\n  }\n\n  /**\n   * Returns the authenticate test query string\n   */\n  authTestQuery() {\n    return 'SELECT 1+1 AS result FROM DUAL';\n  }\n}\n\n/* istanbul ignore next */\nfunction throwMethodUndefined(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}